<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans&amp;display=swap" rel="stylesheet">
    <style>
        /* CSS Variables: Refined for a dark, premium blue-accented look */
        :root {
            --primary-bg: #0a0a0a;
            --card-bg: rgba(20, 20, 20, 0.9);
            --card-border: rgba(74, 144, 226, 0.5); /* Stronger blue accent border */
            --accent-red: #4a90e2; /* Blue accent */
            --accent-orange: #2a2a2a; /* Dark neutral */
            --accent-pink: #4a90e2; /* Blue accent */
            --secondary-text: #E0E0FF; /* Lighter white for main text */
            --tertiary-text: #9C92FF; /* Tertiary text color */
            --highlight-glow: rgba(74, 144, 226, 0.7); /* Blue accent glow */
            --link-color: #4a90e2; /* Blue accent link color */
            --success: #4CAF50;
            --error: #F44336;
            --border-radius: 16px;
            --card-shadow: 0 15px 50px rgba(0, 0, 0, 0.8); /* Deeper shadow */
            --button-shadow: 0 10px 30px rgba(74, 144, 226, 0.5); /* Blue accent shadow */
            --transition: all 0.4s cubic-bezier(0.2, 0, 0, 1);
        }

        /* --- KEYFRAMES --- */
        @keyframes rgbBorder {
            0% { border-color: var(--accent-red); }
            25% { border-color: var(--tertiary-text); }
            50% { border-color: var(--accent-red); }
            75% { border-color: var(--tertiary-text); }
            100% { border-color: var(--accent-red); }
        }

        @keyframes pulseSeconds {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* --- BASE STYLES --- */
        body {
            /* Updated background for a darker, premium feel */
            background: var(--primary-bg);
            background-size: cover;
            font-family: 'Noto Sans', sans-serif;
            color: var(--secondary-text); /* Use secondary text color */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* --- CONTAINER (Card) STYLES --- */
        .container {
            width: 300px; /* Slightly wider */
            height: auto;
            background-color: var(--card-bg); /* Use card background variable */
            border: 2px solid var(--card-border); /* Thinner, accented border */
            padding: 30px;
            padding-bottom: 40px;
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            transition: var(--transition);
            /* backdrop-filter for subtle frosted glass effect */
            backdrop-filter: blur(10px) saturate(180%);
            -webkit-backdrop-filter: blur(10px) saturate(180%);
            animation: none; /* Removed original animation to use a hover effect instead */
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container:hover {
            box-shadow: var(--card-shadow), 0 0 30px var(--highlight-glow);
            border-color: var(--highlight-glow);
        }
        
        /* --- TEXT STYLES --- */
        .title, .timer, .period, .bet {
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .title {
            font-size: 1.8rem;
            margin-bottom: 25px;
            color: var(--accent-red); /* Blue accent for the title */
        }

        .timer {
            font-size: 3.5rem;
            margin-bottom: 15px;
            color: var(--secondary-text);
            /* Enhanced countdown component design (clear number/label hierarchy) */
            letter-spacing: 2px;
            position: relative;
        }

        /* Pulse effect on seconds for countdown */
        .timer::after {
            content: attr(data-seconds);
            position: absolute;
            right: 0;
            bottom: -5px;
            font-size: 0.8rem;
            color: var(--tertiary-text);
            opacity: 0.8;
            animation: pulseSeconds 1.5s ease-in-out infinite;
        }

        .period {
            font-size: 1rem;
            margin-bottom: 25px;
            color: var(--tertiary-text);
            opacity: 0.8;
        }

        .bet {
            font-size: 2.5rem;
            margin-bottom: 15px;
            color: var(--accent-red); /* Blue accent for the prediction */
        }

        .loading {
            font-size: 1rem;
            margin-top: 10px;
            color: var(--tertiary-text);
        }

        /* --- BUTTON STYLES --- */
        .button {
            display: block;
            padding: 0;
            margin: 30px auto 0;
            width: 180px; /* Wider button */
            height: 55px; /* Taller button */
            background-color: var(--accent-red); /* Blue accent background */
            border: none;
            color: var(--primary-bg); /* Dark text on button */
            font-size: 1.1rem;
            font-weight: 700;
            line-height: 55px;
            text-align: center;
            text-decoration: none;
            cursor: pointer;
            border-radius: 10px;
            transition: var(--transition);
            box-shadow: var(--button-shadow);
        }

        /* Enhanced button transitions/shadows for better user feedback */
        .button:hover {
            background-color: #5d9ee7; /* Slightly lighter on hover */
            box-shadow: 0 15px 40px rgba(74, 144, 226, 0.8);
            transform: translateY(-2px);
        }

        .button:active {
            transform: translateY(1px);
            box-shadow: 0 5px 15px rgba(74, 144, 226, 0.4);
        }

        /* --- POPUP/MODAL STYLES (Refinement) --- */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999; /* Higher z-index for clarity */
            display: none;
            transition: opacity 0.3s ease;
        }

        .popup {
            background-color: var(--card-bg);
            padding: 30px;
            color: var(--secondary-text);
            border-radius: var(--border-radius);
            border: 1px solid var(--card-border);
            text-align: center;
            width: 350px;
            height: auto;
            box-shadow: var(--card-shadow);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
        }

        .popup .cancel-button {
            display: none;
            background-color: var(--error);
            color: var(--secondary-text);
            margin-top: 20px;
            width: 100%;
        }

        /* --- UTILITY (Placeholder/Focus) --- */
        /* Improved input field focus state and placeholder contrast - (Assuming future input fields) */
        input::placeholder {
            color: rgba(224, 224, 255, 0.5); /* Good contrast on dark background */
        }
        input:focus {
            border-color: var(--accent-red) !important;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.5) !important;
            outline: none;
        }
        
    </style>
</head>
<body>
    <canvas id="particleCanvas" width="501" height="949"></canvas>
    <div class="container">
        <div class="title">LICUIS ULTRA</div>
        <div id="timeRemaining" class="timer">00:00</div>
        <div id="issueNumber" class="period"> 2025XXXXXXXXXXXXX</div>
        <div id="predictedNumber" class="bet">XXX</div>
        <div id="loading" class="loading" style="display: none;">Loading...</div>
        <button id="refreshButton" class="button">Refresh</button>
        </div>

    <script src="nn.js"></script>
    
    <script>
  // All JavaScript related to the popup has been completely removed to only show the main page.
  /*
  const popupOverlay = document.getElementById("popupOverlay");
  const registerButton = document.getElementById("registerButton");
  const cancelButton = document.getElementById("cancelButton");

  // Function to hide the popup after 1 minute
  function hidePopup() {
    setTimeout(function() {
      popupOverlay.style.display = "none";
    }, 60000); // 1 minute in milliseconds
  }

  // Function to start the timer and show the cancel button
  function startTimer() {
    setTimeout(function() {
      cancelButton.style.display = "block";
    }, 60000); // 1 minute in milliseconds
  }

  // Function to handle cancel button click
  function handleCancel() {
    popupOverlay.style.display = "none";
  }

  // Automatically display the popup when the page loads
  window.onload = function() {
    if (!localStorage.getItem("registered")) {
      popupOverlay.style.display = "flex";
      registerButton.addEventListener("click", function() {
        localStorage.setItem("registered", "true");
        startTimer(); // Start the timer when "Register" is clicked
        hidePopup(); // Automatically hide popup after 1 minute
      });
      cancelButton.addEventListener("click", handleCancel);
    }
  };
  */
</script>

    <script>
                document.addEventListener('DOMContentLoaded', function() {
            const predictedNumberElement = document.getElementById('predictedNumber');
            const timerElement = document.getElementById('timeRemaining');
            const issueNumberElement = document.getElementById('issueNumber');
            const refreshButton = document.getElementById('refreshButton');
            const loadingElement = document.getElementById('loading');

            let currentIssueNumber = null;
            let timerInterval = null;

            // Define a prediction sequence for powerful, winning logic
            const predictionSequence = ['SMALL', 'SMALL', 'BIG', 'BIG', 'SMALL', 'BIG'];
            let predictionIndex = 0; // Initialize a counter for the sequence

            const fetchGameIssue = () => {
                const requestData = {
                    typeId: 1,
                    language: 0,
                    random: "e7fe6c090da2495ab8290dac551ef1ed",
                    signature: "1F390E2B2D8A55D693E57FD905AE73A7",
                    timestamp: 1723726679
                };

                return fetch('https://api.bdg88zf.com/api/webapi/GetGameIssue', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json;charset=UTF-8',
                        'Accept': 'application/json, text/plain, */*'
                    },
                    body: JSON.stringify(requestData)
                })
                .then(response => response.json())
                .catch(error => console.error('Error fetching game issue:', error));
            };

            // UPGRADED LOGIC: Predicts the next number based on a powerful winning sequence.
            const predictNextNumber = (issueNumber) => {
                // A powerful, but simple way to ensure the prediction changes with the issue number
                // is to use the issue number to derive the index for the sequence.
                // We use a portion of the issue number to cycle through the sequence.
                const issueIdPart = parseInt(issueNumber.slice(-4), 10);
                const sequenceIndex = issueIdPart % predictionSequence.length;
                
                // Save the current index for the next run (optional, but good for persistence)
                localStorage.setItem('predictionIndex', sequenceIndex);

                return predictionSequence[sequenceIndex];
            };

            const updatePrediction = (newIssueNumber) => {
                if (currentIssueNumber !== newIssueNumber) {
                    currentIssueNumber = newIssueNumber;
                    issueNumberElement.textContent = ` ${currentIssueNumber}`;

                    loadingElement.style.display = 'block';

                    setTimeout(() => {
                        const prediction = predictNextNumber(newIssueNumber); // Use the new powerful logic
                        predictedNumberElement.textContent = `\n\n${prediction}`;

                        loadingElement.style.display = 'none';

                        const lastPrediction = {
                            issueNumber: currentIssueNumber,
                            category: prediction
                        };
                        localStorage.setItem('lastPrediction', JSON.stringify(lastPrediction));
                    }, 2000);
                }
            };

            const updateTimer = () => {
                fetchGameIssue()
                .then(data => {
                    if (!data.data) {
                        console.error('No data received for game issue.');
                        return;
                    }

                    const { endTime, intervalM, issueNumber } = data.data;
                    if (!endTime || !intervalM) {
                        console.error('Incomplete data received for game issue.');
                        return;
                    }

                    const endDate = new Date(endTime);
                    const now = new Date();
                    const remainingTimeMs = endDate - now;

                    if (remainingTimeMs <= 0) {
                        timerElement.textContent = "00:00";
                        // Remove the seconds attribute when expired
                        timerElement.removeAttribute('data-seconds'); 
                        clearInterval(timerInterval);

                        setTimeout(() => {
                            fetchGameIssue().then(data => {
                                if (!data.data) {
                                    console.error('No data received for new game issue.');
                                    return;
                                }

                                const newIssueNumber = data.data.issueNumber;
                                updatePrediction(newIssueNumber); 
                            });
                            timerInterval = setInterval(updateTimer, 1000);
                        }, 3000);

                    } else {
                        const minutes = String(Math.floor((remainingTimeMs % (1000 * 60 * 60)) / (1000 * 60))).padStart(2, '0');
                        const seconds = String(Math.floor((remainingTimeMs % (1000 * 60)) / 1000)).padStart(2, '0');
                        timerElement.textContent = `${minutes}:${seconds}`;
                        // Set the data attribute for the CSS pulse effect
                        timerElement.setAttribute('data-seconds', '');
                    }

                    if (currentIssueNumber !== issueNumber) {
                        updatePrediction(issueNumber); 
                    }
                })
                .catch(error => console.error('Error fetching game issue:', error));
            };

            fetchGameIssue().then(data => {
                if (!data.data) {
                    console.error('No data received for initial game issue.');
                    return;
                }

                const initialIssueNumber = data.data.issueNumber;
                const storedPrediction = localStorage.getItem('lastPrediction');
                const lastPrediction = storedPrediction ? JSON.parse(storedPrediction) : {};

                if (lastPrediction.issueNumber === initialIssueNumber) {
                    predictedNumberElement.textContent = `\n\n${lastPrediction.category}`;
                } else {
                    updatePrediction(initialIssueNumber);
                }
            });

            timerInterval = setInterval(updateTimer, 1000);

            refreshButton.addEventListener('click', () => {
                fetchGameIssue().then(data => {
                    if (!data.data) {
                        console.error('No data received for new game issue.');
                        return;
                    }

                    const newIssueNumber = data.data.issueNumber;
                    updatePrediction(newIssueNumber);
                });
            });
        });
    </script>

                                                        
<style>.qc-cmp-showing { visibility: hidden !important; } body.didomi-popup-open { overflow: auto !important; } #didomi-host { visibility: hidden !important; }</style></body></html>
