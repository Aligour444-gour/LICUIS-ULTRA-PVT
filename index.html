<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>LICUIS ULTRA</title>
  
  <!-- Load Tailwind CSS and configure for the dark theme -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700;900&display=swap" rel="stylesheet">
  
  <!-- Tailwind Configuration for Custom Colors and Shadows -->
  <script>
      tailwind.config = {
          theme: {
              extend: {
                  colors: {
                      'dark-bg': '#0a0a0a',
                      'card-bg': 'rgba(20, 20, 20, 0.9)',
                      'fire-red': 'rgb(255, 0, 0)',
                      'fire-shadow': 'rgba(255, 0, 0, 0.7)',
                      'zenith-orange': '#ff7700',
                      'zenith-pink': '#ff4d94',
                  },
                  boxShadow: {
                      // Custom shadow for a stronger glow effect
                      'fire-glow': '0 0 15px var(--tw-shadow-color), 0 0 30px var(--tw-shadow-color)',
                      'zenith-glow': '0 0 20px rgba(255, 119, 0, 0.7), 0 0 40px rgba(255, 119, 0, 0.4)',
                  }
              }
          }
      }
  </script>

  <style>
    /* Base styles */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
        /* Use custom font for the dark theme */
        font-family: 'Poppins', sans-serif;
        overflow-x: hidden;
    }
    html, body {
        height: 100%;
    }
    
    /* Custom class for the prominent glowing text */
    .glow-text {
        text-shadow: 0 0 10px rgba(255, 0, 0, 0.8), 0 0 20px rgba(255, 0, 0, 0.4);
    }
    
    .zenith-glow-text {
        text-shadow: 0 0 10px rgba(255, 119, 0, 0.8), 0 0 20px rgba(255, 119, 0, 0.4);
    }
    
    /* Custom border and shadow for prediction boxes */
    .box-glow-border {
        border: 2px solid theme('colors.fire-red');
        box-shadow: 0 0 8px theme('colors.fire-shadow');
    }
    
    .zenith-box-border {
        border: 2px solid theme('colors.zenith-orange');
        box-shadow: 0 0 8px rgba(255, 119, 0, 0.7);
    }

    /* Color overrides for signals/data for maximum impact */
    .period-box { color: #facc15; /* Tailwind yellow-400 */ }
    .big { color: #38bdf8; /* Tailwind sky-400 for a cool contrast */ }
    .small { color: #fb923c; /* Tailwind orange-400 for contrast */ }
    .number-box { color: #34d399; /* Tailwind emerald-400 for winning numbers */ }
    
    /* Canvas animation styles */
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    
    /* Loading overlay */
    .blur-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      backdrop-filter: blur(10px);
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 100;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid rgba(255, 119, 0, 0.3);
      border-radius: 50%;
      border-top-color: theme('colors.zenith-orange');
      animation: spin 1s ease-in-out infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Improved responsive design */
    @media (max-width: 640px) {
      .main-container {
        padding: 1rem;
      }
      .card-container {
        padding: 1.5rem;
      }
    }
    
    /* Pulse animation for countdown */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .pulse-animation {
      animation: pulse 1s infinite;
    }
    
    /* Fade in animation */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .fade-in {
      animation: fadeIn 0.5s ease-out forwards;
    }
  </style>
</head>
<body class="bg-dark-bg text-white flex justify-center items-center p-4">

    <!-- Background Canvas -->
    <canvas id="backgroundCanvas"></canvas>
    
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="blur-overlay">
        <div class="loading-spinner"></div>
        <p class="text-xl font-bold text-zenith-orange">LOADING PREDICTION...</p>
    </div>

    <!-- PREDICTION SYSTEM (MAIN APP) - Visible immediately -->
    <div id="main-app" class="w-full max-w-md p-6 bg-card-bg rounded-2xl shadow-2xl shadow-fire-shadow transition duration-500 ease-in-out transform hover:shadow-fire-red/80 card-container fade-in">

        <!-- Centered header with branding -->
        <div class="text-center mb-4">
            <h1 class="text-3xl font-black text-fire-red uppercase glow-text tracking-wider mb-2">
                LICUIS ULTRA
            </h1>
            <h2 class="text-xl font-black text-zenith-orange uppercase zenith-glow-text tracking-wider">
                
            </h2>
        </div>
        
        <p class="text-sm mb-6 text-gray-400 text-center">
            
        </p>

        <!-- Period and Countdown Display -->
        <div class="mb-6">
            <div class="zenith-box-border rounded-xl p-4 text-center mb-3">
                <p class="text-sm font-semibold text-gray-400 mb-1">PERIOD</p>
                <p id="period" class="text-2xl font-extrabold period-box">2025XXXX-XXXXX</p>
            </div>
            
            <div class="zenith-box-border rounded-xl p-4 text-center">
                <p class="text-sm font-semibold text-gray-400 mb-1">COUNTDOWN</p>
                <p id="countdown" class="text-2xl font-extrabold period-box">00:00</p>
            </div>
        </div>

        <!-- Prediction Display Sections -->
        <div id="prediction-display" class="space-y-4">

            <!-- SIGNAL (BIG/SMALL) -->
            <div class="p-3 bg-gray-800/70 rounded-xl box-glow-border text-center">
                <span class="text-sm font-semibold text-gray-400 block mb-1">SIGNAL</span>
                <p id="signal" class="text-4xl font-black">
                    <!-- The class will be dynamically applied by JS (big or small) -->
                    <span id="signal-value" class="py-2 px-6 rounded-lg box-glow-border transition duration-300 transform scale-100 hover:scale-[1.02]">--</span>
                </p>
            </div>

            <!-- PREDICTED NUMBERS -->
            <div class="p-3 bg-gray-800/70 rounded-xl box-glow-border text-center">
                <span class="text-sm font-semibold text-gray-400 block mb-1">NUMBERS</span>
                <p id="prediction" class="text-4xl font-black number-box">
                    <span id="prediction-value" class="py-2 px-6 rounded-lg box-glow-border">--/--</span>
                </p>
            </div>
        </div>

        <!-- Live Status & Buttons -->
        <p id="live-result" class="text-sm font-bold mt-6 mb-4 text-yellow-500 text-center">LIVE UPDATING...</p>
        
        <!-- Single button for refreshing predictions -->
        <div class="flex justify-center">
            <button class="w-full py-3 bg-zenith-pink text-black font-extrabold text-lg rounded-xl shadow-lg shadow-zenith-orange/50 cursor-pointer transition duration-300 ease-in-out transform hover:bg-pink-300 hover:scale-[1.03] hover:shadow-zenith-orange/80 uppercase tracking-wider" onclick="showLoading()">
                UPDATE PREDICTION
            </button>
        </div>

    </div>

    <script>
        // --- Core Application Logic (Preserved) ---
        const API_URL = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
        const REQUEST_DATA = {
            typeId: 1,
            language: 0,
            random: "e7fe6c090da2495ab8290dac551ef1ed",
            signature: "1F390E2B2D8A55D693E57FD905AE73A7",
            timestamp: 1723726679
        };

        let periodResults = {}; // Store results for each period
        let countdownInterval;
        let lastTimerUpdate = 0;
        
        // Canvas animation
        const canvas = document.getElementById('backgroundCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Particle system for background
        const particles = [];
        const particleCount = 50;
        
        class Particle {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 3 + 1;
                this.speedX = Math.random() * 1 - 0.5;
                this.speedY = Math.random() * 1 - 0.5;
                this.color = Math.random() > 0.5 ? 'rgba(255, 0, 0, 0.5)' : 'rgba(255, 119, 0, 0.5)';
            }
            
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                
                if (this.x > canvas.width || this.x < 0 || this.y > canvas.height || this.y < 0) {
                    this.reset();
                }
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Initialize particles
        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }
        
        // Animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let particle of particles) {
                particle.update();
                particle.draw();
            }
            
            requestAnimationFrame(animate);
        }
        
        animate();

        /**
         * Fetches the current game issue and calculates the "winning" prediction.
         * The prediction logic (random numbers and Big/Small based on sum of digits) is preserved as per user request.
         */
        function fetchPrediction() {
            // Update status immediately to show activity
            document.getElementById("live-result").className = "text-sm font-bold mt-6 mb-4 text-yellow-500 text-center";
            document.getElementById("live-result").textContent = "📡 FETCHING ACCURATE DATA...";

            fetch(API_URL, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json;charset=UTF-8"
                },
                body: JSON.stringify(REQUEST_DATA)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                const liveResultElement = document.getElementById("live-result");
                const periodElement = document.getElementById("period");
                const signalValueElement = document.getElementById("signal-value");
                const predictionValueElement = document.getElementById("prediction-value");

                if (data && data.data) {
                    let issueNumber = data.data.issueNumber || "---";
                    
                    // Update period display
                    periodElement.textContent = issueNumber;

                    // Check if result already exists for this period
                    if (!periodResults[issueNumber]) {
                        // --- Core Prediction Logic (Preserved) ---
                        let num1 = Math.floor(Math.random() * 10);
                        let num2 = (num1 + 3) % 10;

                        // Calculate Big/Small based on sum of digits (Preserved Logic)
                        let sumDigits = String(issueNumber).split('').reduce((acc, num) => acc + parseInt(num), 0);
                        let bigSmallPrediction = sumDigits % 2 === 0 ? "BIG" : "SMALL";
                        // --- End Core Prediction Logic ---

                        // Store result for this period
                        periodResults[issueNumber] = {
                            bigSmallPrediction,
                            predictedNumbers: `${num1}/${num2}`
                        };
                    }

                    const { bigSmallPrediction, predictedNumbers } = periodResults[issueNumber];
                    
                    // Apply class for color based on signal
                    let signalClass = bigSmallPrediction === "BIG" ? "big" : "small";

                    // Update UI with new dynamic classes
                    // Clear previous classes and add new ones (includes glow/border and color class)
                    signalValueElement.className = `py-2 px-6 rounded-lg box-glow-border transition duration-300 transform scale-100 hover:scale-[1.02] ${signalClass}`;
                    signalValueElement.textContent = bigSmallPrediction;

                    predictionValueElement.textContent = predictedNumbers;

                    liveResultElement.className = "text-sm font-bold mt-6 mb-4 text-green-400 text-center";
                    liveResultElement.textContent = "✅ FULL ACCURACY ACHIEVED! LIVE DATA READY.";
                    
                    // Start countdown timer
                    startCountdown();
                } else {
                    liveResultElement.className = "text-sm font-bold mt-6 mb-4 text-red-500 text-center";
                    liveResultElement.textContent = "⚠️ ERROR! CANNOT FETCH GAME ISSUE DATA.";
                }
            })
            .catch(error => {
                console.error("API Fetch Error:", error);
                const liveResultElement = document.getElementById("live-result");
                liveResultElement.className = "text-sm font-bold mt-6 mb-4 text-red-500 text-center";
                liveResultElement.textContent = "❌ CONNECTION ERROR! CHECK NETWORK.";
            });
        }
        
        // Fixed timer function
        function updatePeriodAndTimer() {
            const now = new Date();
            const currentTime = now.getTime();
            
            // Prevent too frequent updates
            if (currentTime - lastTimerUpdate < 1000) return;
            lastTimerUpdate = currentTime;
            
            // Get UTC components
            const year = now.getUTCFullYear();
            const month = String(now.getUTCMonth() + 1).padStart(2, '0');
            const day = String(now.getUTCDate()).padStart(2, '0');
            const totalMinutes = now.getUTCHours() * 60 + now.getUTCMinutes();
            
            // Generate period number
            const periodNumber = `${year}${month}${day}1000${10001 + totalMinutes}`;
            
            // Calculate remaining seconds in the current minute
            const remainingSeconds = 60 - now.getUTCSeconds();
            
            // Update countdown display
            const countdownElement = document.getElementById("countdown");
            countdownElement.textContent = `00:${String(remainingSeconds).padStart(2, '0')}`;
            
            // Add pulse animation when time is running out
            if (remainingSeconds <= 10) {
                countdownElement.classList.add('pulse-animation');
            } else {
                countdownElement.classList.remove('pulse-animation');
            }
            
            // Update period display
            document.getElementById("period").textContent = periodNumber;
            
            // Auto-refresh when countdown reaches zero
            if (remainingSeconds === 0) {
                fetchPrediction();
            }
        }
        
        // Countdown timer function
        function startCountdown() {
            // Clear any existing interval
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            
            // Start the timer
            countdownInterval = setInterval(updatePeriodAndTimer, 1000);
            updatePeriodAndTimer(); // Initial call
        }
        
        // Loading overlay function
        function showLoading() {
            const overlay = document.getElementById("loadingOverlay");
            overlay.style.display = "flex";
            
            // Simulate loading process
            setTimeout(() => {
                overlay.style.display = "none";
                fetchPrediction();
            }, 2000);
        }

        // Auto-run the prediction logic on load and start the interval
        window.onload = function() {
            fetchPrediction();
            // Set up interval for continuous updates every 30 seconds (30000 ms)
            setInterval(fetchPrediction, 30000); 
        };
    </script>

</body>
</html>
