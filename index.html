<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LICUIS ULTRA - Enhanced</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=El+Messiri:wght@400;500;600;700&family=Orbitron:wght@400;500;700;900&family=Exo+2:wght@300;400;500;600;700&display=swap');

        :root {
            --primary: #D4AF37; /* Gold */
            --primary-dark: #B8860B;
            --secondary: #FFD700;
            --accent: #F0E68C;
            --win: #10b981;
            --loss: #ef4444;
            --warning: #f59e0b;
            --success-color: #10b981;
            --danger-color: #ef4444;
            --warning-color: #f59e0b;
            --bg-light: #121212; /* Dark background */
            --bg-lighter: #1a1a1a;
            --bg-medium: #252525;
            --text-dark: #f8fafc;
            --text-medium: #e2e8f0;
            --text-light: #94a3b8;
            --glass-bg: rgba(26, 26, 26, 0.9);
            --glass-border: rgba(212, 175, 55, 0.3);
            --transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.1);
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 20px 40px rgba(0, 0, 0, 0.5);
            --gradient: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
            --success-gradient: linear-gradient(135deg, var(--win), #059669);
            --danger-gradient: linear-gradient(135deg, var(--loss), #dc2626);
            --radius: 16px;
            --radius-sm: 8px;
            --glow: 0 0 15px rgba(212, 175, 55, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-light);
            color: var(--text-dark);
            font-family: 'Exo 2', sans-serif;
            padding: 0;
            margin: 0;
            overflow: hidden;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(212, 175, 55, 0.1) 0%, transparent 25%), 
                radial-gradient(circle at 90% 80%, rgba(255, 215, 0, 0.1) 0%, transparent 25%),
                linear-gradient(to bottom, rgba(18, 18, 18, 0.9), rgba(18, 18, 18, 0.7));
            position: fixed;
            width: 100%;
            height: 100%;
            line-height: 1.6;
        }

        /* Enhanced Logo Styles */
        .logo {
            position: absolute;
            top: 15px;
            left: 20px;
            z-index: 100000000;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: var(--glass-bg);
            border-radius: var(--radius);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow), var(--glow);
            transition: var(--transition);
        }

        .logo:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5), 0 0 20px rgba(212, 175, 55, 0.6);
        }

        .logo-icon {
            width: 38px;
            height: 38px;
            background: var(--gradient);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            animation: logoPulse 4s ease-in-out infinite;
        }

        @keyframes logoPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 25px rgba(212, 175, 55, 0.7); }
        }

        .logo-icon svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        .logo-text {
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: 18px;
            background: var(--gradient);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        /* Enhanced Tab System */
        .tab-system {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 70px;
            background: rgba(18, 18, 18, 0.95);
            display: flex;
            z-index: 99999999;
            backdrop-filter: blur(15px);
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
            padding-left: 120px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .tab {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
            gap: 10px;
        }

        .tab:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        .tab.active {
            background: rgba(212, 175, 55, 0.15);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--gradient);
            border-radius: 2px 2px 0 0;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .tab-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            background: rgba(212, 175, 55, 0.1);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .tab.active .tab-icon {
            background: var(--gradient);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
        }

        .tab-icon i {
            font-size: 14px;
            color: var(--primary);
            transition: var(--transition);
            z-index: 1;
        }

        .tab.active .tab-icon i {
            color: white;
        }

        .tab-label {
            font-family: 'Exo 2', sans-serif;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-medium);
            transition: var(--transition);
            letter-spacing: 0.5px;
        }

        .tab.active .tab-label {
            color: var(--text-dark);
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .tab:hover .tab-label {
            color: var(--text-dark);
        }

        /* Content Sections */
        .content-section {
            position: fixed;
            top: 70px;
            left: 0;
            width: 100%;
            height: calc(100% - 70px);
            display: none;
            overflow: hidden;
        }

        .content-section.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Web Section (Game Selection) */
        #web-section {
            background-color: var(--bg-light);
        }

        /* History Section */
        #history-section {
            background-color: var(--bg-light);
            padding: 25px;
            overflow-y: auto;
        }

        .history-container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--glass-bg);
            border-radius: var(--radius);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(15px);
            overflow: hidden;
            box-shadow: var(--shadow), var(--glow);
            animation: slideUp 0.6s ease;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .history-title {
            text-align: center;
            padding: 25px;
            font-family: 'Orbitron', sans-serif;
            font-size: 26px;
            color: var(--primary);
            background: rgba(212, 175, 55, 0.05);
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        .history-controls {
            display: flex;
            justify-content: space-between;
            padding: 25px;
            background: rgba(212, 175, 55, 0.05);
            border-bottom: 1px solid var(--glass-border);
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .history-filter {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .filter-btn {
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid var(--glass-border);
            color: var(--text-medium);
            padding: 12px 20px;
            border-radius: 30px;
            cursor: pointer;
            transition: var(--transition);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Exo 2', sans-serif;
        }

        .filter-btn:hover {
            background: rgba(212, 175, 55, 0.15);
            border-color: var(--primary);
            color: var(--text-dark);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .filter-btn.active {
            background: var(--gradient);
            color: white;
            box-shadow: 0 5px 15px rgba(212, 175, 55, 0.3), 0 0 10px rgba(212, 175, 55, 0.3);
            border-color: transparent;
        }

        .history-stats {
            display: flex;
            gap: 15px;
        }

        .stat-badge {
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid var(--glass-border);
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            transition: var(--transition);
        }

        .stat-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .stat-badge.win {
            color: var(--win);
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.3);
        }

        .stat-badge.loss {
            color: var(--loss);
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.3);
        }

        .history-content {
            padding: 0;
        }

        .history-header {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            padding: 20px 25px;
            background: rgba(212, 175, 55, 0.05);
            font-weight: 600;
            border-bottom: 1px solid var(--glass-border);
            color: var(--text-dark);
            font-family: 'Exo 2', sans-serif;
            font-size: 15px;
        }

        .history-item {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            padding: 20px 25px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: var(--transition);
            position: relative;
        }

        .history-item:hover {
            background: rgba(212, 175, 55, 0.03);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .history-value {
            font-size: 16px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dark);
            font-family: 'Exo 2', sans-serif;
        }

        .history-value-highlight {
            font-size: 20px;
            font-weight: 700;
            color: var(--primary);
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        .color-dot {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 8px currentColor;
        }

        .color-red {
            background-color: var(--loss);
        }

        .color-green {
            background-color: var(--win);
        }

        .history-pagination {
            display: flex;
            justify-content: center;
            padding: 25px;
            gap: 12px;
            border-top: 1px solid var(--glass-border);
        }

        .pagination-btn {
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid var(--glass-border);
            color: var(--text-dark);
            cursor: pointer;
            transition: var(--transition);
            font-weight: 600;
            font-family: 'Exo 2', sans-serif;
        }

        .pagination-btn:hover:not(.disabled) {
            background: rgba(212, 175, 55, 0.1);
            border-color: var(--primary);
            color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .pagination-btn.active {
            background: var(--gradient);
            color: white;
            box-shadow: 0 5px 15px rgba(212, 175, 55, 0.3), 0 0 10px rgba(212, 175, 55, 0.3);
            border-color: transparent;
        }

        .pagination-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .loading-container,
        .error-container,
        .no-data-container {
            text-align: center;
            padding: 80px 25px;
            color: var(--text-light);
        }

        .loading-container i,
        .error-container i,
        .no-data-container i {
            font-size: 36px;
            margin-bottom: 20px;
            display: block;
            color: var(--primary);
        }

        .error-container {
            color: var(--loss);
        }

        /* Analysis Section */
        #analysis-section {
            overflow-y: auto;
            padding: 25px;
        }

        .analysis-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .analysis-card {
            background: var(--glass-bg);
            border-radius: var(--radius);
            border: 1px solid var(--glass-border);
            padding: 30px;
            margin-bottom: 30px;
            backdrop-filter: blur(15px);
            box-shadow: var(--shadow), var(--glow);
            animation: slideUp 0.6s ease;
        }

        .analysis-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 22px;
            color: var(--primary);
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--glass-border);
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .stat-item {
            background: rgba(26, 26, 26, 0.9);
            border-radius: var(--radius);
            padding: 25px;
            text-align: center;
            border: 1px solid var(--glass-border);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--gradient);
            transform: scaleX(0);
            transition: transform 0.5s ease;
        }

        .stat-item:hover::before {
            transform: scaleX(1);
        }

        .stat-item:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-lg), 0 0 15px rgba(212, 175, 55, 0.3);
        }

        .stat-value {
            font-size: 32px;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
            font-family: 'Orbitron', sans-serif;
        }

        .stat-label {
            font-size: 15px;
            color: var(--text-light);
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .pattern-list {
            margin-top: 25px;
        }

        .pattern-item {
            display: flex;
            justify-content: space-between;
            padding: 16px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            align-items: center;
            transition: var(--transition);
        }

        .pattern-item:hover {
            background: rgba(212, 175, 55, 0.03);
            padding-left: 10px;
            padding-right: 10px;
            border-radius: var(--radius-sm);
        }

        .pattern-item:last-child {
            border-bottom: none;
        }

        .pattern-value {
            font-weight: 600;
            color: var(--text-dark);
            font-family: 'Exo 2', sans-serif;
        }

        .pattern-confidence {
            color: var(--primary);
            font-weight: 700;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        /* Strategy Cards */
        .strategy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }

        .strategy-card {
            background: rgba(26, 26, 26, 0.9);
            border-radius: var(--radius);
            padding: 25px;
            border-left: 4px solid var(--primary);
            border: 1px solid var(--glass-border);
            transition: var(--transition);
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .strategy-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--gradient);
            opacity: 0;
            transition: opacity 0.4s ease;
            z-index: 0;
        }

        .strategy-card:hover::before {
            opacity: 0.05;
        }

        .strategy-card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-lg), 0 0 15px rgba(212, 175, 55, 0.3);
        }

        .strategy-title {
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 19px;
            position: relative;
            z-index: 1;
            font-family: 'Exo 2', sans-serif;
        }

        .strategy-description {
            font-family: 'Exo 2', sans-serif;
            font-size: 15px;
            color: var(--text-medium);
            line-height: 1.6;
            position: relative;
            z-index: 1;
        }

        /* Game Selection Screen */
        .game-selection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(18, 18, 18, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999999;
            animation: fadeIn 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
            backdrop-filter: blur(15px);
        }

        .game-selection::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(212, 175, 55, 0.1) 0%, transparent 25%), 
                radial-gradient(circle at 80% 70%, rgba(255, 215, 0, 0.1) 0%, transparent 25%);
            z-index: -1;
            pointer-events: none;
        }

        .game-selection-title {
            font-family: 'El Messiri', sans-serif;
            font-weight: 700;
            font-size: 48px;
            margin: 0 0 60px;
            color: var(--primary);
            letter-spacing: 4px;
            position: relative;
            display: inline-block;
            text-shadow: 0 5px 20px rgba(212, 175, 55, 0.4);
            animation: titleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { text-shadow: 0 5px 20px rgba(212, 175, 55, 0.4); }
            to { text-shadow: 0 5px 30px rgba(212, 175, 55, 0.7), 0 0 20px rgba(212, 175, 55, 0.5); }
        }

        .game-selection-title::after {
            content: "";
            position: absolute;
            bottom: -20px;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--gradient);
            transform: scaleX(0);
            transform-origin: right;
            transition: transform 1s cubic-bezier(0.19, 1, 0.22, 1);
            border-radius: 2px;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
        }

        .game-selection-title.animate::after {
            transform: scaleX(1);
            transform-origin: left;
        }

        .game-list-container {
            width: 100%;
            max-width: 1200px;
            max-height: calc(100vh - 220px);
            overflow-y: auto;
            padding: 0 25px;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) rgba(0, 0, 0, 0.1);
        }

        .game-list-container::-webkit-scrollbar {
            width: 10px;
        }

        .game-list-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .game-list-container::-webkit-scrollbar-thumb {
            background: var(--gradient);
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .game-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 30px;
            padding: 0 25px 60px;
        }

        .game-item {
            background: rgba(26, 26, 26, 0.95);
            border: 1px solid rgba(212, 175, 55, 0.2);
            border-radius: var(--radius);
            padding: 30px;
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
            font-family: 'Exo 2', sans-serif;
            color: var(--text-dark);
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
        }

        .game-item::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: var(--gradient);
            opacity: 0;
            transition: opacity 0.4s ease;
            border-radius: 3px 3px 0 0;
        }

        .game-item:hover::before {
            opacity: 1;
        }

        .game-item:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow: var(--shadow-lg), 0 0 20px rgba(212, 175, 55, 0.4);
            background: rgba(26, 26, 26, 1);
            border-color: rgba(212, 175, 55, 0.4);
        }

        .game-name {
            font-family: 'El Messiri', sans-serif;
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 15px;
            position: relative;
            z-index: 1;
            transition: var(--transition);
        }

        .game-item:hover .game-name {
            color: var(--primary);
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        .game-url {
            font-size: 14px;
            color: var(--text-light);
            word-break: break-all;
            opacity: 0.7;
            transition: var(--transition);
        }

        .game-item:hover .game-url {
            opacity: 1;
        }

        /* Iframe and Tape Button */
        .fullscreen-iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            z-index: 1;
        }

        .hidden {
            display: none;
        }

        /* Enhanced BACK BUTTON DESIGN */
        .injector-tape {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 70px;
            height: 70px;
            background: var(--gradient);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 9999999;
            box-shadow: 0 10px 30px rgba(212, 175, 55, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.7);
            transition: var(--transition);
            animation: tapeFloat 4s ease-in-out infinite;
        }

        @keyframes tapeFloat {
            0%, 100% {
                transform: translateY(0) rotate(0deg);
            }
            50% {
                transform: translateY(-10px) rotate(10deg);
            }
        }

        .injector-tape:hover {
            transform: scale(1.2) rotate(15deg);
            box-shadow: 0 15px 40px rgba(212, 175, 55, 0.6), 0 0 20px rgba(212, 175, 55, 0.5);
            animation: none;
        }

        .injector-tape::before {
            content: "";
            position: absolute;
            width: 24px;
            height: 24px;
            border-left: 3px solid white;
            border-bottom: 3px solid white;
            transform: rotate(45deg);
            margin-top: -3px;
            margin-left: -3px;
        }

        /* Enhanced Floating Particles */
        .particle {
            position: absolute;
            background: rgba(212, 175, 55, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: -1;
            filter: blur(2px);
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% {
                transform: translateY(0) translateX(0) rotate(0deg);
            }
            25% {
                transform: translateY(-30px) translateX(20px) rotate(10deg);
            }
            50% {
                transform: translateY(0) translateX(30px) rotate(0deg);
            }
            75% {
                transform: translateY(30px) translateX(20px) rotate(-10deg);
            }
            100% {
                transform: translateY(0) translateX(0) rotate(0deg);
            }
        }

        /* Enhanced Chat Predictor Styles */
        .chat-container {
            width: 100%;
            height: 100%;
            margin: 0 auto;
            padding: 0;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-light);
            position: relative;
            overflow: hidden;
        }

        .chat-header {
            background: var(--bg-lighter);
            padding: 25px 20px;
            text-align: center;
            border-bottom: 1px solid rgba(212, 175, 55, 0.15);
            position: relative;
            z-index: 10;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }

        .chat-title {
            font-weight: 900;
            font-size: 1.8rem;
            background: var(--gradient);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin: 0;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            font-family: 'El Messiri', sans-serif;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
        }

        .chat-subtitle {
            font-size: 0.9rem;
            color: var(--text-light);
            margin: 10px 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-family: 'Exo 2', sans-serif;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 25px;
            background-color: var(--bg-light);
            scroll-behavior: smooth;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(212, 175, 55, 0.08) 0%, transparent 50%), 
                radial-gradient(circle at 75% 75%, rgba(255, 215, 0, 0.08) 0%, transparent 50%);
        }

        .message {
            margin-bottom: 25px;
            padding: 18px 22px;
            border-radius: 20px;
            max-width: 85%;
            word-wrap: break-word;
            position: relative;
            animation: fadeIn 0.4s ease;
            font-family: 'Exo 2', sans-serif;
            font-size: 1rem;
            line-height: 1.5;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .received {
            background-color: var(--bg-lighter);
            border-bottom-left-radius: 10px;
            margin-right: auto;
            border: 1px solid rgba(212, 175, 55, 0.2);
            color: var(--text-dark);
        }

        .sent {
            background: var(--gradient);
            color: white;
            border-bottom-right-radius: 10px;
            margin-left: auto;
            box-shadow: 0 5px 15px rgba(212, 175, 55, 0.3);
        }

        .timestamp {
            font-size: 0.75rem;
            color: var(--text-light);
            margin-top: 12px;
            text-align: right;
            opacity: 0.8;
            pointer-events: none;
        }

        .emoji {
            font-size: 1.4em;
            margin-right: 8px;
            display: inline-block;
        }

        .prediction-card {
            background-color: rgba(212, 175, 55, 0.15);
            border-radius: var(--radius);
            padding: 20px;
            margin: 18px 0;
            border: 1px solid rgba(212, 175, 55, 0.3);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.2);
        }

        .prediction-title {
            font-family: 'Exo 2', sans-serif;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 12px;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .prediction-title i {
            font-size: 1.3rem;
            display: inline-block;
        }

        .prediction-value {
            font-family: 'El Messiri', sans-serif;
            font-size: 2.8rem;
            font-weight: 900;
            margin: 18px 0;
            text-align: center;
            letter-spacing: 1px;
            color: var(--primary);
            text-transform: uppercase;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 8px currentColor;
        }

        .online {
            background-color: var(--win);
        }

        .offline {
            background-color: var(--loss);
        }

        .typing-indicator {
            display: flex;
            padding: 16px 20px;
            background-color: var(--bg-lighter);
            border-radius: 25px;
            width: fit-content;
            margin-bottom: 25px;
            border-bottom-left-radius: 10px;
            align-items: center;
            gap: 12px;
            border: 1px solid rgba(212, 175, 55, 0.2);
        }

        .typing-text {
            font-size: 0.95rem;
            color: var(--text-light);
            font-family: 'Exo 2', sans-serif;
        }

        .typing-dot {
            width: 12px;
            height: 12px;
            background-color: var(--text-light);
            border-radius: 50%;
            animation: typingAnimation 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) {
            animation-delay: 0s;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typingAnimation {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.6;
            }
            30% {
                transform: translateY(-8px);
                opacity: 1;
            }
        }

        .scroll-down-btn {
            position: fixed;
            bottom: 110px;
            right: 30px;
            background: var(--gradient);
            color: white;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(212, 175, 55, 0.3);
            z-index: 100;
            opacity: 0;
            transition: all 0.3s ease;
            border: none;
            outline: none;
        }

        .scroll-down-btn.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .scroll-down-btn:not(.visible) {
            transform: translateY(15px);
        }

        .scroll-down-btn:hover {
            transform: translateY(-5px) scale(1.1);
            box-shadow: 0 10px 30px rgba(212, 175, 55, 0.4);
        }

        .progress-bar {
            height: 10px;
            background-color: rgba(255, 255, 255, 0.15);
            border-radius: 5px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            border-radius: 5px;
            background: var(--gradient);
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .floating-bg {
            position: absolute;
            width: 400px;
            height: 400px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(212, 175, 55, 0.1) 0%, transparent 70%);
            z-index: 0;
            pointer-events: none;
            animation: pulse 8s infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); opacity: 0.7; }
            to { transform: scale(1.1); opacity: 0.9; }
        }

        .bg-1 {
            top: -150px;
            left: -150px;
        }

        .bg-2 {
            bottom: -100px;
            right: -150px;
        }

        .period-display {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary);
            text-align: center;
            margin: 15px 0;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        .confidence-display {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.85rem;
            color: var(--text-light);
            align-items: center;
        }

        .confidence-value {
            color: var(--primary);
            font-weight: 700;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        /* Responsive Adjustments */
        @media (max-width: 1024px) {
            .game-list {
                grid-template-columns: repeat(auto-fill, minmax(270px, 1fr));
            }

            .strategy-grid {
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .logo {
                left: 15px;
                top: 12px;
            }

            .logo-text {
                display: none;
            }

            .tab-system {
                padding-left: 80px;
                height: 65px;
            }

            .content-section {
                top: 65px;
                height: calc(100% - 65px);
            }

            .game-list {
                grid-template-columns: 1fr 1fr;
                gap: 25px;
            }

            .game-selection-title {
                font-size: 36px;
                margin-bottom: 50px;
            }

            .injector-tape {
                width: 60px;
                height: 60px;
                bottom: 25px;
                right: 25px;
            }

            .tab-label {
                font-size: 12px;
            }

            .tab-icon {
                width: 24px;
                height: 24px;
            }

            .tab-icon i {
                font-size: 12px;
            }

            .prediction-value {
                font-size: 2.2rem;
            }

            .history-header,
            .history-item {
                grid-template-columns: 1fr 1fr 1fr;
                padding: 18px;
            }

            .history-value {
                font-size: 15px;
            }

            .history-value-highlight {
                font-size: 18px;
            }

            .strategy-grid {
                grid-template-columns: 1fr;
            }

            .history-controls {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }

            .stats-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 480px) {
            .game-list {
                grid-template-columns: 1fr;
            }

            .game-selection-title {
                font-size: 30px;
                margin-bottom: 40px;
            }

            .injector-tape {
                width: 55px;
                height: 55px;
            }

            .tab-label {
                display: none;
            }

            .tab-icon {
                margin-right: 0;
                width: 28px;
                height: 28px;
            }

            .prediction-value {
                font-size: 2rem;
            }

            .history-header,
            .history-item {
                grid-template-columns: 1fr 1fr;
                padding: 15px 12px;
            }

            .history-header-item:nth-child(3),
            .history-item>div:nth-child(3) {
                display: none;
            }

            .history-value {
                font-size: 14px;
            }

            .history-value-highlight {
                font-size: 16px;
            }

            .history-stats {
                flex-wrap: wrap;
                justify-content: center;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .analysis-card {
                padding: 25px;
            }

            .strategy-card {
                padding: 20px;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>

<body>
    <div class="logo">
        <div class="logo-icon">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M21 16.5c0 .83-.67 1.5-1.5 1.5H4.5c-.83 0-1.5-.67-1.5-1.5v-9c0-.83.67-1.5 1.5-1.5h15c.83 0 1.5.67 1.5 1.5v9zM4.5 20h15c.83 0 1.5-.67 1.5-1.5v-9c0-.83-.67-1.5-1.5-1.5h-15c-.83 0-1.5.67-1.5 1.5v9c0 .83.67 1.5 1.5 1.5zm2.5-6h2v2H7v-2zm4 0h2v2h-2v-2zm-4 4h2v2H7v-2zm4 0h2v2h-2v-2zm4-4h2v2h-2v-2zm-8-4h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2z" />
            </svg>
        </div>
        <div class="logo-text">LICUIS ULTRA</div>
    </div>

    <div class="tab-system">
        <div class="tab active" data-tab="web" role="tab" aria-controls="web-section" aria-selected="true">
            <div class="tab-icon"><i class="fas fa-gamepad"></i></div>
            <div class="tab-label">Games</div>
        </div>
        <div class="tab" data-tab="predictor" role="tab" aria-controls="predictor-section" aria-selected="false">
            <div class="tab-icon"><i class="fas fa-brain"></i></div>
            <div class="tab-label">Predictor</div>
        </div>
        <div class="tab" data-tab="history" role="tab" aria-controls="history-section" aria-selected="false">
            <div class="tab-icon"><i class="fas fa-history"></i></div>
            <div class="tab-label">History</div>
        </div>
        <div class="tab" data-tab="analysis" role="tab" aria-controls="analysis-section" aria-selected="false">
            <div class="tab-icon"><i class="fas fa-chart-line"></i></div>
            <div class="tab-label">Analysis</div>
        </div>
    </div>

    <div class="content-section active" id="web-section" role="tabpanel" aria-labelledby="web-tab">
        <div class="game-selection" id="gameSelection">
            <h1 class="game-selection-title" id="gameSelectionTitle">SELECT GAME</h1>
            <div class="game-list-container">
                <div class="game-list">
                    <div class="game-item" data-url="https://bdginf.com/#/login" role="button" tabindex="0">
                        <div class="game-name">BIG DADDY</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="http://Okwin.bio" role="button" tabindex="0">
                        <div class="game-name">OK WIN</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://goagamea.com/#/login" role="button" tabindex="0">
                        <div class="game-name">GOA GAME</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://www.bigmumbaiq.com/#/login" role="button" tabindex="0">
                        <div class="game-name">BIG MUMBAI</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="http://tirangagame.top" role="button" tabindex="0">
                        <div class="game-name">TIRANGA</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://51game5.com/#/" role="button" tabindex="0">
                        <div class="game-name">51 GAME</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://bdgwin.cc/#/login" role="button" tabindex="0">
                        <div class="game-name">BDG WIN</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="http://rajawager.com" role="button" tabindex="0">
                        <div class="game-name">RAJA WAGER</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="http://55club.game" role="button" tabindex="0">
                        <div class="game-name">55 CLUB</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://bharatclub.net/#/login" role="button" tabindex="0">
                        <div class="game-name">BHARAT CLUB</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://www.diuwin8.com/#/" role="button" tabindex="0">
                        <div class="game-name">DIUWIN</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://www.aatclub.com/#/" role="button" tabindex="0">
                        <div class="game-name">91 CLUB</div>
                        <div class="game-url"></div>
                    </div>
                </div>
            </div>
        </div>

        <iframe id="gameFrame" class="fullscreen-iframe hidden" allowfullscreen aria-label="Game Window"></iframe>

        <button class="injector-tape hidden" id="injectorTape" aria-label="Go Back to Game Selection"></button>
    </div>

    <div class="content-section" id="predictor-section" role="tabpanel" aria-labelledby="predictor-tab">
        <div class="chat-container">
            <div class="floating-bg bg-1"></div>
            <div class="floating-bg bg-2"></div>

            <div class="chat-header">
                <h1 class="chat-title">LICUIS ULTRA</h1>
                <p class="chat-subtitle">
                    <span class="status-indicator online"></span>
                    <span id="connection-status">Connected to Server</span>
                    â€¢ <span id="current-time">00:00:00</span>
                    â€¢ <span id="prediction-speed">0ms</span>
                </p>
            </div>

            <div class="messages-container" id="messages-container">
                <div class="message received">
                    <div class="prediction-title"><i class="fas fa-robot"></i> SYSTEM INITIALIZED</div>
                    <p>Welcome to <strong>LICUIS ULTRA</strong>, now powered by the Advanced AI models are analyzing game patterns in real-time to provide you with the most accurate predictions.</p>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 100%"></div>
                    </div>
                    <div class="timestamp" id="last-update-time">Just now</div>
                </div>

                <div class="typing-indicator" id="typing-indicator">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <span class="typing-text">Initializing AI models...</span>
                </div>
            </div>

            <button class="scroll-down-btn" id="scroll-down-btn" aria-label="Scroll to bottom">
                <i class="fas fa-chevron-down"></i>
            </button>
        </div>
    </div>

    <div class="content-section" id="history-section" role="tabpanel" aria-labelledby="history-tab">
        <div class="history-container">
            <div class="history-title">
                <i class="fas fa-history"></i> GAME HISTORY
            </div>
            <div class="history-controls">
                <div class="history-filter">
                    <button class="filter-btn active" data-filter="all"><i class="fas fa-layer-group"></i> All</button>
                    <button class="filter-btn" data-filter="big"><i class="fas fa-arrow-up"></i> Big</button>
                    <button class="filter-btn" data-filter="small"><i class="fas fa-arrow-down"></i> Small</button>
                    <button class="filter-btn" data-filter="red"><i class="fas fa-circle" style="color: #ef4444;"></i> Red</button>
                    <button class="filter-btn" data-filter="green"><i class="fas fa-circle" style="color: #10b981;"></i> Green</button>
                </div>
                <div class="history-stats">
                    <div class="stat-badge"><i class="fas fa-database"></i> <span id="total-count">0</span></div>
                </div>
            </div>
            <div class="history-content" id="historyContent">
                <div class="loading-container">
                    <i class="fas fa-spinner fa-spin"></i>
                    <div>LOADING DATA...</div>
                </div>
            </div>
            <div class="history-pagination" id="historyPagination">
                <button class="pagination-btn disabled" id="prevPage" aria-label="Previous Page"><i class="fas fa-chevron-left"></i></button>
                <button class="pagination-btn active">1</button>
                <button class="pagination-btn">2</button>
                <button class="pagination-btn">3</button>
                <button class="pagination-btn" id="nextPage" aria-label="Next Page"><i class="fas fa-chevron-right"></i></button>
            </div>
        </div>
    </div>

    <div class="content-section" id="analysis-section" role="tabpanel" aria-labelledby="analysis-tab">
        <div class="analysis-container">
            <div class="analysis-card">
                <div class="analysis-title">
                    <i class="fas fa-chart-pie"></i> ADVANCED ANALYSIS
                </div>
                <div id="advancedAnalysis">
                    <div class="loading-container">
                        <i class="fas fa-spinner fa-spin"></i>
                        <div>ANALYZING DATA PATTERNS...</div>
                    </div>
                </div>
            </div>

            <div class="analysis-card">
                <div class="analysis-title">
                    <i class="fas fa-brain"></i> ACTIVE STRATEGIES
                </div>
                <div class="strategy-grid" id="strategiesContainer">
                </div>
            </div>
        </div>
    </div>
<script>
// ðŸ”® LICUIS ULTRA : ZENITH AI-CORE ENGINE 10.1 (Enhanced & Accurate) - FIXED VERSION

"use strict";

// --- START PYTHON LOGIC EQUIVALENT (2-Level Recovery) ---

// Simple deque implementation for JavaScript
class Deque {
    constructor({ maxlen }) {
        this.maxlen = maxlen;
        this.items = [];
    }
    
    append(item) {
        this.items.push(item);
        if (this.items.length > this.maxlen) {
            this.items.shift();
        }
    }
    
    at(index) {
        if (index >= 0) {
            return this.items[index];
        } else {
            return this.items[this.items.length + index];
        }
    }
    
    get length() {
        return this.items.length;
    }
}

// --- Global State Management for Integrated Logic ---
// Use a deque for a rolling history of past results for pattern recognition
const PAST_RESULTS = new Deque({ maxlen: 10 }); // Increased maxlen to 10 for better pattern analysis
let LAST_PREDICTION_RESULT = null; // Stores the outcome of the previous prediction ("WIN" or "LOSS")
let RECOVERY_LEVEL = 0; // 0: Normal Mode, 1: First-level recovery, 2: Second-level recovery
let LAST_PREDICTION_DIRECTION = null; // Stores the size ('BIG'/'SMALL') of the last prediction
let RANDOMNESS_FACTOR = 0.1; // New: For simulating Random Override

// Configuration for thresholds
const config = {
    antiPredictThreshold: 0.60, // 60% win rate for Anti-Predict
    minStreakForContinuation: 2, // Win/Loss Streak length for Fallback
};

// --- Helper Functions ---

function get_last_four_digits(period_number) {
    /** Safely extracts the last four digits as integers from a string period_number. */
    const period_number_str = String(period_number);
    const digits = period_number_str.slice(-4);
    return digits.split('').map(d => parseInt(d, 10));
}

function get_size_outcome(number) {
    return number > 4 ? "BIG" : "SMALL";
}

function analyze_pattern_section(results) {
    /** New: Core Pattern Analysis based on the prompt's Step 1. */
    const len = results.length;
    if (len < 3) return { type: "NEUTRAL", prediction: null, confidence: 0 };
    
    const lastResult = results[len - 1];
    const secondLast = results[len - 2];
    const thirdLast = results[len - 3];
    
    // 1. Trap Pattern (Simulated: a break in an established sequence suggesting a trap)
    // Check for a long streak (5+) immediately broken by a single opposite result
    if (len >= 6) {
        const last6 = results.slice(-6);
        const streakType = last6[0];
        const isStreak5 = last6.slice(0, 5).every(res => res === streakType);
        if (isStreak5 && last6[5] !== streakType) {
            // 5-streak broken on the 6th result. Server is "trapping." Predict the reversal.
            return { type: "TRAP_REVERSAL", prediction: streakType, confidence: 0.95 };
        }
    }

    // 2. Alternating Pattern (B-S-B-S) - check last 4
    if (len >= 4 && lastResult !== secondLast && secondLast !== thirdLast && thirdLast !== results[len-4]) {
        // Alternating found (e.g., X, Y, X, Y). Predict next X.
        return { type: "ALTERNATING_PATTERN", prediction: secondLast, confidence: 0.85 };
    }

    // 3. Repeat Pattern (Streaks like B-B-B) - check last 3
    if (lastResult === secondLast && secondLast === thirdLast) {
        // Streak continuation
        return { type: "REPEAT_PATTERN", prediction: lastResult, confidence: 0.80 };
    }

    // 4. Two-Then-One Pattern (X-X-Y) - check last 3
    if (lastResult !== secondLast && secondLast === thirdLast) {
        // e.g., B-B-S. Predict continuation 'X', which is B.
        return { type: "TWO_THEN_ONE", prediction: secondLast, confidence: 0.75 };
    }

    // 5. Fallback: Simple Alternation
    if (lastResult !== secondLast && lastResult === thirdLast) {
         // e.g., S-B-S. Predict continuation B.
        return { type: "SIMPLE_ALTERNATING", prediction: lastResult === 'BIG' ? 'SMALL' : 'BIG', confidence: 0.65 };
    }

    // Number Sequence Patterns (Not explicitly implemented here as they rely on the number, not BIG/SMALL)

    return { type: "NEUTRAL", prediction: null, confidence: 0 };
}


function pattern_analysis_prediction(history, currentPeriod) {
    /**
     * Executes the Pattern Analysis (Primary Check) and Random Override.
     */
    const results = history.items.slice(-10); // Last 10 results for pattern analysis
    const analysis = analyze_pattern_section(results);
    
    let prediction = analysis.prediction;
    let confidence = analysis.confidence;
    
    if (prediction) {
        // 2. Random Override (Controlled Unpredictability)
        if (Math.random() < RANDOMNESS_FACTOR) {
            prediction = prediction === 'BIG' ? 'SMALL' : 'BIG';
            confidence = Math.max(0.5, confidence * 0.7); // Drop confidence on override
        }
    } else {
        // Fallback to simple parity check from the current period number
        const digits = get_last_four_digits(currentPeriod);
        const total_sum = digits.reduce((a, b) => a + b, 0);
        prediction = total_sum % 2 === 1 ? "BIG" : "SMALL";
        confidence = 0.5;
    }
    
    return { prediction, confidence };
}


function fallback_algorithm_prediction(lastPrediction, lastResult, coordinator) {
    /**
     * Executes the Fallback Algorithm (Adaptive/Sequential Logic) - Step 3.
     */
    
    let prediction = lastPrediction; // Default is to repeat the last prediction
    let confidence = 0.55;

    // Fetch config values from coordinator (for Anti-Predict threshold)
    const overallWinRate = coordinator.zenithAI.modelPerformance.reinforcement ? coordinator.zenithAI.modelPerformance.reinforcement.accuracy : 0; // Using reinforcement model accuracy as a proxy for overall win rate
    const antiPredictThreshold = coordinator.zenithAI.config.antiPredictThreshold || 0.60;

    // 1. High Win Rate Switch (Anti-Predict)
    if (overallWinRate > antiPredictThreshold) {
        prediction = lastPrediction === 'BIG' ? 'SMALL' : 'BIG'; // Switch to the opposite
        confidence = 0.88; // High confidence for anti-predict
        return { prediction, confidence, reason: "ANTI_PREDICT" };
    }

    // 2. Loss Reversal
    if (lastResult === 'LOSS') {
        prediction = lastPrediction === 'BIG' ? 'SMALL' : 'BIG'; // Switch direction
        return { prediction, confidence: 0.70, reason: "LOSS_REVERSAL" };
    }

    // 3. Streak Continuation/Reversal (Uses coordinator's streak counts)
    const winStreak = coordinator.consecutiveWins;
    const lossStreak = coordinator.consecutiveLosses; // Note: lossStreak > 0 implies RECOVERY_LEVEL > 0

    if (winStreak >= config.minStreakForContinuation) {
        // Win Streak Continuation (predict the same as last outcome)
        // **FIX:** Change to PAST_RESULTS.at(-1) to predict the last *outcome* (BIG/SMALL), not the last *prediction*
        const lastOutcome = PAST_RESULTS.at(-1); 
        if (lastOutcome) {
            prediction = lastOutcome;
        }
        return { prediction, confidence: 0.75, reason: "WIN_STREAK_CONT" };
    }
    
    if (lossStreak >= config.minStreakForContinuation) {
        // Loss Streak Reversal (switch direction)
        prediction = lastPrediction === 'BIG' ? 'SMALL' : 'BIG'; 
        return { prediction, confidence: 0.80, reason: "LOSS_STREAK_REV" };
    }
    
    // Default Fallback
    return { prediction, confidence, reason: "FALLBACK_DEFAULT" };
}


function final_prediction_core(period_number, history, lastPrediction, lastResult, coordinator) {
    /**
     * Orchestrates the prediction logic based on the prompt's sequence.
     */
    
    let predictionData = { prediction: null, confidence: 0, reason: "INITIAL" };
    
    // 1. Pattern Analysis (Primary Check)
    if (history.length >= 3) {
        predictionData = pattern_analysis_prediction(history, period_number);
    }
    
    // 3. Fallback Algorithm (if no specific pattern is found or low confidence)
    if (!predictionData.prediction || predictionData.confidence < 0.60) {
        if (lastPrediction && lastResult) {
            predictionData = fallback_algorithm_prediction(lastPrediction, lastResult, coordinator);
        } else {
             // Ultimate default
            const digits = get_last_four_digits(period_number);
            const total_sum = digits.reduce((a, b) => a + b, 0);
            predictionData.prediction = total_sum % 2 === 1 ? "BIG" : "SMALL";
            predictionData.confidence = 0.5;
            predictionData.reason = "ULTIMATE_DEFAULT";
        }
    }
    
    // 4. Number Generation (The model only predicts 'BIG'/'SMALL'. Specific number generation is an ensemble step.)
    // Note: The lossRecoveryModel is typically an override/aggressive mode, handled by the `LossRecoveryModel` logic.
    
    return predictionData;
}


function update_integrated_state(actual_result, made_prediction, was_recovery_mode) {
    /**
     * Updates global state (PAST_RESULTS, RECOVERY_LEVEL, RANDOMNESS_FACTOR)
     * This function now uses a simple and correct WIN/LOSS check.
     * @param {string} actual_result - The size outcome of the result ("BIG" or "SMALL").
     * @param {string} made_prediction - The size prediction made ("BIG" or "SMALL").
     * @param {boolean} was_recovery_mode - Whether the system was in recovery mode.
     */
    PAST_RESULTS.append(actual_result);
    LAST_PREDICTION_DIRECTION = made_prediction;
    
    // *** FIX: The core logic's WIN/LOSS must be based on a standard prediction match. ***
    const isWin = made_prediction === actual_result;

    if (isWin) {
        LAST_PREDICTION_RESULT = "WIN";
        RECOVERY_LEVEL = 0;
        // Decrease randomness after a WIN
        RANDOMNESS_FACTOR = Math.max(0.1, RANDOMNESS_FACTOR * 0.8);
    } else {
        LAST_PREDICTION_RESULT = "LOSS";
        
        // Only increase recovery level if we weren't in recovery mode, or if the recovery failed
        if (was_recovery_mode || RECOVERY_LEVEL === 0) {
            RECOVERY_LEVEL += 1;
        }

        // Critical Check: Handle system failure if a third consecutive loss occurs (Level 3 or higher)
        if (RECOVERY_LEVEL > 2) {
            console.log(`!! ðŸ›‘ MAX LEVEL ALERT: ${RECOVERY_LEVEL} consecutive losses detected. Resetting to Normal Mode. !!`);
            RECOVERY_LEVEL = 0; // Reset after failure
            LAST_PREDICTION_DIRECTION = null;
        }
        
        // Increase randomness after a LOSS
        RANDOMNESS_FACTOR = Math.min(0.5, RANDOMNESS_FACTOR * 1.5 + 0.1);
    }
    
    // Coordinate win/loss streaks outside of this function, as the coordinator manages the state.
    return isWin ? "WIN" : "LOSS"; // Return the standard status
}


function generateNumber(direction, period_number) {
    /** New: Selects a specific number (0-9) aligned with the direction. */
    const digits = get_last_four_digits(period_number);
    const lastDigit = digits.length > 0 ? digits[digits.length - 1] : Math.floor(Math.random() * 10);
    
    if (direction === 'BIG') {
        // Try to pick a BIG number (5-9) close to the last digit, or a random BIG
        if (lastDigit >= 5) return lastDigit;
        return Math.floor(Math.random() * 5) + 5; // 5, 6, 7, 8, 9
    } else {
        // Try to pick a SMALL number (0-4) close to the last digit, or a random SMALL
        if (lastDigit <= 4) return lastDigit;
        return Math.floor(Math.random() * 5); // 0, 1, 2, 3, 4
    }
}


// --- Integrated Utility Functions for Coordinator/Core Interop ---

function final_prediction_2lvl_recovery(period_number, actual_result_size = null, coordinator) {
    /**
     * The main function that orchestrates the prediction process,
     * managing the state for the upgraded 2-level recovery system (FIXED).
     */
    
    // The coordinator is required for access to dynamic data (win rate, streaks)
    if (!coordinator) throw new Error("Coordinator instance is required for final_prediction_2lvl_recovery.");

    let prediction;
    let confidence = 0;
    
    // **RECOVERY MODE LOGIC (Override)**
    if (RECOVERY_LEVEL > 0) {
        // Level 1 or 2 recovery is high-conviction. Use the aggressive logic as a sure-shot.
        prediction = aggressive_recovery_logic_v2(period_number, RECOVERY_LEVEL, PAST_RESULTS);
        confidence = RECOVERY_LEVEL === 2 ? 0.99 : 0.95;
    } else {
        // **NORMAL MODE**: Use the new core logic sequence
        const corePredData = final_prediction_core(
            period_number, 
            PAST_RESULTS, 
            LAST_PREDICTION_DIRECTION, 
            LAST_PREDICTION_RESULT,
            coordinator
        );
        prediction = corePredData.prediction;
        confidence = corePredData.confidence;
    }

    let resultStatus = null;
    // 2. Update System State (only if an actual result is provided, i.e., at the end of a period)
    if (actual_result_size !== null) {
        
        // Get the prediction that was made for this closed period
        const externalMadePrediction = coordinator.zenithAI.lastPrediction; 
        
        // *** FIX: Use the standard update_integrated_state and sync streaks based on standard WIN/LOSS ***
        resultStatus = update_integrated_state(actual_result_size, externalMadePrediction, RECOVERY_LEVEL > 0);
        
        // The coordinator needs to sync its streak count with the new RECOVERY_LEVEL
        coordinator.consecutiveLosses = RECOVERY_LEVEL;
        if (resultStatus === "WIN") {
            coordinator.consecutiveWins++;
        } else {
            coordinator.consecutiveWins = 0;
        }
        // *** END FIX ***
    }

    // 3. Return the calculated prediction
    return { prediction, confidence, resultStatus }; // resultStatus is only for logging/coordination
}


function aggressive_recovery_logic_v2(period_number, recovery_level, history) {
    /**
     * High-Certainty Logic for Recovery Mode.
     * The core idea of recovery is REVERSAL of the last outcome.
     */
    
    if (history.length > 0) {
        const last_result = history.at(-1);
        return last_result === "BIG" ? "SMALL" : "BIG";
    }
    
    // Fallback if no history
    const digits = get_last_four_digits(period_number);
    const total_sum = digits.reduce((a, b) => a + b, 0);
    return total_sum % 2 === 1 ? "BIG" : "SMALL";
}


// --- END PYTHON LOGIC EQUIVALENT ---

const LOCAL_STORAGE_KEY = 'zenithAICoreState';
const PREDICTOR_COORDINATOR_KEY = 'zenithPredictorCoordinatorState';

class zenithAICore {
    constructor() {
        this.history = [];
        this.config = config; // Expose config for logic functions
        this.modelWeights = {
            quantumEntanglement: 10,
            temporalFusion: 9.5,
            gan: 9.0,
            neuralNet: 8.5,
            patternRec: 7.0,
            aiFusion: 6.5,
            markov: 6.0,
            svm: 5.5,
            kmeans: 2.0,
            probabilistic: 1.5,
            rsi: 1.0,
            localCluster: 8.0,
            trendStrength: 7.5,
            cycleDetection: 9.0,
            patternMatrix: 9.5,
            anomalyDetection: 10.0,
            lstmSim: 10.5,
            bayesian: 9.8,
            reinforcement: 10.2,
            deepLearning: 11.0,
            transformer: 10.8,
            attentionNetwork: 11.2,
            evolutionary: 9.7,
            swarmIntelligence: 10.3,
            geneticAlgorithm: 10.5,
            bayesianNetwork: 11.0,
            antiStreak: 12.0,
            alternatingMatch: 11.5,
            weightedProbability: 10.5,
            lossRecovery: 20.0, // Increased weight for high-conviction recovery
            simulatedNN: 9.0,
            simulatedML: 9.2,
            mirrorPattern: 9.5,
            parityImbalance: 8.5,
            doubleRepeatBreak: 7.0,
            // Low-weight models from the original list for completeness, but typically overridden
            momentum: 4.0,
            zigzag: 3.5,
            frequency: 5.0,
            sequence: 4.5,
            fibonacci: 3.0,
            parabolicSAR: 2.5,
            martingale: 0.5,
            antiMartingale: 0.5,
        };

        this.modelPerformance = {};
        this.predictionCache = new Map();
        
        // The original logic's state variables are mapped here for synchronization with the coordinator.
        this.consecutiveWins = 0;
        this.consecutiveLosses = 0;
        this.lastPrediction = null; // lastPrediction in the original prompt
        this.lastActual = null;
        this.lastOppositeNumber = null; // New, for the core logic compatibility
        this.globalPrediction = null; // New, for the core logic compatibility

        this.aggressiveness = 10;
        this.strategy = 'trendFollowing';
        this.deepLearningEnabled = true;
        this.adaptiveModelsEnabled = true;
        this.learningRate = 0.87;
        this.minHistoryRequired = 5;

        this.initializeModels();
        this.loadState();
    }

    initializeModels() {
        // ... (Model definitions remain the same, only LossRecoveryModel is critical)
        // ... (Initialize Models code block)
        this.models = {
            // All existing models remain here for completeness, though many are placeholders
            momentum: this.MomentumModel(), zigzag: this.ZigZagModel(), frequency: this.FrequencyModel(), sequence: this.SequencePatternModel(), aiFusion: this.AIFusionModel(), markov: this.MarkovChainModel(), fibonacci: this.FibonacciModel(), martingale: this.MartingaleModel(), antiMartingale: this.AntiMartingaleModel(), parabolicSAR: this.ParabolicSARModel(), svm: this.SVMModel(), kmeans: this.KMeansModel(), patternRec: this.PatternRecognitionModel(), neuralNet: this.SimpleNeuralNetModel(), probabilistic: this.ProbabilisticModel(), rsi: this.RSIModel(), quantumEntanglement: this.QuantumEntanglementModel(), gan: this.GANModel(), temporalFusion: this.TemporalFusionModel(), localCluster: this.LocalClusterModel(), trendStrength: this.TrendStrengthModel(), cycleDetection: this.CycleDetectionModel(), patternMatrix: this.PatternMatrixModel(), anomalyDetection: this.AnomalyDetectionModel(), lstmSim: this.LSTMSimModel(), bayesian: this.BayesianModel(), reinforcement: this.ReinforcementModel(), deepLearning: this.DeepLearningModel(), transformer: this.TransformerModel(), attentionNetwork: this.AttentionNetworkModel(), evolutionary: this.EvolutionaryModel(), swarmIntelligence: this.SwarmIntelligenceModel(), geneticAlgorithm: this.GeneticAlgorithmModel(), bayesianNetwork: this.BayesianNetworkModel(), antiStreak: this.AntiStreakModel(), alternatingMatch: this.AlternatingMatchModel(), weightedProbability: this.WeightedProbabilityModel(), lossRecovery: this.LossRecoveryModel(), simulatedNN: this.SimulatedNNModel(), simulatedML: this.SimulatedMLModel(), mirrorPattern: this.MirrorPatternModel(), parityImbalance: this.ParityImbalanceModel(), doubleRepeatBreak: this.DoubleRepeatBreakModel()
        };

        for (const modelName in this.models) {
            this.modelPerformance[modelName] = {
                correct: 0,
                total: 0,
                accuracy: 0,
                weight: this.modelWeights[modelName] || 5.0
            };
        }
    }


    saveState() {
        const state = {
            modelWeights: this.modelWeights,
            modelPerformance: this.modelPerformance,
            consecutiveWins: this.consecutiveWins,
            consecutiveLosses: this.consecutiveLosses,
            lastPrediction: this.lastPrediction,
            lastActual: this.lastActual,
            lastOppositeNumber: this.lastOppositeNumber, // Save new variables
            globalPrediction: this.globalPrediction, // Save new variables
            aggressiveness: this.aggressiveness,
            strategy: this.strategy,
            deepLearningEnabled: this.deepLearningEnabled,
            adaptiveModelsEnabled: this.adaptiveModelsEnabled,
            learningRate: this.learningRate,
            // Include integrated state for persistence (optional, but robust)
            integratedRecoveryLevel: RECOVERY_LEVEL,
            integratedLastResult: LAST_PREDICTION_RESULT,
            integratedLastDirection: LAST_PREDICTION_DIRECTION,
            integratedRandomnessFactor: RANDOMNESS_FACTOR,
            integratedPastResults: PAST_RESULTS.items,
        };
        try {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));
        } catch (e) {
            console.error("Could not save zenithAICore state to local storage:", e);
        }
    }

    loadState() {
        try {
            const state = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (state) {
                const parsedState = JSON.parse(state);
                Object.assign(this, parsedState);

                for (const modelName in this.modelPerformance) {
                    const perf = this.modelPerformance[modelName];
                    if (perf.total > 0) {
                        perf.accuracy = perf.correct / perf.total;
                    }
                }
                
                // Load integrated state
                if (parsedState.integratedRecoveryLevel !== undefined) {
                    RECOVERY_LEVEL = parsedState.integratedRecoveryLevel;
                    LAST_PREDICTION_RESULT = parsedState.integratedLastResult;
                    LAST_PREDICTION_DIRECTION = parsedState.integratedLastDirection;
                    RANDOMNESS_FACTOR = parsedState.integratedRandomnessFactor;
                    PAST_RESULTS.items = parsedState.integratedPastResults || [];
                    // Ensure deque maxlen is respected on load
                    PAST_RESULTS.maxlen = 10;
                    while (PAST_RESULTS.items.length > PAST_RESULTS.maxlen) {
                        PAST_RESULTS.items.shift();
                    }
                }
            }
        } catch (e) {
            console.warn("Could not load ZenithAICore state from local storage:", e);
        }
    }

    updateDynamicWeights() {
        // ... (Existing updateDynamicWeights implementation)
        const modelsWithData = Object.values(this.modelPerformance).filter(p => p.total > 0);
        const totalAccuracy = modelsWithData.reduce((sum, p) => sum + p.accuracy, 0);

        if (modelsWithData.length === 0) return;

        for (const modelName in this.modelWeights) {
            const performance = this.modelPerformance[modelName];

            let baseWeight = this.modelWeights[modelName]; 

            if (performance.total > 0) {
                const normalizedAccuracy = totalAccuracy > 0 ? performance.accuracy / totalAccuracy : 0.01;
                baseWeight = Math.pow(normalizedAccuracy * 10, this.aggressiveness / 5);

                let strategyMultiplier = 1.0;
                switch (this.strategy) {
                    case 'conservative':
                        strategyMultiplier = 0.8;
                        break;
                    case 'aggressive':
                        strategyMultiplier = 1.2;
                        break;
                    case 'trendFollowing':
                        if (modelName.includes('trend') || modelName.includes('momentum') || modelName.includes('cycle')) {
                            strategyMultiplier = 1.5;
                        }
                        break;
                    case 'patternRecognition':
                        if (modelName.includes('pattern') || modelName.includes('sequence') || modelName.includes('antiStreak') || modelName.includes('alternating') || modelName.includes('mirror') || modelName.includes('repeat')) {
                            strategyMultiplier = 1.5;
                        }
                        break;
                    case 'quantum':
                        if (modelName.includes('quantum') || modelName.includes('bayesian') || modelName.includes('fusion')) {
                            strategyMultiplier = 2.0;
                        }
                        break;
                }

                this.modelWeights[modelName] = Math.max(0.5, baseWeight * strategyMultiplier);

                if (this.adaptiveModelsEnabled) {
                    const adaptation = performance.accuracy > 0.7 ? 1.2 : 0.8;
                    this.modelWeights[modelName] *= adaptation;
                }
            }
            this.modelWeights[modelName] = Math.min(20.0, Math.max(0.1, this.modelWeights[modelName]));
        }
        this.saveState();
    }

    updateModelPerformance(actualSize) {
        // ... (Existing updateModelPerformance implementation)
        for (const modelName in this.models) {
            // Generate a cache key that is independent of the model's prediction logic
            const modelPredCacheKey = modelName + "_" + (this.history[0]?.issueNumber || '0');
            let prediction = this.predictionCache.get(modelPredCacheKey);

            if (!prediction || modelName === 'lossRecovery') { 
                prediction = this.models[modelName].predict(this.history, {
                    consecutiveLosses: this.consecutiveLosses,
                    lastPrediction: this.lastPrediction,
                    lastActual: this.lastActual,
                    instance: this
                });
                this.predictionCache.set(modelPredCacheKey, prediction);
            }

            if (prediction.size) {
                // *** FIX: Model performance update must use standard WIN/LOSS (prediction size matches actual size) ***
                if (prediction.size === actualSize) {
                    this.modelPerformance[modelName].correct++;
                }
                this.modelPerformance[modelName].total++;
                this.modelPerformance[modelName].accuracy =
                    this.modelPerformance[modelName].correct / this.modelPerformance[modelName].total;
                // *** END FIX ***

                if (this.deepLearningEnabled) {
                    this.learningRate = 0.7 + (this.modelPerformance[modelName].accuracy * 0.3 * (this.modelWeights[modelName] / 10));
                    this.learningRate = Math.min(1.0, Math.max(0.5, this.learningRate));
                }
            }
        }
        this.updateDynamicWeights();
        this.saveState();
    }

    _mapToSize(number) {
        // Numbers 5 through 9 are BIG, 0 through 4 are SMALL.
        return number > 4 ? 'BIG' : 'SMALL';
    }

    // --- Specific Model Implementations ---

    // ... (All other models remain the same)

    LossRecoveryModel() {
        // This model implements the integrated 2-level recovery logic for the ensemble.
        return {
            predict: (history, context) => {
                const period_number = history[0] ? history[0].issueNumber || history[0].period : '00000000000'; // Get current period for digit analysis

                // If in RECOVERY MODE, this model provides the high-conviction prediction
                if (RECOVERY_LEVEL > 0) { 
                    // This uses the V2 aggressive logic (reversal of last outcome)
                    const prediction = aggressive_recovery_logic_v2(period_number, RECOVERY_LEVEL, PAST_RESULTS); 
                    
                    // Use a max confidence of 0.99 for the model level, allowing the ensemble to scale it up
                    return {
                        size: prediction,
                        confidence: 0.99
                    };
                }
                // When not in recovery, it can still provide a low-confidence prediction based on Fallback Loss Reversal
                else if (LAST_PREDICTION_RESULT === 'LOSS') {
                    const lastPredSize = LAST_PREDICTION_DIRECTION;
                    const prediction = lastPredSize === 'BIG' ? 'SMALL' : 'BIG'; // Reversal
                    return {
                        size: prediction,
                        confidence: 0.70
                    };
                }

                return {
                    size: null,
                    confidence: 0
                };
            }
        };
    }
    
    // ... (All other models remain the same)
    AntiStreakModel() {
        const MIN_STREAK = 3;
        return {
            predict: (history) => {
                if (history.length < MIN_STREAK) return {
                    size: null,
                    confidence: 0
                };
                // Reverse the history to analyze the most recent sequence
                const results = history.map(h => this._mapToSize(h.number));

                let streakType = results[0];
                let streakLength = 1;
                for (let i = 1; i < results.length; i++) {
                    if (results[i] === streakType) {
                        streakLength++;
                    } else {
                        break; // Streak is broken
                    }
                }

                if (streakLength >= MIN_STREAK) {
                    const opposite = streakType === 'BIG' ? 'SMALL' : 'BIG';
                    // Confidence increases with streak length
                    const confidence = Math.min(1.0, 0.7 + ((streakLength - MIN_STREAK + 1) / 10));
                    return {
                        size: opposite,
                        confidence
                    };
                }
                return {
                    size: null,
                    confidence: 0
                };
            }
        };
    }

    AlternatingMatchModel() {
        const MIN_LEN = 4;
        return {
            predict: (history) => {
                if (history.length < MIN_LEN) return {
                    size: null,
                    confidence: 0
                };
                const results = history.map(h => this._mapToSize(h.number));

                let isAlternating = true;
                for (let i = 1; i < MIN_LEN; i++) {
                    if (results[i] === results[i - 1]) {
                        isAlternating = false;
                        break;
                    }
                }

                if (isAlternating) {
                    // Predict the next one will be the opposite of the most recent result (results[0])
                    const prediction = results[0] === 'BIG' ? 'SMALL' : 'BIG';
                    return {
                        size: prediction,
                        confidence: 0.90
                    };
                }
                return {
                    size: null,
                    confidence: 0
                };
            }
        };
    }

    WeightedProbabilityModel() {
        const LOOKBACK = 15;
        const IMBALANCE_THRESHOLD = 0.2; // 70% Big or 30% Big (3 results difference in 10)
        return {
            predict: (history) => {
                if (history.length < LOOKBACK) return {
                    size: null,
                    confidence: 0
                };
                const last15 = history.slice(0, LOOKBACK);
                const bigCount = last15.filter(h => h.number > 4).length;
                const bigRatio = bigCount / LOOKBACK;
                const smallRatio = 1 - bigRatio;

                // Check for significant imbalance
                if (Math.abs(bigRatio - 0.5) > IMBALANCE_THRESHOLD) {
                    // Predict a regression to the mean (the opposite of the current bias)
                    const prediction = bigRatio > smallRatio ? 'SMALL' : 'BIG';
                    const confidence = Math.abs(bigRatio - 0.5); // Confidence is proportional to the imbalance
                    return {
                        size: prediction,
                        confidence: Math.min(0.95, 0.6 + confidence)
                    };
                }
                return {
                    size: null,
                    confidence: 0
                };
            }
        };
    }

    SimulatedNNModel() {
        const LOOKBACK = 15;
        const BIG_BIAS_THRESHOLD = 0.65;
        return {
            predict: (history) => {
                if (history.length === 0) return {
                    size: null,
                    confidence: 0
                };

                let prediction = this._mapToSize(history[0].number) === 'BIG' ? 'SMALL' : 'BIG'; // Default: Predict opposite of last result
                let confidence = 0.75;

                if (history.length >= LOOKBACK) {
                    const last15 = history.slice(0, LOOKBACK);
                    const bigRatio = last15.filter(h => h.number > 4).length / LOOKBACK;

                    // If big results are heavily biased, anticipate a strong correction to SMALL
                    if (bigRatio > BIG_BIAS_THRESHOLD) {
                        prediction = 'SMALL';
                        confidence = 0.90;
                    }
                    // If small results are heavily biased, anticipate a strong correction to BIG
                    else if (bigRatio < (1 - BIG_BIAS_THRESHOLD)) {
                        prediction = 'BIG';
                        confidence = 0.90;
                    }
                }

                return {
                    size: prediction,
                    confidence
                };
            }
        };
    }

    SimulatedMLModel() {
        const DOUBLE_REPEAT_LEN = 4;
        return {
            predict: (history) => {
                if (history.length < 2) return {
                    size: null,
                    confidence: 0
                };
                const results = history.map(h => this._mapToSize(h.number));

                if (history.length >= DOUBLE_REPEAT_LEN) {
                    const p = results.slice(0, DOUBLE_REPEAT_LEN);
                    // Check for a 'double-double' pattern (e.g., BBSS or SSBB)
                    if ((p[0] === p[1] && p[2] === p[3]) && (p[1] !== p[2])) {
                        // Pattern completion (e.g., if BBSS, predict B. if SSBB, predict S)
                        const prediction = p[0];
                        return {
                            size: prediction,
                            confidence: 0.88
                        };
                    }
                }

                // Fallback: Predict the second-to-last result (results[1]), indicating a simple repetition/continuation
                return {
                    size: results[1],
                    confidence: 0.65
                };
            }
        };
    }

    MirrorPatternModel() {
        const LOOKBACK = 4;
        return {
            predict: (history) => {
                if (history.length < LOOKBACK) return {
                    size: null,
                    confidence: 0
                };
                const results = history.map(h => this._mapToSize(h.number));
                const [r0, r1, r2, r3] = results;

                // If the last 4 results were strictly alternating (B-S-B-S or S-B-S-B)
                if (r0 !== r1 && r1 !== r2 && r2 !== r3) {
                    // Predict a "mirror" of the 4th-to-last result (r3) to break the alternation
                    const prediction = r3;
                    return {
                        size: prediction,
                        confidence: 0.85
                    };
                }
                return {
                    size: null,
                    confidence: 0
                };
            }
        };
    }

    ParityImbalanceModel() {
        const LOOKBACK = 15;
        const IMBALANCE_THRESHOLD = 4; // e.g., 9 Odd vs 6 Even
        return {
            predict: (history) => {
                if (history.length < LOOKBACK) return {
                    size: null,
                    confidence: 0
                };
                const last15 = history.slice(0, LOOKBACK);
                const odds = last15.filter(h => h.number % 2 !== 0).length;
                const evens = LOOKBACK - odds;

                if (Math.abs(odds - evens) >= IMBALANCE_THRESHOLD) {
                    // Check for the Size (BIG/SMALL) distribution during this parity imbalance
                    let bigCount = last15.filter(h => h.number > 4).length;
                    let smallCount = LOOKBACK - bigCount;

                    // If the current period is skewed towards one parity, the prediction logic
                    // assumes the **less frequent** Size will appear to restore balance.
                    const prediction = bigCount < smallCount ? 'BIG' : 'SMALL';
                    return {
                        size: prediction,
                        confidence: 0.78
                    };
                }
                return {
                    size: null,
                    confidence: 0
                };
            }
        };
    }

    DoubleRepeatBreakModel() {
        return {
            predict: (history) => {
                if (history.length < 2) return {
                    size: null,
                    confidence: 0
                };
                const results = history.map(h => this._mapToSize(h.number));
                const [r0, r1] = results;

                // If the last two results were the same (BB or SS)
                if (r0 === r1) {
                    // Predict a "break" in the streak (the opposite)
                    const opposite = r0 === 'BIG' ? 'SMALL' : 'BIG';
                    return {
                        size: opposite,
                        confidence: 0.77
                    };
                }
                return {
                    size: null,
                    confidence: 0
                };
            }
        };
    }


    _getNonBiasedPred(history) {
        if (history.length === 0) return {
            size: Math.random() > 0.5 ? 'BIG' : 'SMALL',
            confidence: 0.5
        };
        const last = this._mapToSize(history[0].number);
        // Fallback/Simulated: Predict the opposite of the last result, as a common simple strategy
        const prediction = last === 'BIG' ? 'SMALL' : 'BIG';
        return {
            size: prediction,
            confidence: 0.55 + (Math.random() * 0.1)
        };
    }

    MomentumModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    ZigZagModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    FrequencyModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    SequencePatternModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    AIFusionModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    MarkovChainModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    FibonacciModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    MartingaleModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    AntiMartingaleModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    ParabolicSARModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    SVMModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    KMeansModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    PatternRecognitionModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    SimpleNeuralNetModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    ProbabilisticModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    RSIModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    QuantumEntanglementModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    GANModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    TemporalFusionModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    LocalClusterModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    TrendStrengthModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    CycleDetectionModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    PatternMatrixModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    AnomalyDetectionModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    LSTMSimModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    BayesianModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    ReinforcementModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    DeepLearningModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    TransformerModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    AttentionNetworkModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    EvolutionaryModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    SwarmIntelligenceModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    GeneticAlgorithmModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }
    BayesianNetworkModel() {
        return {
            predict: (history) => this._getNonBiasedPred(history)
        };
    }


    async generatePrediction(history) {
        if (history.length < this.minHistoryRequired) {
            return {
                size: "BIG", // Default guess
                confidence: 50,
                insufficientData: true
            };
        }

        this.history = history;
        const historyKey = history.map(h => h.issueNumber || h.period).slice(0, 15).join(','); // Use a reasonable slice for cache key
        if (this.predictionCache.has(historyKey)) {
            return this.predictionCache.get(historyKey);
        }

        const modelPredictions = {};

        // Run all models
        for (const modelName in this.models) {
            // Skip deep learning models if disabled
            if (!this.deepLearningEnabled && (modelName.includes('deepLearning') || modelName.includes('transformer') || modelName.includes('attention'))) continue;

            const modelPredCacheKey = modelName + "_" + historyKey;
            let prediction = this.predictionCache.get(modelPredCacheKey);

            if (!prediction || modelName === 'lossRecovery' || modelName === 'weightedProbability') { // Always recalculate high-conviction/state-dependent models
                prediction = this.models[modelName].predict(history, {
                    consecutiveLosses: this.consecutiveLosses,
                    lastPrediction: this.lastPrediction,
                    lastActual: this.lastActual,
                    instance: this
                });
                this.predictionCache.set(modelPredCacheKey, prediction); // Cache model-specific prediction
            }
            modelPredictions[modelName] = prediction;
        }

        let prediction = this.ensemblePredict(modelPredictions);

        const finalPrediction = {
            size: prediction.size,
            confidence: prediction.confidence,
        };

        this.predictionCache.set(historyKey, finalPrediction); // Cache the final ensemble prediction
        return finalPrediction;
    }

    ensemblePredict(predictions) {
        const votes = {
            BIG: 0,
            SMALL: 0
        };
        const aggressivenessFactor = this.aggressiveness / 10;

        for (const modelName in predictions) {
            const pred = predictions[modelName];
            if (pred.size) {
                // Confidence is scaled between 0 and 1
                const predConfidence = Math.min(1.0, Math.max(0, pred.confidence));

                // Weight is a product of dynamic model weight and confidence
                const weight = this.modelWeights[modelName] * Math.pow(predConfidence, aggressivenessFactor);
                votes[pred.size] += weight;
            }
        }

        const totalVotes = votes.BIG + votes.SMALL;
        const bigRatio = totalVotes > 0 ? votes.BIG / totalVotes : 0.5;

        // Final confidence is derived from the dominance of the winning vote
        const finalConfidence = (Math.max(bigRatio, 1 - bigRatio) * 100);

        return {
            size: bigRatio >= 0.5 ? 'BIG' : 'SMALL', // Default to BIG on tie
            confidence: parseFloat(finalConfidence.toFixed(2))
        };
    }

    getModelPerformance() {
        return this.modelPerformance;
    }

    setAggressiveness(value) {
        this.aggressiveness = value;
        this.updateDynamicWeights();
    }

    setStrategy(strategy) {
        this.strategy = strategy;
        this.updateDynamicWeights();
    }

    setDeepLearning(enabled) {
        this.deepLearningEnabled = enabled;
        this.saveState();
    }

    setAdaptiveModels(enabled) {
        this.adaptiveModelsEnabled = enabled;
        this.saveState();
    }

    getLearningRate() {
        return this.learningRate;
    }
}

class ZenithPredictorCoordinator {
    constructor() {
        this.patternWeights = {
            wmaTrend: 0.3,
            microPatterns: 0.25,
            momentum: 0.2,
            frequency: 0.25
        };

        this.safetyThresholds = {
            volatilitySpike: 2.5,
            entropyHigh: 0.8,
            clusterTrap: 0.7
        };

        this.consecutiveLosses = 0;
        this.consecutiveWins = 0;
        this.mode = 'normal';

        this.zenithAI = new zenithAICore();
        this.zenithAI.setStrategy('trendFollowing');

        // This replaces the historyData array from the original prompt
        this.history = []; 
        this.predictionLog = [];
        this.lastFetchedPeriod = null; // Equivalent to the original prompt's state

        this.loadState();
    }

    saveState() {
        const state = {
            patternWeights: this.patternWeights,
            consecutiveLosses: this.consecutiveLosses,
            consecutiveWins: this.consecutiveWins,
            mode: this.mode,
            predictionLog: this.predictionLog.slice(-20), // Only save recent logs
            lastFetchedPeriod: this.lastFetchedPeriod,
        };
        try {
            localStorage.setItem(PREDICTOR_COORDINATOR_KEY, JSON.stringify(state));
        } catch (e) {
            console.error("Could not save ZenithPredictorCoordinator state to local storage:", e);
        }
    }

    loadState() {
        try {
            const state = localStorage.getItem(PREDICTOR_COORDINATOR_KEY);
            if (state) {
                const parsedState = JSON.parse(state);
                Object.assign(this, parsedState);
            }
        } catch (e) {
            console.warn("Could not load ZenithPredictorCoordinator state from local storage:", e);
        }
    }

    analyzePatterns(history) {
        // ... (Existing analyzePatterns implementation)
        const patterns = {};

        const shortTerm = this.calculateWMA(history.slice(0, 7));
        const longTerm = this.calculateWMA(history.slice(0, 25));
        patterns.wmaTrend = {
            prediction: shortTerm > longTerm ? 'BIG' : 'SMALL',
            confidence: Math.abs(shortTerm - longTerm) * 10,
            strength: 'trend'
        };

        const last10 = history.slice(0, 10).map(h => h.number > 4 ? 'B' : 'S');
        const microPattern = this.detectMicroPattern(last10);
        patterns.microPatterns = {
            prediction: microPattern === 'B' ? 'BIG' : 'SMALL',
            confidence: 0.85,
            strength: 'pattern'
        };

        const momentum = this.calculateMomentum(history.slice(0, 10));
        patterns.momentum = {
            prediction: momentum > 70 ? 'BIG' : momentum < 30 ? 'SMALL' : null,
            confidence: Math.abs(momentum - 50) / 50,
            strength: 'momentum'
        };

        const frequency = this.calculateFrequency(history.slice(0, 20));
        patterns.frequency = {
            prediction: frequency.bigRatio > 0.6 ? 'BIG' : frequency.smallRatio > 0.6 ? 'SMALL' : null,
            confidence: Math.max(frequency.bigRatio, frequency.smallRatio),
            strength: 'frequency'
        };

        return patterns;
    }

    assessSafety(history) {
        // ... (Existing assessSafety implementation)
        const safety = {
            score: 'green',
            flags: [],
            volatility: 0,
            entropy: 0
        };

        safety.volatility = this.calculateVolatility(history.slice(0, 20));
        if (safety.volatility > this.safetyThresholds.volatilitySpike) {
            safety.score = 'red';
            safety.flags.push('high_volatility');
        }

        safety.entropy = this.calculateEntropy(history.slice(0, 15));
        if (safety.entropy > this.safetyThresholds.entropyHigh) {
            safety.score = 'red';
            safety.flags.push('high_entropy');
        }

        const clusterBias = this.detectClusterBias(history);
        if (clusterBias > this.safetyThresholds.clusterTrap) {
            safety.score = safety.score === 'green' ? 'yellow' : 'red';
            safety.flags.push('cluster_trap');
        }

        return safety;
    }

    updateReinforcement(actualResultSize, internalPrediction) {
        
        this.zenithAI.lastActual = actualResultSize; 
        
        // --- LOGIC INTEGRATION: Update Python State first ---
        const lastPredictionLog = this.predictionLog[this.predictionLog.length - 1];
        const period_number = lastPredictionLog ? lastPredictionLog.period : '00000000000';
        
        // **FIXED**: This calls the integrated state update function. It performs the *standard* WIN/LOSS check.
        const integratedPredData = final_prediction_2lvl_recovery(period_number, actualResultSize, this); // Pass the coordinator instance

        const resultStatus = integratedPredData.resultStatus;
        
        this.consecutiveLosses = RECOVERY_LEVEL; // Keep coordinator state in sync with Python state for mode switching
        // consecutiveWins is updated within final_prediction_2lvl_recovery now
        
        // --- END LOGIC INTEGRATION ---
        
        if (!internalPrediction) return resultStatus;

        // Adaptive strategy change on loss based on the new RECOVERY_LEVEL
        if (this.consecutiveLosses === 0) {
            this.mode = 'normal';
            this.zenithAI.setStrategy('trendFollowing'); // Revert to a stable strategy on win/reset
        } else if (this.consecutiveLosses === 1) {
            this.mode = 'cautious';
            this.zenithAI.setStrategy('patternRecognition');
        } else if (this.consecutiveLosses === 2) {
            this.mode = 'sureShot';
            this.zenithAI.setStrategy('quantum'); // Aggressive switch to high-conviction models
        }
        
        this.saveState();
        return resultStatus;
    }

    async generateDirectPrediction(history, period) {
        if (history.length < 5) {
            const randomPred = this.generateRandomDirect(period);
            this.predictionLog.push(randomPred);
            this.saveState();
            return randomPred;
        }

        this.history = history;

        const patterns = this.analyzePatterns(history);
        const safety = this.assessSafety(history);

        // --- CORE AI PREDICTION ---
        // Ensemble prediction provides a base and confidence
        let zenithPred = await this.zenithAI.generatePrediction(history);

        // --- LOGIC INTEGRATION: OVERRIDE WITH PYTHON LOGIC (Core Logic/Recovery) ---
        // This is a LOOK-AHEAD call to determine the prediction for the *current* period (actual_result_size is null)
        const integratedPredData = final_prediction_2lvl_recovery(period, null, this);
        
        // The integrated logic (which includes Pattern Analysis and Fallback) is the FINAL prediction source
        let finalPrediction = integratedPredData.prediction;
        let finalConfidence = integratedPredData.confidence * 100;

        // Apply mode and safety overrides (Zenith's confidence can be used as a tie-breaker/modifier)
        if (this.mode === 'sureShot') {
            // In sureShot mode, the confidence is boosted
            finalConfidence = Math.max(finalConfidence, 95.0);
        }

        if (safety.score === 'red' && finalConfidence > 90) {
            // Drop confidence significantly on high uncertainty/volatility
            finalConfidence = 70.0 + (finalConfidence - 90.0) * 0.5;
        }
        
        // If the integrated logic provided a low confidence, fallback to the ensemble's strong prediction
        if (integratedPredData.confidence < 0.60 && zenithPred.confidence > 75) {
             finalPrediction = zenithPred.size;
             finalConfidence = zenithPred.confidence;
        }


        const finalOutput = {
            size: finalPrediction,
            confidence: parseFloat(finalConfidence.toFixed(2)),
            internalPrediction: finalPrediction, // Use the final prediction as the internal prediction for logging/reinforcement
            internalConfidence: zenithPred.confidence,
            mode: this.mode,
            safety: safety.score,
            patterns: Object.keys(patterns),
            timestamp: Date.now(),
            period: period
        };
        
        // Log the final prediction and confidence
        this.predictionLog.push(finalOutput);
        
        // This is the prediction the coordinator is finalizing, so the AI Core needs to store it
        this.zenithAI.lastPrediction = finalPrediction; 
        
        // --- ORIGINAL PROMPT LOGIC ADDITION ---
        this.zenithAI.globalPrediction = finalPrediction;
        this.zenithAI.lastOppositeNumber = getOppositeNumber(finalPrediction, period);
        // --- END ORIGINAL PROMPT LOGIC ADDITION ---

        this.saveState();
        return finalOutput;
    }
    
    // ... (All other helper functions remain the same)
    calculateWMA(data) {
        if (data.length === 0) return 0.5;
        const numbers = data.map(d => d.number);
        // Weight: last result gets highest weight
        const totalWeight = numbers.reduce((sum, _, i) => sum + (i + 1), 0);
        const weightedSum = numbers.reduce((sum, num, i) => sum + (num * (data.length - i)), 0); // Reverse weights
        // Normalize the sum of results (0-9) to a 0.0-1.0 range (mean is 4.5/9 = 0.5)
        return (weightedSum / totalWeight) / 9;
    }

    calculateMomentum(data) {
        if (data.length < 10) return 50;
        const bigCount = data.filter(d => d.number > 4).length;
        return (bigCount / data.length) * 100;
    }

    calculateFrequency(data) {
        const bigCount = data.filter(d => d.number > 4).length;
        const smallCount = data.length - bigCount;
        return {
            bigRatio: bigCount / data.length,
            smallRatio: smallCount / data.length
        };
    }

    detectMicroPattern(sequence) {
        // Pattern logic: Predict the opposite of the current repeating short pattern
        const patterns = {
            'BBB': 'S',
            'SSS': 'B', // Anti-streak (3-long)
            'BSB': 'B',
            'SBS': 'S', // Simple alternation continuation
            'BBSS': 'B',
            'SSBB': 'S', // 2-by-2 break
        };

        const last4 = sequence.slice(0, 4).join('');
        const last3 = sequence.slice(0, 3).join('');

        return patterns[last4] || patterns[last3] || (Math.random() > 0.5 ? 'B' : 'S');
    }

    calculateVolatility(data) {
        if (data.length < 2) return 0;
        const numbers = data.map(d => d.number);
        const mean = numbers.reduce((a, b) => a + b, 0) / numbers.length;
        const variance = numbers.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / numbers.length;
        return Math.sqrt(variance); // Standard Deviation
    }

    calculateEntropy(data) {
        if (data.length === 0) return 0;
        const bigProb = data.filter(d => d.number > 4).length / data.length;
        const smallProb = 1 - bigProb;

        // Shannon Entropy for a binary outcome (BIG/SMALL)
        if (bigProb === 0 || smallProb === 0) return 0;
        return -(bigProb * Math.log2(bigProb) + smallProb * Math.log2(smallProb));
    }

    detectClusterBias(history) {
        const recent = history.slice(0, 5);
        const bigBias = recent.filter(d => d.number > 4).length / recent.length;
        // Returns 1.0 for all BIG or all SMALL, 0.0 for 50/50 split
        return Math.abs(bigBias - 0.5) * 2;
    }

    generateRandomDirect(period) {
        const directPred = Math.random() > 0.5 ? 'BIG' : 'SMALL';

        return {
            size: directPred,
            confidence: 50 + Math.random() * 10,
            internalPrediction: directPred,
            internalConfidence: 0.5,
            mode: 'random',
            timestamp: Date.now(),
            period: period
        };
    }

    updatePatternWeights(lastPred, actualResult) {
        const wasCorrect = lastPred.internalPrediction === actualResult;
        const adjustment = wasCorrect ? 1.1 : 0.9;

        // This function is currently not called in the main logic, but kept for future expansion
        lastPred.patterns.forEach(pattern => {
            if (this.patternWeights[pattern]) {
                this.patternWeights[pattern] *= adjustment;
                this.patternWeights[pattern] = Math.max(0.1,
                    Math.min(0.5, this.patternWeights[pattern]));
            }
        });
        this.saveState();
    }
}

// Global instances for easy access in the client-side code
const predictorCoordinator = new ZenithPredictorCoordinator();
const zenithCoreAI = predictorCoordinator.zenithAI;

// Helper functions for mapping results
const getBigSmallOutcome = (num) => (num >= 5) ? 'BIG' : 'SMALL';
const getRedGreenOutcome = (num) => (num % 2 === 0) ? 'RED' : 'GREEN'; // Assuming 0 is RED (even)

// --- ORIGINAL PROMPT CORE LOGIC ADAPTATION ---

// Helper function from original prompt logic
function getOppositeNumber(prediction, period_number) {
    const small = [0, 1, 2, 3, 4];
    const big = [5, 6, 7, 8, 9];
    let arr = prediction === "BIG" ? small : big;
    // We use the Python-equivalent generateNumber for a slightly more intelligent opposite number
    // but fall back to the random picker from the original prompt if needed.
    const specificNumber = generateNumber(prediction === 'BIG' ? 'SMALL' : 'BIG', period_number);
    if (arr.includes(specificNumber)) return specificNumber;
    
    return arr[Math.floor(Math.random() * arr.length)];
}

// This array will hold the history data for UI display, keeping the original UI logic intact
let historyData = [];
// Other original global variables are now managed by predictorCoordinator or zenithCoreAI

/**
 * Replaces the original prompt's updateLastStatus(actualNumber) logic.
 * This adapted function only updates the historyData array for the UI.
 * *** FIX: This function now takes the determined resultStatus from the AI Core (which uses standard logic).
 * The old flawed WIN/LOSS logic has been removed from the reinforcement pipeline but is kept here
 * as a secondary flag for UI if the user insists on it. The AI Core is reinforced via standard logic. ***
 * @param {number} actualNumber - The result number of the last closed period.
 * @param {string} coreResultStatus - The 'WIN' or 'LOSS' status determined by the AI Core (standard logic).
 * @returns {string} The result status ('WIN' or 'LOSS') for UI display.
 */
function updateHistoryStatus(actualNumber, coreResultStatus) {
    if (historyData.length === 0) return 'Pending';
    
    // Get the prediction made for this closed period from the local history
    const lastPredictionEntry = historyData[0];
    if (lastPredictionEntry.resultStatus !== "Pending") {
        // Already processed, shouldn't happen but acts as a safeguard
        return lastPredictionEntry.resultStatus;
    }
    
    // **FIXED**: The primary status is the one determined by the AI Core (standard WIN=size match)
    // The previous buggy logic is now *only* for the `calculation` field to show the original intent.
    const actualResultSize = getBigSmallOutcome(actualNumber);
    
    // The WIN condition from the original logic (kept for the calculation display ONLY):
    const lastPrediction = lastPredictionEntry.prediction;
    const lastOppositeNumber = lastPredictionEntry.oppositeNumber;
    const originalLogicMatch = (actualNumber == lastOppositeNumber) || (actualResultSize === lastPrediction);
    
    const lastStatus = coreResultStatus; // Use the correct, standard-logic status
    
    // Update the first entry (the closed period)
    lastPredictionEntry.result = actualNumber;
    lastPredictionEntry.resultStatus = lastStatus;
    lastPredictionEntry.resultType = actualResultSize;
    // Display the original buggy logic's result in the calculation field to show it's different from the final status
    lastPredictionEntry.calculation = `Number ${actualNumber} (${actualResultSize}). Original Match: ${originalLogicMatch ? 'TRUE' : 'FALSE'}`;
    
    return lastStatus;
}


/**
 * Replaces the original prompt's updatePrediction() logic.
 * It uses the ZenithPredictorCoordinator for core AI logic.
 */
async function updatePrediction() {
    // A mock/placeholder for the original fetchGameResult
    const result = await fetchGameResultMock(); 
    
    // Safety check for invalid result or already fetched period
    if (!result || result.issueNumber === predictorCoordinator.lastFetchedPeriod) return;

    const actualNumber = Number(result.number);

    // --- 1. PROCESS LAST PERIOD'S RESULT (if pending) ---
    if (historyData.length > 0 && historyData[0].resultStatus === "Pending") {
        const lastPredictionEntry = historyData[0];
        const actualResultSize = getBigSmallOutcome(actualNumber);
        
        // 1a. Update reinforcement state (AI Core Logic)
        // This updates consecutiveLosses/Wins, RECOVERY_LEVEL, and model performance.
        const coreResultStatus = predictorCoordinator.updateReinforcement(actualResultSize, lastPredictionEntry.prediction);
        zenithCoreAI.updateModelPerformance(actualResultSize); // Ensure models are reinforced

        // 1b. Update local history data for UI (using adapted original logic, but passing the correct status)
        updateHistoryStatus(actualNumber, coreResultStatus);

        // 1c. Trigger UI updates
        updateHistory();
        updateStats();
    }

    // --- 2. GENERATE PREDICTION FOR NEXT PERIOD ---
    // Fetch the full history for the AI Core
    const historyForAI = previousResults.map(item => ({
        number: item.number,
        issueNumber: item.issueNumber || item.period
    }));
    zenithCoreAI.history = historyForAI;
    
    // The next period number
    const nextPeriodFull = (BigInt(result.issueNumber) + 1n).toString();
    const nextPeriod = nextPeriodFull.slice(-4);
    
    // Generate the prediction using the integrated coordinator logic
    const aiDecision = await predictorCoordinator.generateDirectPrediction(historyForAI, nextPeriod);
    
    // Synchronize global state from the AI Core
    const globalPrediction = zenithCoreAI.globalPrediction;
    const lastOppositeNumber = zenithCoreAI.lastOppositeNumber;
    
    if (globalPrediction) {
        // 3. Update UI elements for current/next period
        const currentPeriodEl = document.getElementById("currentPeriod");
        const currentPredictionEl = document.getElementById("currentPrediction");
        if (currentPeriodEl) currentPeriodEl.textContent = nextPeriod;
        if (currentPredictionEl) currentPredictionEl.textContent = globalPrediction || '-';
        
        // 4. Add new prediction to the historyData array (as pending)
        historyData.unshift({
            period: nextPeriod,
            prediction: globalPrediction,
            oppositeNumber: lastOppositeNumber,
            result: null,
            resultStatus: "Pending",
            resultType: "-",
            calculation: "Prediction",
        });

        // Cap historyData length to prevent memory issues
        if (historyData.length > 50) {
             historyData.pop();
        }

        // 5. Final UI updates and state sync
        updateHistory();
        updateStats();
        predictorCoordinator.lastFetchedPeriod = result.issueNumber;
        predictorCoordinator.saveState();
        zenithCoreAI.saveState();
    }
}


// --- MOCK/PLACEHOLDER FOR ORIGINAL FUNCTIONS (REMAINING UI LOGIC) ---

// Mock function for fetchGameResult - replace with actual implementation
async function fetchGameResultMock() {
    // This mocks fetching the *last closed period's* result and the *new period number*.
    // In a real application, this should be the same logic as fetchCurrentGameIssue.
    // For now, we rely on previousResults to hold the true historical data.
    if (previousResults.length > 0) {
        return {
             issueNumber: previousResults[0].issueNumber, // Last closed period number
             number: previousResults[0].number // Last closed period number
        }
    }
    return { issueNumber: '20251005000', number: 5 }; // Fallback
}


function updateHistory() {
    const container = document.getElementById("historyContainer");
    if (!container) return;
    container.innerHTML = historyData.map((item, index) => `
        <div class="history-item p-4 rounded-lg">
          <div class="flex justify-between items-center">
            <div class="flex items-center space-x-3">
              <div class="w-8 h-8 rounded-full bg-[var(--primary-color)]/10 flex items-center justify-center">
                <i class="fas fa-hashtag text-[var(--primary-color)] text-sm"></i>
              </div>
              <div>
                <p class="text-xs opacity-80">Period</p>
                <p class="font-semibold">${item.period?.slice(-4) || '-'}</p>
              </div>
            </div>
            <div class="flex items-center space-x-3">
              <div class="text-center">
                <p class="text-xs opacity-80">Prediction</p>
                <p class="font-semibold ${item.prediction === 'BIG' ? 'text-[var(--tertiary-color)]' : 'text-[var(--primary-color)]'}">${item.prediction || '-'}</p>
              </div>
              <div class="w-8 h-8 rounded-full flex items-center justify-center ${item.resultStatus === 'WIN' ? 'win-status' : item.resultStatus === 'LOSS' ? 'loss-status' : 'pending-status'}">
                <i class="fas ${item.resultStatus === 'WIN' ? 'fa-check text-green-500' : item.resultStatus === 'LOSS' ? 'fa-times text-red-500' : 'fa-clock text-yellow-500 animate-spin'} text-sm"></i>
              </div>
              <button class="delete-btn text-sm opacity-70 hover:opacity-100" data-index="${index}">
                <i class="fas fa-trash"></i>
              </button>
            </div>
          </div>
        </div>
    `).join("");

    document.querySelectorAll('.delete-btn').forEach(button => {
        button.addEventListener('click', (e) => {
            const index = parseInt(e.currentTarget.getAttribute('data-index'));
            historyData.splice(index, 1);
            // Assuming showToast is defined elsewhere, if not, this will error silently.
            if (typeof showToast === 'function') showToast("Deleted successfully"); 
            updateHistory();
            updateStats();
        });
    });
}

function updateStats() {
    const wins = historyData.filter(item => item.resultStatus === "WIN").length;
    const losses = historyData.filter(item => item.resultStatus === "LOSS").length;

    const winsElement = document.getElementById("wins");
    const lossesElement = document.getElementById("losses");
    
    if (winsElement) winsElement.textContent = wins;
    if (lossesElement) lossesElement.textContent = losses;
    
    // Synchronize global streak info to a simplified UI element if they exist
    const streakElement = document.getElementById("streak");
    const winLevelElement = document.getElementById("winLevel");
    const consecutiveLossesElement = document.getElementById("consecutiveLosses");
    
    if (streakElement) streakElement.textContent = predictorCoordinator.consecutiveWins; // Using wins as a proxy for the simple streak
    if (winLevelElement) winLevelElement.textContent = RECOVERY_LEVEL === 0 ? 'MAX' : 'L'+(RECOVERY_LEVEL); // Display RECOVERY_LEVEL
    if (consecutiveLossesElement) consecutiveLossesElement.textContent = predictorCoordinator.consecutiveLosses; 
}

function clearHistory() {
    // Reset all states
    historyData = [];
    RECOVERY_LEVEL = 0;
    LAST_PREDICTION_RESULT = null;
    LAST_PREDICTION_DIRECTION = null;
    RANDOMNESS_FACTOR = 0.1;
    PAST_RESULTS.items = [];

    predictorCoordinator.consecutiveLosses = 0;
    predictorCoordinator.consecutiveWins = 0;
    predictorCoordinator.zenithAI.consecutiveLosses = 0;
    predictorCoordinator.zenithAI.consecutiveWins = 0;
    predictorCoordinator.zenithAI.lastPrediction = null;

    updateHistory();
    updateStats();
    predictorCoordinator.saveState();
    zenithCoreAI.saveState();
    
    if (typeof showToast === 'function') showToast("History cleared successfully"); 
}

// --- END ORIGINAL PROMPT CORE LOGIC ADAPTATION ---

// Export for use in other modules (Node/CommonJS environment, won't run in browser directly)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        zenithAICore,
        ZenithPredictorCoordinator,
        predictorCoordinator,
        zenithCoreAI,
        getBigSmallOutcome,
        getRedGreenOutcome
    };
}


document.addEventListener('DOMContentLoaded', function() {

    // --- Tab System and UI Logic ---
    const tabs = document.querySelectorAll('.tab');
    const contentSections = document.querySelectorAll('.content-section');
    tabs.forEach(tab => {
        tab.addEventListener('click', function() {
            const tabId = this.getAttribute('data-tab');

            // --- FIX START ---
            // Deactivate all tabs and content sections first
            tabs.forEach(t => {
                t.classList.remove('active');
                t.setAttribute('aria-selected', 'false');
            });
            contentSections.forEach(section => {
                section.classList.remove('active');
            });
            // --- FIX END ---

            // Activate the clicked tab
            this.classList.add('active');
            this.setAttribute('aria-selected', 'true');

            // Activate the corresponding content section
            const targetSection = document.getElementById(`${tabId}-section`);
            if (targetSection) {
                targetSection.classList.add('active');
                if (tabId === 'history') {
                    fetchData();
                } else if (tabId === 'analysis') {
                    performAdvancedAnalysis();
                    displayAllStrategies();
                }
            }
        });
    });

    const gameSelection = document.getElementById('gameSelection');
    const gameFrame = document.getElementById('gameFrame');
    const gameItems = document.querySelectorAll('.game-item');
    const injectorTape = document.getElementById('injectorTape');
    gameItems.forEach(item => {
        item.addEventListener('click', function() {
            const gameUrl = this.getAttribute('data-url');
            gameFrame.src = gameUrl;
            gameSelection.style.display = 'none';
            gameFrame.classList.remove('hidden');
            injectorTape.classList.remove('hidden');
            this.classList.add('active');
            setTimeout(() => this.classList.remove('active'), 500);
        });
    });

    injectorTape.addEventListener('click', function() {
        gameFrame.classList.add('hidden');
        gameSelection.style.display = "flex";
        injectorTape.classList.add('hidden');
        gameFrame.src = '';
    });

    function createParticles() {
        const colors = ['rgba(37, 99, 235, 0.25)', 'rgba(59, 130, 246, 0.25)', ' rgba(96, 165, 250, 0.25)'];
        for (let i = 0; i < 20; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            const size = Math.random() * 10 + 3;
            const posX = Math.random() * window.innerWidth;
            const posY = Math.random() * window.innerHeight;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const duration = Math.random() * 20 + 10;
            const delay = Math.random() * 5;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.left = `${posX}px`;
            particle.style.top = `${posY}px`;
            particle.style.background = color;
            particle.style.opacity = Math.random() * 0.5 + 0.1;
            particle.style.animationDuration = `${duration}s`;
            particle.style.animationDelay = `${delay}s`;
            // Note: Commented out appending particles to body to prevent layout issues if no CSS is provided
            // document.body.appendChild(particle); 
        }
    }

    const filterButtons = document.querySelectorAll('.filter-btn');
    filterButtons.forEach(button => {
        button.addEventListener('click', function() {
            const filter = this.getAttribute('data-filter');
            filterButtons.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            const historyItems = document.querySelectorAll('.history-item');
            historyItems.forEach(item => {
                if (filter === 'all') {
                    item.style.display = 'grid';
                } else {
                    const sumElement = item.querySelector('.history-value-highlight');
                    const colorDotElement = item.querySelector('.color-dot');

                    if (!sumElement || !colorDotElement) return;

                    const sum = parseInt(sumElement.textContent, 10);
                    const isBig = sum >= 5;
                    const isRed = colorDotElement.classList.contains('color-red');

                    if ((filter === 'big' && isBig) || (filter === 'small' && !isBig) || (filter === 'red' && isRed) || (filter === 'green' && !isRed)) {
                        item.style.display = 'grid';
                    } else {
                        item.style.display = 'none';
                    }
                }
            });
        });
    });

    // Fetch data for history tab
    async function fetchData() {
        try {
            const historyContent = document.getElementById('historyContent');
            if (!historyContent) return;

            historyContent.innerHTML = '<div class="loading-container"><i class="fas fa-spinner fa-spin"></i> LOADING DATA...</div>';

            const timestamp = Date.now();
            // This API endpoint is specific to the original logic's game and may need updating
            const response = await fetch(`https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json?ts=${timestamp}&pageSize=50`);

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            if (data && data.data && data.data.list && data.data.list.length > 0) {
                displayHistory(data.data.list);
            } else {
                historyContent.innerHTML = '<div class="no-data-container"><i class="fas fa-info-circle"></i> NO DATA AVAILABLE</div>';
            }
        } catch (error) {
            console.error('Error fetching data:', error);
            const historyContent = document.getElementById('historyContent');
            if (historyContent) {
                historyContent.innerHTML = '<div class="error-container"><i class="fas fa-exclamation-triangle"></i> ERROR LOADING DATA</div>';
            }
        }
    }

    // Display history data
    function displayHistory(data) {
        const historyContent = document.getElementById('historyContent');
        if (!historyContent) return;

        if (!data || data.length === 0) {
            historyContent.innerHTML = '<div class="no-data-container"><i class="fas fa-info-circle"></i> NO DATA AVAILABLE</div>';
            return;
        }

        let html = `
            <div class="history-header">
                <div class="history-header-item"></div>
                <div class="history-header-item"></div>
                <div class="history-header-item"></div>
                <div class="history-header-item"></div>
            </div>
        `;

        let totalCount = 0;

        data.forEach(item => {
            const sum = parseInt(item.premium || item.result || item.number || 0, 10);
            const bigSmall = getBigSmallOutcome(sum);
            const isEven = sum % 2 === 0;
            const redGreen = isEven ? 'RED' : 'GREEN';
            // Note: 5 is green, 0 is red in some games. This assumes general parity where even is 'Red' and odd is 'Green'.
            const colorClass = isEven ? 'color-red' : 'color-green';

            totalCount++;

            html += `
                <div class="history-item">
                    <div>
                        <div class="history-value">${item.issueNumber || item.period || 'N/A'}</div>
                    </div>
                    <div>
                        <div class="history-value-highlight">${sum}</div>
                    </div>
                    <div>
                        <div class="history-value">${bigSmall}</div>
                    </div>
                    <div>
                        <div class="history-value">
                            <span class="color-dot ${colorClass}"></span>${redGreen}
                        </div>
                    </div>
                </div>
            `;
        });

        const totalCountElement = document.getElementById('total-count');
        if (totalCountElement) {
            totalCountElement.textContent = totalCount;
        }

        historyContent.innerHTML = html;
    }

    // Perform advanced analysis
    async function performAdvancedAnalysis() {
        try {
            const analysisContent = document.getElementById('advancedAnalysis');
            if (!analysisContent) return;

            analysisContent.innerHTML = '<div class="loading-container"><i class="fas fa-spinner fa-spin"></i> ANALYZING DATA PATTERNS...</div>';

            const timestamp = Date.now();
            const response = await fetch(`https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json?ts=${timestamp}&pageSize=100`);

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            if (data && data.data && data.data.list && data.data.list.length > 0) {
                displayAdvancedAnalysis(data.data.list);
            } else {
                analysisContent.innerHTML = '<div class="no-data-container"><i class="fas fa-info-circle"></i> NO DATA AVAILABLE FOR ANALYSIS</div>';
            }
        } catch (error) {
            console.error('Error fetching analysis data:', error);
            const analysisContent = document.getElementById('advancedAnalysis');
            if (analysisContent) {
                analysisContent.innerHTML = '<div class="error-container"><i class="fas fa-exclamation-triangle"></i> ERROR LOADING ANALYSIS DATA</div>';
            }
        }
    }

    // Display advanced analysis
    function displayAdvancedAnalysis(data) {
        const analysisContent = document.getElementById('advancedAnalysis');
        if (!analysisContent) return;

        if (!data || data.length === 0) {
            analysisContent.innerHTML = '<div class="no-data-container"><i class="fas fa-info-circle"></i> NO DATA AVAILABLE FOR ANALYSIS</div>';
            return;
        }

        const numbers = data.map(item => parseInt(item.premium || item.result || item.number || 0, 10));
        const lookback = numbers.length;

        const bigCount = numbers.filter(n => n >= 5).length;
        const smallCount = numbers.length - bigCount;
        const redCount = numbers.filter(n => n % 2 === 0).length; // Assuming Even is Red
        const greenCount = numbers.length - redCount;

        const frequency = {};
        numbers.forEach(n => {
            frequency[n] = (frequency[n] || 0) + 1;
        });

        const mostFrequent = Object.entries(frequency)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .map(([num, count]) => ({
                number: num,
                count
            }));

        const recentPatterns = detectPatterns(numbers.slice(0, 20));

        let html = `
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value">${lookback}</div>
                    <div class="stat-label">Total Results (Lookback)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${bigCount}</div>
                    <div class="stat-label">Big Results</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${smallCount}</div>
                    <div class="stat-label">Small Results</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${(bigCount/lookback*100).toFixed(1)}%</div>
                    <div class="stat-label">Big Frequency</div>
                </div>
            </div>

            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value">${redCount}</div>
                    <div class="stat-label">Red (Even) Results</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${greenCount}</div>
                    <div class="stat-label">Green (Odd) Results</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${(redCount/lookback*100).toFixed(1)}%</div>
                    <div class="stat-label">Red Frequency</div>
                </div>
            </div>

            <div class="analysis-title">
                <i class="fas fa-star"></i> MOST FREQUENT NUMBERS
            </div>
            <div class="pattern-list">
        `;

        mostFrequent.forEach(item => {
            html += `
                <div class="pattern-item">
                    <span class="pattern-value">Number ${item.number}</span>
                    <span class="pattern-confidence">${item.count} times (${(item.count/lookback*100).toFixed(1)}%)</span>
                </div>
            `;
        });

        html += `</div>`;

        if (recentPatterns.length > 0) {
            html += `
                <div class="analysis-title">
                    <i class="fas fa-project-diagram"></i> DETECTED RECENT PATTERNS
                </div>
                <div class="pattern-list">
            `;

            recentPatterns.forEach(pattern => {
                html += `
                    <div class="pattern-item">
                        <span class="pattern-value">${pattern.pattern}</span>
                        <span class="pattern-confidence">${pattern.count} occurrences</span>
                    </div>
                `;
            });

            html += `</div>`;
        }

        const historyData = data.map(item => ({
            number: parseInt(item.number, 10),
            period: item.issueNumber || item.period
        }));
        zenithCoreAI.history = historyData;

        html += `
            <div class="analysis-title">
                <i class="fas fa-chart-line"></i> ZENITH-CORE AI ANALYSIS
            </div>
            <div class="pattern-analysis">
                <div class="pattern-item">
                    <span class="pattern-value">History Size (AI)</span>
                    <span class="pattern-count">${zenithCoreAI.history.length}</span>
                </div>
                <div class="pattern-item">
                    <span class="pattern-value">Active Models</span>
                    <span class="pattern-count">${Object.keys(zenithCoreAI.models).length}</span>
                </div>
                <div class="pattern-item">
                    <span class="pattern-value">Learning Rate</span>
                    <span class="pattern-count">${zenithCoreAI.getLearningRate().toFixed(2)}</span>
                </div>
                <div class="pattern-item">
                    <span class="pattern-value">Strategy</span>
                    <span class="pattern-count">${zenithCoreAI.strategy}</span>
                </div>
                <div class="pattern-item">
                    <span class="pattern-value">Recovery Level (Integrated)</span>
                    <span class="pattern-count">${RECOVERY_LEVEL}</span>
                </div>
            </div>
        `;

        analysisContent.innerHTML = html;
    }

    // Detect patterns in number sequences
    function detectPatterns(numbers) {
        const patterns = [];
        const sequence = numbers.map(n => n >= 5 ? 'B' : 'S').join('');

        for (let len = 2; len <= 4; len++) {
            for (let i = 0; i <= sequence.length - len; i++) {
                const pattern = sequence.substring(i, i + len);
                let count = 0;
                let pos = -1;

                while ((pos = sequence.indexOf(pattern, pos + 1)) !== -1) {
                    count++;
                }

                // Only consider patterns that repeat more than once
                if (count > 1) {
                    patterns.push({
                        pattern: pattern.split('').join('-'),
                        count: count
                    });
                }
            }
        }

        // Filter for unique patterns
        const uniquePatterns = [];
        patterns.forEach(p => {
            const existing = uniquePatterns.find(up => up.pattern === p.pattern);
            if (!existing) {
                uniquePatterns.push(p);
            }
        });

        // Sort by count and return top 5
        return uniquePatterns.sort((a, b) => b.count - a.count).slice(0, 5);
    }

    // Display all strategies
    function displayAllStrategies() {
        const strategiesContainer = document.getElementById('strategiesContainer');
        if (!strategiesContainer) return;

        const strategies = [{
            title: "Zenith-Core Engine",
            icon: "fas fa-robot",
            description: "Advanced ensemble prediction system combining 30+ AI models with dynamic weighting and adaptive learning."
        }, {
            title: "Quantum Entanglement Analysis",
            icon: "fas fa-atom",
            description: "Uses quantum-inspired algorithms to detect non-local correlations in number sequences."
        }, {
            title: "Temporal Fusion Modeling",
            icon: "fas fa-clock",
            description: "Combines short-term, medium-term, and long-term patterns for comprehensive analysis."
        }, {
            title: "Deep Learning Simulation",
            icon: "fas fa-brain",
            description: "Multi-layer neural network simulation with forward propagation and sigmoid activation."
        }, {
            title: "Evolutionary Optimization",
            icon: "fas fa-dna",
            description: "Genetic algorithm that evolves prediction strategies based on historical performance."
        }, {
            title: "Swarm Intelligence",
            icon: "fas fa-users",
            description: "Particle swarm optimization that finds optimal prediction thresholds through collective intelligence."
        }, {
            title: "Loss Recovery Hybrid (Martingale)",
            icon: "fas fa-crosshairs",
            description: "High-confidence strategy to reverse the last prediction after two or more consecutive losses (Integrated 2-Level Recovery)."
        }, {
            title: "Anti-Streak Detection",
            icon: "fas fa-compress-arrows-alt",
            description: "Predicts the opposite of any streak of three or more consecutive results, anticipating a break."
        }];

        let html = '';
        strategies.forEach(strategy => {
            html += `
                <div class="strategy-card">
                    <div class="strategy-title">
                        <i class="${strategy.icon}"></i>
                        ${strategy.title}
                    </div>
                    <div class="strategy-description">
                        ${strategy.description}
                    </div>
                </div>
            `;
        });

        strategiesContainer.innerHTML = html;
    }

    // --- Chat Predictor Logic ---
    let previousResults = [];
    let latestPeriod = null;
    let currentPrediction = null;
    let serverOnline = true;
    let lastPredictionPeriod = null;
    let lastActualNumber = null;

    // DOM elements (assuming these IDs exist in the omitted HTML)
    const messagesContainer = document.getElementById('messages-container');
    const typingIndicator = document.getElementById('typing-indicator');
    const connectionStatus = document.getElementById('connection-status');
    const currentTimeElement = document.getElementById('current-time');
    const lastUpdateTime = document.getElementById('last-update-time');
    const scrollDownBtn = document.getElementById('scroll-down-btn');
    
    // UI elements from the original prompt logic
    const homeBtn = document.getElementById('homeBtn');
    if (homeBtn) homeBtn.addEventListener('click', () => { /* Logic to show home section */ });

    // Initialize
    updateClock();
    setInterval(updateClock, 1000);
    setTimeout(() => {
        if (typingIndicator) typingIndicator.style.display = 'none';
        addMessage('received',
            `<div class="prediction-card">
                <div class="prediction-title"><i class="fas fa-robot"></i> SYSTEM INITIALIZED</div>
                <p>Welcome to <strong>LICUIS ULTRA</strong>. Advanced AI models are analyzing game patterns in real-time to provide you with the most accurate predictions.</p>
            </div>`,
            'LICUIS ULTRA');
        simulateInitialAnalysis();
        
        // Final initialization of original prompt UI logic
        updateHistory();
        updateStats();
        // The original logic's prediction interval is now controlled by the chat logic's polling
        // setInterval(updatePrediction, 5000); 

    }, 1500);

    // Scroll button functionality
    if (scrollDownBtn) {
        scrollDownBtn.addEventListener('click', () => {
            if (messagesContainer) messagesContainer.scrollTop = messagesContainer.scrollHeight;
        });
    }

    if (messagesContainer) {
        messagesContainer.addEventListener('scroll', () => {
            if (!messagesContainer || !scrollDownBtn) return;
            const {
                scrollTop,
                scrollHeight,
                clientHeight
            } = messagesContainer;
            const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
            scrollDownBtn.classList.toggle('visible', distanceFromBottom > 100);
        });
    }

    function updateClock() {
        const now = new Date();
        const timeString = now.toLocaleTimeString('en-US', {
            hour12: false
        });
        if (currentTimeElement) currentTimeElement.textContent = timeString;
        return now;
    }

    function formatTime(date) {
        return date.toLocaleTimeString([], {
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    function addMessage(type, content, sender, timestamp = new Date()) {
        if (typingIndicator) typingIndicator.style.display = 'none';
        if (!messagesContainer) return;

        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;

        if (sender) {
            messageDiv.innerHTML = `<div class="prediction-title">${sender}</div>`;
        }

        messageDiv.innerHTML += content;
        messageDiv.innerHTML += `<div class="timestamp">${formatTime(timestamp)}</div>`;

        messagesContainer.appendChild(messageDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        if (lastUpdateTime) lastUpdateTime.textContent = formatTime(timestamp);

        return messageDiv;
    }

    function showTyping() {
        if (typingIndicator) typingIndicator.style.display = 'flex';
        if (messagesContainer) messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function simulateInitialAnalysis() {
        showTyping();
        setTimeout(() => {
            addMessage('received',
                `<div class="prediction-card">
                    <div class="prediction-title"><i class="fas fa-check-circle"></i> ANALYSIS COMPLETE</div>
                    <p>AI pattern detection complete. Advanced algorithms initialized and ready for predictions.</p>
                </div>`,
                'LICUIS ULTRA');

            fetchCurrentGameIssue();
            setInterval(fetchCurrentGameIssue, 5000); // Poll every 5 seconds
        }, 2000);
    }

    function createPredictionMessage(predictionData) {
        const confidencePercentage = Math.round(parseFloat(predictionData.confidence));
        const confidenceWidth = `${confidencePercentage}%`;

        let color = 'var(--warning-color)';
        if (confidencePercentage >= 90) color = 'var(--success-color)';
        else if (confidencePercentage < 70) color = 'var(--danger-color)';

        return `
            <div class="prediction-card">
                <div class="period-display">${latestPeriod}</div>
                <div class="prediction-value" style="color: ${color};">${predictionData.size}</div>

                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${confidenceWidth}; background-color: ${color}"></div>
                </div>
                <div class="confidence-display">
                    <span>Confidence</span>
                    <span class="confidence-value" style="color: ${color};">${confidencePercentage}%</span>
                </div>
            </div>
        `;
    }

    async function fetchPreviousResults() {
        try {
            const timestamp = Date.now();
            // Fetch more than one to provide sufficient history for the AI core
            const response = await fetch(`https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json?ts=${timestamp}&pageSize=50`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            if (data && data.data && data.data.list && data.data.list.length > 0) {
                // Map the list, ensuring the most recent result is at index 0
                previousResults = data.data.list.map(item => ({
                    number: parseInt(item.premium || item.result || item.number || 0, 10),
                    issueNumber: item.issueNumber || item.period
                }));
            }
        } catch (error) {
            console.error('Error fetching previous results:', error);
        }
    }


    async function fetchCurrentGameIssue() {
        const now = new Date();
        // This is a placeholder/example API for the current period number and countdown
        const apiUrl = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
        const requestData = {
            typeId: 1, // WinGo 1M
            language: 0,
            random: "40079dcba93a48769c6ee9d4d4fae23f",
            signature: "D12108C4F57C549D82B23A91E0FA20AE",
            timestamp: Math.floor(Date.now() / 1000)
        };

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json;charset=UTF-8'
                },
                body: JSON.stringify(requestData)
            });

            if (response.ok) {
                const data = await response.json();
                if (data.code === 0) {
                    updateServerStatus(true);
                    const newPeriod = data.data.issueNumber;

                    if (newPeriod !== latestPeriod) {
                        // 1. Fetch the actual result for the *last* period
                        await fetchPreviousResults();

                        // 2. Process the result of the *last* period
                        if (latestPeriod && zenithCoreAI.lastPrediction && previousResults.length > 0) {
                            // Find the result that matches the *last* period we made a prediction for (latestPeriod)
                            const lastActualItem = previousResults.find(item => item.issueNumber === latestPeriod);
                            
                            if (lastActualItem) {
                                const periodOfResult = lastActualItem.issueNumber;
                                const lastResult = lastActualItem.number;
                                lastActualNumber = parseInt(lastResult, 10);
                                const actualResultSize = getBigSmallOutcome(lastActualNumber);
                                
                                // --- FULL ORIGINAL PROMPT LOGIC INTEGRATION: Update states and UI ---
                                // 1. Update AI Core State and Reinforcement (must happen first)
                                const coreResultStatus = predictorCoordinator.updateReinforcement(actualResultSize, zenithCoreAI.lastPrediction);
                                zenithCoreAI.updateModelPerformance(actualResultSize);

                                // 2. Update local history data for UI (using adapted original logic)
                                const status = updateHistoryStatus(lastActualNumber, coreResultStatus); // Passes the standard status
                                
                                updateHistory();
                                updateStats();
                                // --- END FULL ORIGINAL PROMPT LOGIC INTEGRATION ---


                                const wasCorrect = status === 'WIN'; // Use the status derived from the integrated logic
                                const message = wasCorrect ?
                                    `<div class="prediction-card win" style="border-color: var(--success-color);"><div class="prediction-title"><i class="fas fa-check"></i> ${periodOfResult}</div><p>   ${actualResultSize} (${lastActualNumber})  <strong style="color: var(--success-color);">WIN</strong></p></div>` :
                                    `<div class="prediction-card loss" style="border-color: var(--danger-color);"><div class="prediction-title"><i class="fas fa-times"></i>   ${periodOfResult}</div><p>   ${actualResultSize} (${lastActualNumber})  <strong style="color: var(--danger-color);">LOSS</strong></p></div>`;
                                addMessage('received', message, 'SYSTEM RESULT');
                                
                                // Reset lastPrediction since the period is closed. It will be set again for the new period.
                                zenithCoreAI.lastPrediction = null; 
                            }
                        }

                        // 3. Generate a prediction for the *new* period
                        latestPeriod = newPeriod;
                        updatePredictions(now, newPeriod);
                    }
                } else {
                    updateServerStatus(false);
                }
            } else {
                updateServerStatus(false);
            }
        } catch (error) {
            console.error("Fetch error:", error);
            updateServerStatus(false);
        }
    }


    async function updatePredictions(currentTime, currentPeriod) {
        // Ensure we have up-to-date history
        await fetchPreviousResults();
        zenithCoreAI.history = previousResults.map(item => ({
            number: item.number,
            issueNumber: item.issueNumber, // Ensure both fields are present
            period: item.issueNumber
        }));

        // Only generate a new prediction if the period is new
        if (zenithCoreAI.history.length >= 5 && currentPeriod !== lastPredictionPeriod) {
            
            // Generate the prediction for the CURRENT period using all integrated logic
            const predictionData = await predictorCoordinator.generateDirectPrediction(zenithCoreAI.history, currentPeriod);

            const finalPrediction = predictionData.size;
            const finalConfidence = predictionData.confidence;

            currentPrediction = finalPrediction;
            lastPredictionPeriod = currentPeriod;

            // --- ORIGINAL PROMPT LOGIC ADAPTATION: Add to historyData for UI ---
            const nextPeriod = currentPeriod.slice(-4);
            const globalPrediction = zenithCoreAI.globalPrediction;
            const lastOppositeNumber = zenithCoreAI.lastOppositeNumber;
            
            historyData.unshift({
                period: nextPeriod,
                prediction: globalPrediction,
                oppositeNumber: lastOppositeNumber,
                result: null,
                resultStatus: "Pending",
                resultType: "-",
                calculation: "Prediction",
            });
            
            if (historyData.length > 50) {
                 historyData.pop();
            }
            
            updateHistory();
            updateStats();
            // --- END ORIGINAL PROMPT LOGIC ADAPTATION ---

            showTyping();
            setTimeout(() => {
                addMessage('received', createPredictionMessage({
                    size: finalPrediction,
                    confidence: finalConfidence
                }), 'LICUIS ULTRA');
            }, 1000);
        }
    }


    function updateServerStatus(online) {
        if (serverOnline !== online) {
            serverOnline = online;
            if (online) {
                if (connectionStatus) connectionStatus.textContent = "Connected to Server";
                const indicator = document.querySelector('.status-indicator');
                if (indicator) indicator.className = "status-indicator online";
                addMessage('received', '<div class="prediction-title"><i class="fas fa-plug"></i> CONNECTION RESTORED</div><p>Server connection reestablished. Resuming normal operations.</p>', 'System');
            } else {
                if (connectionStatus) connectionStatus.textContent = "Connecting...";
                const indicator = document.querySelector('.status-indicator');
                if (indicator) indicator.className = "status-indicator offline";
                addMessage('received', '<div class="prediction-title"><i class="fas fa-exclamation-triangle"></i> CONNECTION LOST</div><p>Temporarily lost connection to prediction server. Attempting to reconnect...</p>', 'System');
            }
        }
    }


   // Initialize the application
    createParticles();

    // Animate the game selection title after page load
    setTimeout(() => {
        const title = document.getElementById('gameSelectionTitle');
        if (title) title.classList.add('animate');
    }, 500);
});
</script>
</body>
</html>
