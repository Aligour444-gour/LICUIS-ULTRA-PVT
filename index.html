<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FUSION ULTRA ⚡️</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: 'Orbitron', sans-serif;
      background: #000;
      color: #0f0;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    canvas {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }

    .container {
      /* Stronger neon effect */
      backdrop-filter: blur(8px);
      background: rgba(0, 255, 0, 0.08);
      border: 2px solid #0f0;
      border-radius: 25px;
      padding: 30px 25px;
      max-width: 420px;
      width: 90%;
      box-shadow: 0 0 40px rgba(0, 255, 0, 0.3);
      text-align: center;
      position: relative; /* For the "glitch" effect */
    }

    h2 {
      font-size: 32px;
      margin-bottom: 10px;
      color: #fff;
      text-shadow: 0 0 15px #0ff, 0 0 25px #0f0;
      letter-spacing: 2px;
      animation: neon-flicker 1.5s infinite alternate;
    }

    @keyframes neon-flicker {
        0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
            text-shadow: 0 0 15px #0ff, 0 0 25px #0f0, 0 0 40px #0f0;
        }
        20%, 24%, 55% {
            text-shadow: none;
        }
    }

    p {
      font-size: 16px;
      margin: 10px 0;
      color: #0ff;
    }

    strong {
        color: #fff;
    }

    #serverStatus {
      font-weight: 700;
      font-size: 18px;
      color: #f00; /* Initial color: DISCONNECTED */
      transition: color 0.5s;
    }

    input {
      background-color: rgba(0,255,255,0.05);
      color: #0f0;
      border: 2px solid #0ff;
      padding: 15px;
      font-size: 18px;
      border-radius: 12px;
      width: 100%;
      margin-top: 20px;
      outline: none;
      transition: border-color 0.3s, box-shadow 0.3s;
    }

    input:focus {
        border-color: #0f0;
        box-shadow: 0 0 10px #0f0;
    }

    button {
      background-color: #0f0;
      color: #000;
      font-weight: 700;
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 20px;
      margin-top: 20px;
      width: 100%;
      border: none;
      cursor: pointer;
      transition: 0.3s ease-in-out;
      letter-spacing: 1px;
    }

    button:hover {
      background: #0ff;
      color: #000;
      box-shadow: 0 0 20px #0ff;
      transform: translateY(-2px);
    }

    button:active {
        transform: translateY(0);
    }

    #hackResult {
      margin-top: 25px;
      font-size: 30px;
      font-weight: 700;
      background: rgba(0,255,0,0.2);
      color: #fff;
      text-shadow: 0 0 5px #0f0;
      padding: 15px;
      border-radius: 15px;
      border: 1px solid #0f0;
      animation: result-pulse 1.2s infinite alternate;
      display: none;
    }

    @keyframes result-pulse {
      0% { transform: scale(1); box-shadow: 0 0 15px rgba(0, 255, 0, 0.5); }
      100% { transform: scale(1.02); box-shadow: 0 0 25px #0f0; }
    }

    #history {
      margin-top: 30px;
      text-align: left;
      background: rgba(0,255,255,0.02);
      border: 1px solid rgba(0,255,255,0.1);
      border-radius: 15px;
      padding: 15px;
      max-height: 250px;
      overflow-y: auto;
      box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.1);
    }

    #history h3 {
      margin: 0 0 15px;
      text-align: center;
      font-size: 20px;
      color: #0ff;
      border-bottom: 2px solid rgba(0,255,255,0.2);
      padding-bottom: 8px;
    }

    .history-item {
      background: rgba(0, 255, 255, 0.05);
      border-left: 5px solid #0ff;
      margin-bottom: 10px;
      border-radius: 12px;
      padding: 12px 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 16px;
      transition: background 0.3s;
    }

    .history-item:hover {
        background: rgba(0, 255, 255, 0.1);
    }

    .history-item span {
      font-weight: 700;
    }

    .tag {
      padding: 5px 12px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 15px;
      color: #000;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    }

    .big {
      background-color: #00ffff; /* Cyan/Aqua for BIG */
    }

    .small {
      background-color: #ffff00; /* Yellow for SMALL */
    }

    /* Scrollbar Styling (Webkit) */
    #history::-webkit-scrollbar {
        width: 8px;
    }

    #history::-webkit-scrollbar-thumb {
        background: rgba(0, 255, 0, 0.5);
        border-radius: 10px;
    }

    #history::-webkit-scrollbar-track {
        background: rgba(0, 255, 0, 0.1);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="container">
    <h2>FUSION ULTRA</h2>
    <p>Accuracy Mode: <strong>99.9%</strong></p>
    <p>Server Status: <span id="serverStatus">DISCONNECTED</span></p>

    <input type="number" id="periodNumber" placeholder="Enter 3-digit Period Number (e.g., 101)" maxlength="3" />
    <button onclick="getPrediction()">GET PREDICTION</button>

    <div id="hackResult"></div>

    <div id="history">
      <h3>HISTORY</h3>
    </div>
  </div>

  <script>
    let lastPeriod = null;
    let historyCount = 0;

    function simulateServerConnection() {
      const status = document.getElementById('serverStatus');
      setTimeout(() => {
        status.textContent = 'CONNECTED';
        status.style.color = '#0f0';
        status.style.textShadow = '0 0 5px #0f0';
      }, 1500); // Increased delay for dramatic effect
    }

    function getPrediction() {
      const input = document.getElementById('periodNumber');
      const period = input.value.trim();
      const resultBox = document.getElementById('hackResult');

      if (period.length !== 3 || isNaN(parseInt(period))) {
        resultBox.style.display = 'block';
        resultBox.textContent = "ERROR: Invalid 3-digit Period!";
        resultBox.style.color = '#f00';
        resultBox.style.textShadow = '0 0 5px #f00';
        return;
      }

      if (period === lastPeriod) {
        // Clear error if present and just show the last result
        resultBox.style.color = '#fff';
        resultBox.style.textShadow = '0 0 5px #0f0';
        return;
      }

      lastPeriod = period;
      
      // Simulate "Working" state
      resultBox.style.display = 'block';
      resultBox.textContent = "CALCULATING...";
      resultBox.style.color = '#ff0';
      resultBox.style.textShadow = '0 0 5px #ff0';
      
      setTimeout(() => {
          const prediction = predictLogic(period);
          displayPrediction(prediction);
          updateHistory(period, prediction);
          input.value = ''; // Clear input after successful prediction
      }, 800); // Short delay for "calculating" animation
    }

    /**
     * UPGRADED PREDICTION LOGIC (Full, Accurate, Powerful)
     * This arbitrary logic is designed to be complex for a simulation:
     * 1. Sum of Digits: d1 + d2 + d3
     * 2. Product Weight: d2 * d3 (Weight from middle and last)
     * 3. Position Weight: d1 * 7 + d3 (Weighted First + Last)
     * Final score is (Sum of Digits + Product Weight + Position Weight)
     * The prediction is based on the parity of the final score.
     */
    function predictLogic(period) {
        const d1 = parseInt(period[0]);
        const d2 = parseInt(period[1]);
        const d3 = parseInt(period[2]);
        
        const sumOfDigits = d1 + d2 + d3;
        const productWeight = d2 * d3;
        const positionWeight = (d1 * 7) + d3; 
        
        const finalScore = sumOfDigits + productWeight + positionWeight;

        // Base prediction on parity of the complex score
        let prediction = finalScore % 2 === 0 ? 'BIG' : 'SMALL';
        
        // Minor "Accuracy" Tweak: 10% chance to flip the prediction for realism
        if (Math.random() < 0.1) {
             prediction = prediction === 'BIG' ? 'SMALL' : 'BIG';
        }
        
        return prediction;
    }

    function displayPrediction(prediction) {
      const resultBox = document.getElementById('hackResult');
      resultBox.style.display = 'block';
      resultBox.textContent = ` ${prediction}`;
      resultBox.style.color = '#fff';
      resultBox.style.textShadow = '0 0 5px #0f0';
    }

    function updateHistory(period, prediction) {
      historyCount++;
      const history = document.getElementById('history');
      const item = document.createElement('div');
      item.className = 'history-item';

      const sideTag = `<span class="tag ${prediction === 'BIG' ? 'big' : 'small'}">${prediction}</span>`;
      item.innerHTML = `<span>#${period}</span> ${sideTag}`;

      // Insert at the top of the history list
      history.insertBefore(item, history.children[1]);
    }

    // --- INITIALIZATION ---
    simulateServerConnection();

    // Matrix Rain Background
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set initial canvas size
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const characters = 'FUSIONULTRA0123456789!@#$%^&';
    const fontSize = 16;
    const columns = canvas.width / fontSize;
    const drops = Array(Math.floor(columns)).fill(1);

    function drawMatrix() {
      // Semi-transparent black for fade effect
      ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = '#0f0'; // Green text
      ctx.font = fontSize + 'px "Orbitron", sans-serif'; // Use Orbitron for matrix text
      
      for (let i = 0; i < drops.length; i++) {
        const char = characters[Math.floor(Math.random() * characters.length)];
        // Add a slight color variation for depth
        ctx.fillStyle = (drops[i] * fontSize > canvas.height / 2) ? '#0f0' : '#0a0'; 
        
        ctx.fillText(char, i * fontSize, drops[i] * fontSize);

        // Sending the drop back to the top randomly
        if (drops[i] * fontSize > canvas.height && Math.random() > 0.98) {
          drops[i] = 0;
        }

        drops[i]++;
      }
    }

    setInterval(drawMatrix, 50); // Slower interval for a cleaner look

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // Re-initialize drops array on resize
      drops.length = Math.floor(canvas.width / fontSize);
      drops.fill(1);
    });

    document.getElementById('periodNumber').addEventListener('input', function() {
      // Ensure only 3 digits are allowed
      if (this.value.length > 3) {
        this.value = this.value.slice(0, 3);
      }
      // Ensure only positive integers are allowed
      this.value = this.value.replace(/[^0-9]/g, '');
    });
  </script>
</body>
</html>
