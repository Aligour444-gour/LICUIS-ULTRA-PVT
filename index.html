<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LICUIS ULTRA V2</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=El+Messiri:wght@400;500;600;700&family=Merriweather:ital,wght@0,400;0,700;1,400;1,700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap');

        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --secondary: #3b82f6;
            --accent: #60a5fa;
            --win: #10b981;
            --loss: #ef4444;
            --warning: #f59e0b;
            --bg-light: #0f172a;
            --bg-lighter: #1e293b;
            --bg-medium: #334155;
            --text-dark: #f1f5f9;
            --text-medium: #cbd5e1;
            --text-light: #94a3b8;
            --glass-bg: rgba(30, 41, 59, 0.85);
            --glass-border: rgba(37, 99, 235, 0.25);
            --transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.1);
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 20px 40px rgba(0, 0, 0, 0.4);
            --gradient: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
            --success-gradient: linear-gradient(135deg, var(--win), #059669);
            --danger-gradient: linear-gradient(135deg, var(--loss), #dc2626);
            --radius: 16px;
            --radius-sm: 8px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-light);
            color: var(--text-dark);
            font-family: 'Merriweather', serif;
            padding: 0;
            margin: 0;
            overflow: hidden;
            background-image: radial-gradient(circle at 10% 20%, rgba(37, 99, 235, 0.08) 0%, transparent 25%), radial-gradient(circle at 90% 80%, rgba(59, 130, 246, 0.08) 0%, transparent 25%);
            position: fixed;
            width: 100%;
            height: 100%;
            line-height: 1.6;
        }

        /* Enhanced Logo Styles */
        .logo {
            position: absolute;
            top: 15px;
            left: 20px;
            z-index: 100000000;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: var(--glass-bg);
            border-radius: var(--radius);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
        }

        .logo-icon {
            width: 35px;
            height: 35px;
            background: var(--gradient);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(37, 99, 235, 0.3);
        }

        .logo-icon svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        .logo-text {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 18px;
            background: var(--gradient);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 0.5px;
        }

        /* Enhanced Tab System */
        .tab-system {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 65px;
            background: rgba(15, 23, 42, 0.98);
            display: flex;
            z-index: 99999999;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(37, 99, 235, 0.1);
            padding-left: 100px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .tab {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
            gap: 8px;
        }

        .tab:hover {
            background: rgba(37, 99, 235, 0.1);
        }

        .tab.active {
            background: rgba(37, 99, 235, 0.15);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--gradient);
            border-radius: 2px 2px 0 0;
        }

        .tab-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            background: rgba(37, 99, 235, 0.1);
            transition: var(--transition);
        }

        .tab.active .tab-icon {
            background: var(--gradient);
        }

        .tab-icon i {
            font-size: 14px;
            color: var(--primary);
            transition: var(--transition);
        }

        .tab.active .tab-icon i {
            color: white;
        }

        .tab-label {
            font-family: 'Merriweather', serif;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-medium);
            transition: var(--transition);
        }

        .tab.active .tab-label {
            color: var(--text-dark);
            font-weight: 700;
        }

        .tab:hover .tab-label {
            color: var(--text-dark);
        }

        /* Content Sections */
        .content-section {
            position: fixed;
            top: 65px;
            left: 0;
            width: 100%;
            height: calc(100% - 65px);
            display: none;
            overflow: hidden;
        }

        .content-section.active {
            display: block;
        }

        /* Web Section (Game Selection) */
        #web-section {
            background-color: var(--bg-light);
        }

        /* History Section */
        #history-section {
            background-color: var(--bg-light);
            padding: 20px;
            overflow-y: auto;
        }

        .history-container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--glass-bg);
            border-radius: var(--radius);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        .history-title {
            text-align: center;
            padding: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            color: var(--primary);
            background: rgba(37, 99, 235, 0.05);
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .history-controls {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            background: rgba(37, 99, 235, 0.05);
            border-bottom: 1px solid var(--glass-border);
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .history-filter {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .filter-btn {
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid var(--glass-border);
            color: var(--text-medium);
            padding: 10px 18px;
            border-radius: 30px;
            cursor: pointer;
            transition: var(--transition);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .filter-btn:hover {
            background: rgba(37, 99, 235, 0.1);
            border-color: var(--primary);
            color: var(--text-dark);
        }

        .filter-btn.active {
            background: var(--gradient);
            color: white;
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.2);
            border-color: transparent;
        }

        .history-stats {
            display: flex;
            gap: 15px;
        }

        .stat-badge {
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid var(--glass-border);
            padding: 10px 18px;
            border-radius: 30px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 500;
        }

        .stat-badge.win {
            color: var(--win);
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.2);
        }

        .stat-badge.loss {
            color: var(--loss);
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.2);
        }

        .history-content {
            padding: 0;
        }

        .history-header {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            padding: 18px 20px;
            background: rgba(37, 99, 235, 0.05);
            font-weight: 600;
            border-bottom: 1px solid var(--glass-border);
            color: var(--text-dark);
        }

        .history-item {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            padding: 18px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: var(--transition);
            position: relative;
        }

        .history-item:hover {
            background: rgba(37, 99, 235, 0.03);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .history-value {
            font-size: 16px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dark);
        }

        .history-value-highlight {
            font-size: 18px;
            font-weight: 700;
            color: var(--primary);
        }

        .color-dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .color-red {
            background-color: var(--loss);
        }

        .color-green {
            background-color: var(--win);
        }

        .history-pagination {
            display: flex;
            justify-content: center;
            padding: 20px;
            gap: 10px;
            border-top: 1px solid var(--glass-border);
        }

        .pagination-btn {
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid var(--glass-border);
            color: var(--text-dark);
            cursor: pointer;
            transition: var(--transition);
            font-weight: 600;
        }

        .pagination-btn:hover:not(.disabled) {
            background: rgba(37, 99, 235, 0.1);
            border-color: var(--primary);
            color: var(--primary);
        }

        .pagination-btn.active {
            background: var(--gradient);
            color: white;
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.2);
            border-color: transparent;
        }

        .pagination-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .loading-container,
        .error-container,
        .no-data-container {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-light);
        }

        .loading-container i,
        .error-container i,
        .no-data-container i {
            font-size: 32px;
            margin-bottom: 15px;
            display: block;
            color: var(--primary);
        }

        .error-container {
            color: var(--loss);
        }

        /* Analysis Section */
        #analysis-section {
            overflow-y: auto;
            padding: 20px;
        }

        .analysis-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .analysis-card {
            background: var(--glass-bg);
            border-radius: var(--radius);
            border: 1px solid var(--glass-border);
            padding: 25px;
            margin-bottom: 25px;
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow);
        }

        .analysis-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            color: var(--primary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--glass-border);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .stat-item {
            background: rgba(30, 41, 59, 0.9);
            border-radius: var(--radius);
            padding: 20px;
            text-align: center;
            border: 1px solid var(--glass-border);
            transition: var(--transition);
        }

        .stat-item:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow);
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 14px;
            color: var(--text-light);
            font-weight: 500;
        }

        .pattern-list {
            margin-top: 20px;
        }

        .pattern-item {
            display: flex;
            justify-content: space-between;
            padding: 14px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            align-items: center;
        }

        .pattern-item:last-child {
            border-bottom: none;
        }

        .pattern-value {
            font-weight: 600;
            color: var(--text-dark);
        }

        .pattern-confidence {
            color: var(--primary);
            font-weight: 600;
        }

        /* Strategy Cards */
        .strategy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 25px;
            margin-top: 25px;
        }

        .strategy-card {
            background: rgba(30, 41, 59, 0.9);
            border-radius: var(--radius);
            padding: 20px;
            border-left: 4px solid var(--primary);
            border: 1px solid var(--glass-border);
            transition: var(--transition);
            height: 100%;
        }

        .strategy-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow);
        }

        .strategy-title {
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
        }

        .strategy-description {
            font-family: 'Merriweather', serif;
            font-size: 14px;
            color: var(--text-medium);
            line-height: 1.6;
        }

        /* Game Selection Screen */
        .game-selection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999999;
            animation: fadeIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                backdrop-filter: blur(0);
            }

            to {
                opacity: 1;
                backdrop-filter: blur(10px);
            }
        }

        .game-selection::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 30%, rgba(37, 99, 235, 0.08) 0%, transparent 25%), radial-gradient(circle at 80% 70%, rgba(59, 130, 246, 0.08) 0%, transparent 25%);
            z-index: -1;
            pointer-events: none;
        }

        .game-selection-title {
            font-family: 'El Messiri', sans-serif;
            font-weight: 400;
            font-size: 42px;
            margin: 0 0 50px;
            color: var(--primary);
            letter-spacing: 3px;
            position: relative;
            display: inline-block;
            text-shadow: 0 5px 15px rgba(37, 99, 235, 0.2);
        }

        .game-selection-title::after {
            content: "";
            position: absolute;
            bottom: -15px;
            left: 0;
            width: 100%;
            height: 3px;
            background: var(--gradient);
            transform: scaleX(0);
            transform-origin: right;
            transition: transform 0.8s cubic-bezier(0.19, 1, 0.22, 1);
            border-radius: 3px;
        }

        .game-selection-title.animate::after {
            transform: scaleX(1);
            transform-origin: left;
        }

        .game-list-container {
            width: 100%;
            max-width: 1100px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            padding: 0 20px;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) rgba(0, 0, 0, 0.1);
        }

        .game-list-container::-webkit-scrollbar {
            width: 8px;
        }

        .game-list-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .game-list-container::-webkit-scrollbar-thumb {
            background: var(--gradient);
            border-radius: 4px;
        }

        .game-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
            padding: 0 20px 50px;
        }

        .game-item {
            background: rgba(30, 41, 59, 0.95);
            border: 1px solid rgba(37, 99, 235, 0.15);
            border-radius: var(--radius);
            padding: 25px;
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
            font-family: 'Merriweather', serif;
            color: var(--text-dark);
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
        }

        .game-item:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-lg);
            background: rgba(30, 41, 59, 1);
            border-color: rgba(37, 99, 235, 0.3);
        }

        .game-item::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: var(--gradient);
            opacity: 0;
            transition: opacity 0.4s ease;
            border-radius: 3px 3px 0 0;
        }

        .game-item:hover::before {
            opacity: 1;
            pointer-events: none;
        }

        .game-name {
            font-family: 'El Messiri', sans-serif;
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 12px;
            position: relative;
            z-index: 1;
            transition: var(--transition);
        }

        .game-item:hover .game-name {
            color: var(--primary);
        }

        .game-url {
            font-size: 13px;
            color: var(--text-light);
            word-break: break-all;
            opacity: 0.7;
            transition: var(--transition);
        }

        .game-item:hover .game-url {
            opacity: 1;
        }

        /* Iframe and Tape Button */
        .fullscreen-iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            z-index: 1;
        }

        .hidden {
            display: none;
        }

        /* Enhanced BACK BUTTON DESIGN */
        .injector-tape {
            position: fixed;
            bottom: 25px;
            right: 25px;
            width: 65px;
            height: 65px;
            background: var(--gradient);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 9999999;
            box-shadow: 0 10px 25px rgba(37, 99, 235, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.6);
            transition: var(--transition);
            animation: tapeFloat 4s ease-in-out infinite;
        }

        @keyframes tapeFloat {
            0%,
            100% {
                transform: translateY(0) rotate(0deg);
            }

            50% {
                transform: translateY(-8px) rotate(8deg);
            }
        }

        .injector-tape:hover {
            transform: scale(1.15) rotate(15deg);
            box-shadow: 0 15px 35px rgba(37, 99, 235, 0.4);
            animation: none;
        }

        .injector-tape::before {
            content: "";
            position: absolute;
            width: 22px;
            height: 22px;
            border-left: 3px solid white;
            border-bottom: 3px solid white;
            transform: rotate(45deg);
            margin-top: -3px;
            margin-left: -3px;
        }

        /* Enhanced Floating Particles */
        .particle {
            position: absolute;
            background: rgba(37, 99, 235, 0.25);
            border-radius: 50%;
            pointer-events: none;
            z-index: -1;
            filter: blur(2px);
            animation: float 15s infinite linear;
        }

        @keyframes float {
            0% {
                transform: translateY(0) translateX(0) rotate(0deg);
            }

            25% {
                transform: translateY(-25px) translateX(15px) rotate(8deg);
            }

            50% {
                transform: translateY(0) translateX(25px) rotate(0deg);
            }

            75% {
                transform: translateY(25px) translateX(15px) rotate(-8deg);
            }

            100% {
                transform: translateY(0) translateX(0) rotate(0deg);
            }
        }

        /* Enhanced Chat Predictor Styles */
        .chat-container {
            width: 100%;
            height: 100%;
            margin: 0 auto;
            padding: 0;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-light);
            position: relative;
            overflow: hidden;
        }

        .chat-header {
            background: var(--bg-lighter);
            padding: 20px 15px;
            text-align: center;
            border-bottom: 1px solid rgba(37, 99, 235, 0.1);
            position: relative;
            z-index: 10;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .chat-title {
            font-weight: 800;
            font-size: 1.5rem;
            background: var(--gradient);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin: 0;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
            font-family: 'El Messiri', sans-serif;
            font-weight: 600;
        }

        .chat-subtitle {
            font-size: 0.85rem;
            color: var(--text-light);
            margin: 8px 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background-color: var(--bg-light);
            scroll-behavior: smooth;
            background-image: radial-gradient(circle at 25% 25%, rgba(37, 99, 235, 0.05) 0%, transparent 50%), radial-gradient(circle at 75% 75%, rgba(59, 130, 246, 0.05) 0%, transparent 50%);
        }

        .message {
            margin-bottom: 20px;
            padding: 16px 20px;
            border-radius: 18px;
            max-width: 85%;
            word-wrap: break-word;
            position: relative;
            animation: fadeIn 0.3s ease;
            font-family: 'Merriweather', serif;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .received {
            background-color: var(--bg-lighter);
            border-bottom-left-radius: 8px;
            margin-right: auto;
            border: 1px solid rgba(37, 99, 235, 0.15);
            color: var(--text-dark);
        }

        .sent {
            background: var(--gradient);
            color: white;
            border-bottom-right-radius: 8px;
            margin-left: auto;
        }

        .timestamp {
            font-size: 0.7rem;
            color: var(--text-light);
            margin-top: 10px;
            text-align: right;
            opacity: 0.8;
            pointer-events: none;
        }

        .emoji {
            font-size: 1.3em;
            margin-right: 6px;
            display: inline-block;
        }

        .prediction-card {
            background-color: rgba(37, 99, 235, 0.1);
            border-radius: var(--radius);
            padding: 18px;
            margin: 15px 0;
            border: 1px solid rgba(37, 99, 235, 0.2);
        }

        .prediction-title {
            font-family: 'Merriweather', serif;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .prediction-title i {
            font-size: 1.2rem;
            display: inline-block;
        }

        .prediction-value {
            font-family: 'El Messiri', sans-serif;
            font-size: 2.5rem;
            font-weight: 800;
            margin: 15px 0;
            text-align: center;
            letter-spacing: 1px;
            color: var(--primary);
            text-transform: uppercase;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .online {
            background-color: var(--win);
        }

        .offline {
            background-color: var(--loss);
        }

        .typing-indicator {
            display: flex;
            padding: 14px 18px;
            background-color: var(--bg-lighter);
            border-radius: 22px;
            width: fit-content;
            margin-bottom: 20px;
            border-bottom-left-radius: 8px;
            align-items: center;
            gap: 10px;
            border: 1px solid rgba(37, 99, 235, 0.15);
        }

        .typing-text {
            font-size: 0.9rem;
            color: var(--text-light);
            font-family: 'Merriweather', serif;
        }

        .typing-dot {
            width: 10px;
            height: 10px;
            background-color: var(--text-light);
            border-radius: 50%;
            animation: typingAnimation 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) {
            animation-delay: 0s;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typingAnimation {
            0%,
            60%,
            100% {
                transform: translateY(0);
                opacity: 0.6;
            }

            30% {
                transform: translateY(-6px);
                opacity: 1;
            }
        }

        .scroll-down-btn {
            position: fixed;
            bottom: 100px;
            right: 25px;
            background: var(--gradient);
            color: white;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(37, 99, 235, 0.25);
            z-index: 100;
            opacity: 0;
            transition: all 0.3s ease;
            border: none;
            outline: none;
        }

        .scroll-down-btn.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .scroll-down-btn:not(.visible) {
            transform: translateY(15px);
        }

        .scroll-down-btn:hover {
            transform: translateY(-3px) scale(1.08);
            box-shadow: 0 10px 25px rgba(37, 99, 235, 0.35);
        }

        .progress-bar {
            height: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin: 12px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            border-radius: 4px;
            background: var(--gradient);
            transition: width 0.5s ease;
        }

        .floating-bg {
            position: absolute;
            width: 350px;
            height: 350px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(37, 99, 235, 0.08) 0%, transparent 70%);
            z-index: 0;
            pointer-events: none;
        }

        .bg-1 {
            top: -120px;
            left: -120px;
        }

        .bg-2 {
            bottom: -80px;
            right: -120px;
        }

        .period-display {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary);
            text-align: center;
            margin: 12px 0;
            letter-spacing: 1px;
        }

        .confidence-display {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.8rem;
            color: var(--text-light);
            align-items: center;
        }

        .confidence-value {
            color: var(--primary);
            font-weight: 700;
        }

        /* Responsive Adjustments */
        @media (max-width: 1024px) {
            .game-list {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            }

            .strategy-grid {
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .logo {
                left: 15px;
                top: 12px;
            }

            .logo-text {
                display: none;
            }

            .tab-system {
                padding-left: 70px;
                height: 60px;
            }

            .content-section {
                top: 60px;
                height: calc(100% - 60px);
            }

            .game-list {
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }

            .game-selection-title {
                font-size: 32px;
                margin-bottom: 40px;
            }

            .injector-tape {
                width: 55px;
                height: 55px;
                bottom: 20px;
                right: 20px;
            }

            .tab-label {
                font-size: 12px;
            }

            .tab-icon {
                width: 22px;
                height: 22px;
            }

            .tab-icon i {
                font-size: 12px;
            }

            .prediction-value {
                font-size: 2rem;
            }

            .history-header,
            .history-item {
                grid-template-columns: 1fr 1fr 1fr;
                padding: 15px;
            }

            .history-value {
                font-size: 14px;
            }

            .history-value-highlight {
                font-size: 16px;
            }

            .strategy-grid {
                grid-template-columns: 1fr;
            }

            .history-controls {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }

            .stats-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 480px) {
            .game-list {
                grid-template-columns: 1fr;
            }

            .game-selection-title {
                font-size: 28px;
                margin-bottom: 30px;
            }

            .injector-tape {
                width: 50px;
                height: 50px;
            }

            .tab-label {
                display: none;
            }

            .tab-icon {
                margin-right: 0;
                width: 26px;
                height: 26px;
            }

            .prediction-value {
                font-size: 1.8rem;
            }

            .history-header,
            .history-item {
                grid-template-columns: 1fr 1fr;
                padding: 12px 10px;
            }

            .history-header-item:nth-child(3),
            .history-item>div:nth-child(3) {
                display: none;
            }

            .history-value {
                font-size: 13px;
            }

            .history-value-highlight {
                font-size: 15px;
            }

            .history-stats {
                flex-wrap: wrap;
                justify-content: center;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .analysis-card {
                padding: 20px;
            }

            .strategy-card {
                padding: 18px;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>

<body>
    <div class="logo">
        <div class="logo-icon">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M21 16.5c0 .83-.67 1.5-1.5 1.5H4.5c-.83 0-1.5-.67-1.5-1.5v-9c0-.83.67-1.5 1.5-1.5h15c.83 0 1.5.67 1.5 1.5v9zM4.5 20h15c.83 0 1.5-.67 1.5-1.5v-9c0-.83-.67-1.5-1.5-1.5h-15c-.83 0-1.5.67-1.5 1.5v9c0 .83.67 1.5 1.5 1.5zm2.5-6h2v2H7v-2zm4 0h2v2h-2v-2zm-4 4h2v2H7v-2zm4 0h2v2h-2v-2zm4-4h2v2h-2v-2zm-8-4h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2z" />
            </svg>
        </div>
        <div class="logo-text">LICUIS ULTRA V2</div>
    </div>

    <div class="tab-system">
        <div class="tab active" data-tab="web" role="tab" aria-controls="web-section" aria-selected="true">
            <div class="tab-icon"><i class="fas fa-gamepad"></i></div>
            <div class="tab-label">Games</div>
        </div>
        <div class="tab" data-tab="predictor" role="tab" aria-controls="predictor-section" aria-selected="false">
            <div class="tab-icon"><i class="fas fa-brain"></i></div>
            <div class="tab-label">Predictor</div>
        </div>
        <div class="tab" data-tab="history" role="tab" aria-controls="history-section" aria-selected="false">
            <div class="tab-icon"><i class="fas fa-history"></i></div>
            <div class="tab-label">History</div>
        </div>
        <div class="tab" data-tab="analysis" role="tab" aria-controls="analysis-section" aria-selected="false">
            <div class="tab-icon"><i class="fas fa-chart-line"></i></div>
            <div class="tab-label">Analysis</div>
        </div>
    </div>

    <div class="content-section active" id="web-section" role="tabpanel" aria-labelledby="web-tab">
        <div class="game-selection" id="gameSelection">
            <h1 class="game-selection-title" id="gameSelectionTitle">SELECT GAME</h1>
            <div class="game-list-container">
                <div class="game-list">
                    <div class="game-item" data-url="https://bdginf.com/#/login" role="button" tabindex="0">
                        <div class="game-name">BIG DADDY</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="http://Okwin.bio" role="button" tabindex="0">
                        <div class="game-name">OK WIN</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://goagamea.com/#/login" role="button" tabindex="0">
                        <div class="game-name">GOA GAME</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://www.bigmumbaiq.com/#/login" role="button" tabindex="0">
                        <div class="game-name">BIG MUMBAI</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="http://tirangagame.top" role="button" tabindex="0">
                        <div class="game-name">TIRANGA</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://51game5.com/#/" role="button" tabindex="0">
                        <div class="game-name">51 GAME</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://bdgwin.cc/#/login" role="button" tabindex="0">
                        <div class="game-name">BDG WIN</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="http://rajawager.com" role="button" tabindex="0">
                        <div class="game-name">RAJA WAGER</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="http://55club.game" role="button" tabindex="0">
                        <div class="game-name">55 CLUB</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://bharatclub.net/#/login" role="button" tabindex="0">
                        <div class="game-name">BHARAT CLUB</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://www.diuwin8.com/#/" role="button" tabindex="0">
                        <div class="game-name">DIUWIN</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://www.aatclub.com/#/" role="button" tabindex="0">
                        <div class="game-name">91 CLUB</div>
                        <div class="game-url"></div>
                    </div>
                </div>
            </div>
        </div>

        <iframe id="gameFrame" class="fullscreen-iframe hidden" allowfullscreen aria-label="Game Window"></iframe>

        <button class="injector-tape hidden" id="injectorTape" aria-label="Go Back to Game Selection"></button>
    </div>

    <div class="content-section" id="predictor-section" role="tabpanel" aria-labelledby="predictor-tab">
        <div class="chat-container">
            <div class="floating-bg bg-1"></div>
            <div class="floating-bg bg-2"></div>

            <div class="chat-header">
                <h1 class="chat-title">LICUIS ULTRA</h1>
                <p class="chat-subtitle">
                    <span class="status-indicator online"></span>
                    <span id="connection-status">Connected to Server</span>
                    • <span id="current-time">00:00:00</span>
                    • <span id="prediction-speed">0ms</span>
                </p>
            </div>

            <div class="messages-container" id="messages-container">
                <div class="message received">
                    <div class="prediction-title"><i class="fas fa-robot"></i> SYSTEM INITIALIZED</div>
                    <p>Welcome to <strong>LICUIS ULTRA V2</strong>, now powered by the Advanced AI models are analyzing game patterns in real-time to provide you with the most accurate predictions.</p>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 100%"></div>
                    </div>
                    <div class="timestamp" id="last-update-time">Just now</div>
                </div>

                <div class="typing-indicator" id="typing-indicator">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <span class="typing-text">Initializing AI models...</span>
                </div>
            </div>

            <button class="scroll-down-btn" id="scroll-down-btn" aria-label="Scroll to bottom">
                <i class="fas fa-chevron-down"></i>
            </button>
        </div>
    </div>

    <div class="content-section" id="history-section" role="tabpanel" aria-labelledby="history-tab">
        <div class="history-container">
            <div class="history-title">
                <i class="fas fa-history"></i> GAME HISTORY
            </div>
            <div class="history-controls">
                <div class="history-filter">
                    <button class="filter-btn active" data-filter="all"><i class="fas fa-layer-group"></i> All</button>
                    <button class="filter-btn" data-filter="big"><i class="fas fa-arrow-up"></i> Big</button>
                    <button class="filter-btn" data-filter="small"><i class="fas fa-arrow-down"></i> Small</button>
                    <button class="filter-btn" data-filter="red"><i class="fas fa-circle" style="color: #ef4444;"></i> Red</button>
                    <button class="filter-btn" data-filter="green"><i class="fas fa-circle" style="color: #10b981;"></i> Green</button>
                </div>
                <div class="history-stats">
                    <div class="stat-badge"><i class="fas fa-database"></i> <span id="total-count">0</span></div>
                </div>
            </div>
            <div class="history-content" id="historyContent">
                <div class="loading-container">
                    <i class="fas fa-spinner fa-spin"></i>
                    <div>LOADING DATA...</div>
                </div>
            </div>
            <div class="history-pagination" id="historyPagination">
                <button class="pagination-btn disabled" id="prevPage" aria-label="Previous Page"><i class="fas fa-chevron-left"></i></button>
                <button class="pagination-btn active">1</button>
                <button class="pagination-btn">2</button>
                <button class="pagination-btn">3</button>
                <button class="pagination-btn" id="nextPage" aria-label="Next Page"><i class="fas fa-chevron-right"></i></button>
            </div>
        </div>
    </div>

    <div class="content-section" id="analysis-section" role="tabpanel" aria-labelledby="analysis-tab">
        <div class="analysis-container">
            <div class="analysis-card">
                <div class="analysis-title">
                    <i class="fas fa-chart-pie"></i> ADVANCED ANALYSIS
                </div>
                <div id="advancedAnalysis">
                    <div class="loading-container">
                        <i class="fas fa-spinner fa-spin"></i>
                        <div>ANALYZING DATA PATTERNS...</div>
                    </div>
                </div>
            </div>

            <div class="analysis-card">
                <div class="analysis-title">
                    <i class="fas fa-brain"></i> ACTIVE STRATEGIES
                </div>
                <div class="strategy-grid" id="strategiesContainer">
                </div>
            </div>
        </div>
    </div>

    <script>
// 🔮 LICUIS ULTRA V2: INFINITY-CORE PREDICTION ENGINE 10.0 (Enhanced & Accurate)
// MODIFIED: ALWAYS SHOW OPPOSITE PREDICTION & OPPOSITE OUTCOME WITH HIGH CONFIDENCE

"use strict";

/**
 * The main class for the Infinity-Core AI prediction engine.
 * Modified to always return opposite predictions and outcomes with high confidence.
 */
class InfinityCoreAI {
    constructor() {
        this.history = [];
        this.modelWeights = {
            quantumEntanglement: 10,
            temporalFusion: 9.5,
            gan: 9.0,
            neuralNet: 8.5,
            patternRec: 7.0,
            aiFusion: 6.5,
            markov: 6.0,
            svm: 5.5,
            frequency: 5.0,
            sequence: 4.5,
            momentum: 4.0,
            zigzag: 3.5,
            fibonacci: 3.0,
            parabolicSAR: 2.5,
            kmeans: 2.0,
            probabilistic: 1.5,
            rsi: 1.0,
            martingale: 0.5,
            antiMartingale: 0.5,
            localCluster: 8.0,
            trendStrength: 7.5,
            cycleDetection: 9.0,
            patternMatrix: 9.5,
            anomalyDetection: 10.0,
            lstmSim: 10.5,
            bayesian: 9.8,
            reinforcement: 10.2,
            deepLearning: 11.0,
            transformer: 10.8,
            attentionNetwork: 11.2,
            evolutionary: 9.7,
            swarmIntelligence: 10.3,
            geneticAlgorithm: 10.5,
            bayesianNetwork: 11.0,
        };

        this.modelPerformance = {};
        this.predictionCache = new Map();
        this.consecutiveWins = 0;
        this.consecutiveLosses = 0;
        this.lastPrediction = null;
        this.lastActual = null;
        this.initializeModels();
        this.aggressiveness = 10;
        this.strategy = 'balanced';
        this.deepLearningEnabled = true;
        this.adaptiveModelsEnabled = true;
        this.learningRate = 0.87;
        this.minHistoryRequired = 5;
    }

    initializeModels() {
        this.models = {
            momentum: this.MomentumModel(),
            zigzag: this.ZigZagModel(),
            frequency: this.FrequencyModel(),
            sequence: this.SequencePatternModel(),
            aiFusion: this.AIFusionModel(),
            markov: this.MarkovChainModel(),
            fibonacci: this.FibonacciModel(),
            martingale: this.MartingaleModel(),
            antiMartingale: this.AntiMartingaleModel(),
            parabolicSAR: this.ParabolicSARModel(),
            svm: this.SVMModel(),
            kmeans: this.KMeansModel(),
            patternRec: this.PatternRecognitionModel(),
            neuralNet: this.SimpleNeuralNetModel(),
            probabilistic: this.ProbabilisticModel(),
            rsi: this.RSIModel(),
            quantumEntanglement: this.QuantumEntanglementModel(),
            gan: this.GANModel(),
            temporalFusion: this.TemporalFusionModel(),
            localCluster: this.LocalClusterModel(),
            trendStrength: this.TrendStrengthModel(),
            cycleDetection: this.CycleDetectionModel(),
            patternMatrix: this.PatternMatrixModel(),
            anomalyDetection: this.AnomalyDetectionModel(),
            lstmSim: this.LSTMSimModel(),
            bayesian: this.BayesianModel(),
            reinforcement: this.ReinforcementModel(),
            deepLearning: this.DeepLearningModel(),
            transformer: this.TransformerModel(),
            attentionNetwork: this.AttentionNetworkModel(),
            evolutionary: this.EvolutionaryModel(),
            swarmIntelligence: this.SwarmIntelligenceModel(),
            geneticAlgorithm: this.GeneticAlgorithmModel(),
            bayesianNetwork: this.BayesianNetworkModel(),
        };

        for (const modelName in this.models) {
            this.modelPerformance[modelName] = {
                correct: 0,
                total: 0,
                accuracy: 0,
                weight: this.modelWeights[modelName] || 5.0
            };
        }
    }

    updateDynamicWeights() {
        const totalAccuracy = Object.values(this.modelPerformance).reduce((sum, p) => sum + p.accuracy, 0);
        if (totalAccuracy === 0) return;

        for (const modelName in this.modelWeights) {
            const performance = this.modelPerformance[modelName];
            if (performance.total > 0) {
                const normalizedAccuracy = performance.accuracy / totalAccuracy;
                const baseWeight = Math.pow(normalizedAccuracy * 10, this.aggressiveness / 5);

                let strategyMultiplier = 1.0;
                switch (this.strategy) {
                    case 'conservative':
                        strategyMultiplier = 0.8;
                        break;
                    case 'aggressive':
                        strategyMultiplier = 1.2;
                        break;
                    case 'trendFollowing':
                        if (modelName.includes('trend') || modelName.includes('momentum')) {
                            strategyMultiplier = 1.5;
                        }
                        break;
                    case 'patternRecognition':
                        if (modelName.includes('pattern') || modelName.includes('sequence')) {
                            strategyMultiplier = 1.5;
                        }
                        break;
                    case 'quantum':
                        if (modelName.includes('quantum')) {
                            strategyMultiplier = 2.0;
                        }
                        break;
                }

                this.modelWeights[modelName] = Math.max(0.5, baseWeight * strategyMultiplier);

                if (this.adaptiveModelsEnabled) {
                    const adaptation = performance.accuracy > 0.7 ? 1.2 : 0.8;
                    this.modelWeights[modelName] *= adaptation;
                }
            }
        }
    }

    updateModelPerformance(actualSize) {
        for (const modelName in this.models) {
            const prediction = this.models[modelName].predict(this.history);
            if (prediction.size === actualSize) {
                this.modelPerformance[modelName].correct++;
            }
            this.modelPerformance[modelName].total++;
            this.modelPerformance[modelName].accuracy =
                this.modelPerformance[modelName].correct / this.modelPerformance[modelName].total;

            if (this.deepLearningEnabled) {
                this.learningRate = 0.7 + (this.modelPerformance[modelName].accuracy * 0.3);
            }
        }
        this.updateDynamicWeights();
        this.predictionCache.clear();
    }

    // --- Enhanced AI Models with Accurate Logic ---

    MomentumModel() {
        const HISTORY_SIZE = 5;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: "BIG", confidence: 0.5 };
                const last = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 'BIG' : 'SMALL');
                const bigs = last.filter(x => x === "BIG").length;
                const smalls = HISTORY_SIZE - bigs;
                if (bigs >= 4) return { size: "BIG", confidence: 0.95 };
                if (smalls >= 4) return { size: "SMALL", confidence: 0.95 };
                if (bigs > smalls) return { size: "BIG", confidence: 0.8 };
                if (smalls > bigs) return { size: "SMALL", confidence: 0.8 };
                return { size: last[0], confidence: 0.6 };
            }
        };
    }

    ZigZagModel() {
        const HISTORY_SIZE = 4;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const last = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 'BIG' : 'SMALL');
                const isZigzag = last.every((v, i, arr) => i === 0 || v !== arr[i - 1]);
                if (isZigzag) return { size: last[0] === "BIG" ? "SMALL" : "BIG", confidence: 0.9 };
                const patternBreak = last[0] === last[1] && last[1] !== last[2];
                if (patternBreak) return { size: last[2], confidence: 0.85 };
                return { size: last[0], confidence: 0.6 };
            }
        };
    }

    FrequencyModel() {
        const HISTORY_SIZE = 20;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const last20 = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 'BIG' : 'SMALL');
                const bigs = last20.filter(x => x === "BIG").length;
                const smalls = last20.length - bigs;
                if (bigs > smalls * 1.8) return { size: "SMALL", confidence: 0.9 };
                if (smalls > bigs * 1.8) return { size: "BIG", confidence: 0.9 };
                if (bigs > smalls) return { size: "BIG", confidence: bigs / 20 };
                if (smalls > bigs) return { size: "SMALL", confidence: smalls / 20 };
                return { size: last20[0], confidence: 0.5 };
            }
        };
    }

    SequencePatternModel() {
        const HISTORY_SIZE = 10;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const last = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 'BIG' : 'SMALL').join('');
                const patterns = {
                    'BIGBIGBIG': 'SMALL',
                    'SMALLSMALLSMALL': 'BIG',
                    'BIGBIGSMALL': 'SMALL',
                    'SMALLSMALLBIG': 'BIG',
                    'BIGSMALLBIG': 'SMALL',
                    'SMALLBIGSMALL': 'BIG'
                };
                for (const pattern in patterns) {
                    if (last.startsWith(pattern)) {
                        return { size: patterns[pattern], confidence: 0.95 };
                    }
                }
                if (/^(BIGSMALL){2,}BIG$/.test(last)) return { size: "SMALL", confidence: 0.9 };
                if (/^(SMALLBIG){2,}SMALL$/.test(last)) return { size: "BIG", confidence: 0.9 };
                return { size: last[0], confidence: 0.6 };
            }
        };
    }

    AIFusionModel() {
        const HISTORY_SIZE = 10;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const last10 = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 1 : -1);
                let bias = 0;
                last10.forEach((val, i) => {
                    bias += val * (10 - i);
                });
                if (bias > 20) return { size: "BIG", confidence: Math.min(0.99, 0.5 + (bias / 50)) };
                if (bias < -20) return { size: "SMALL", confidence: Math.min(0.99, 0.5 + (Math.abs(bias) / 50)) };
                if (bias > 0) return { size: "BIG", confidence: 0.5 + (bias / 30) };
                if (bias < 0) return { size: "SMALL", confidence: 0.5 + (Math.abs(bias) / 30) };
                return { size: last10[0] > 0 ? 'BIG' : 'SMALL', confidence: 0.6 };
            }
        };
    }

    MarkovChainModel() {
        const HISTORY_SIZE = 50;
        const MIN_HISTORY = 10;
        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.5 };
                const historySlice = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 'BIG' : 'SMALL');
                const last = historySlice[0];
                const transitions = {};
                for (let i = 1; i < historySlice.length; i++) {
                    const from = historySlice[i];
                    const to = historySlice[i - 1];
                    if (!transitions[from]) transitions[from] = { BIG: 0, SMALL: 0 };
                    transitions[from][to]++;
                }
                if (!transitions[last]) return { size: 'BIG', confidence: 0.5 };
                const bigProb = transitions[last].BIG / (transitions[last].BIG + transitions[last].SMALL);
                const smallProb = transitions[last].SMALL / (transitions[last].BIG + transitions[last].SMALL);
                if (bigProb > smallProb + 0.2) return { size: 'BIG', confidence: Math.min(0.98, bigProb) };
                if (smallProb > bigProb + 0.2) return { size: 'SMALL', confidence: Math.min(0.98, smallProb) };
                return { size: last === 'BIG' ? 'SMALL' : 'BIG', confidence: 0.65 };
            }
        };
    }

    FibonacciModel() {
        const HISTORY_SIZE = 5;
        const fibSequence = [1, 2, 3, 5, 8];
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const results = [];
                for (let i = 0; i < Math.min(HISTORY_SIZE, history.length); i++) {
                    const idx = fibSequence[i] - 1;
                    if (idx < history.length) {
                        results.push(history[idx].number > 4 ? 'BIG' : 'SMALL');
                    }
                }
                const bigs = results.filter(x => x === "BIG").length;
                const smalls = results.length - bigs;
                if (bigs > smalls) return { size: "BIG", confidence: 0.8 + (bigs / results.length) * 0.15 };
                if (smalls > bigs) return { size: "SMALL", confidence: 0.8 + (smalls / results.length) * 0.15 };
                return { size: results[0], confidence: 0.5 };
            }
        };
    }

    MartingaleModel() {
        const HISTORY_SIZE = 3;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const last = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 'BIG' : 'SMALL');
                const consecutiveSame = last[0] === last[1] && last[1] === last[2];
                if (consecutiveSame) return { size: last[0] === 'BIG' ? 'SMALL' : 'BIG', confidence: 0.95 };
                return { size: last[0], confidence: 0.5 };
            }
        };
    }

    AntiMartingaleModel() {
        const HISTORY_SIZE = 3;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const last = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 'BIG' : 'SMALL');
                const isAlternating = last[0] !== last[1] && last[1] !== last[2];
                if (isAlternating) return { size: last[0], confidence: 0.9 };
                return { size: last[0] === 'BIG' ? 'SMALL' : 'BIG', confidence: 0.5 };
            }
        };
    }

    ParabolicSARModel() {
        const HISTORY_SIZE = 20;
        const MIN_HISTORY = 10;
        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.5 };
                const historySlice = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 1 : 0);
                let trend = 0;
                let af = 0.02;
                let ep = historySlice[0];
                let sar = historySlice[0];

                for (let i = 1; i < historySlice.length; i++) {
                    if (trend === 1) {
                        sar = sar + af * (ep - sar);
                        if (historySlice[i] > ep) {
                            ep = historySlice[i];
                            af = Math.min(af + 0.02, 0.2);
                        }
                        if (historySlice[i] < sar) {
                            trend = -1;
                            sar = ep;
                            af = 0.02;
                            ep = historySlice[i];
                        }
                    } else {
                        sar = sar + af * (ep - sar);
                        if (historySlice[i] < ep) {
                            ep = historySlice[i];
                            af = Math.min(af + 0.02, 0.2);
                        }
                        if (historySlice[i] > sar) {
                            trend = 1;
                            sar = ep;
                            af = 0.02;
                            ep = historySlice[i];
                        }
                    }
                }
                return { size: trend === 1 ? 'BIG' : 'SMALL', confidence: 0.8 };
            }
        };
    }

    SVMModel() {
        const HISTORY_SIZE = 10;
        const MIN_HISTORY = 15;
        const WEIGHTS = [0.3, 0.25, 0.2, 0.15, 0.1, 0.08, 0.06, 0.04, 0.02, 0.01];
        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.5 };
                const features = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 1 : -1);
                let sum = features.reduce((acc, curr, i) => acc + curr * (WEIGHTS[i] || 0), 0);
                return { size: sum > 0 ? 'BIG' : 'SMALL', confidence: Math.min(0.95, 0.5 + Math.abs(sum) * 0.5) };
            }
        };
    }

    KMeansModel() {
        const HISTORY_SIZE = 20;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const numbers = history.slice(0, HISTORY_SIZE).map(h => h.number);
                const avg = numbers.reduce((a, b) => a + b, 0) / numbers.length;
                const cluster1 = numbers.filter(n => n <= avg);
                const cluster2 = numbers.filter(n => n > avg);
                if (cluster1.length > cluster2.length * 1.5) {
                    return { size: 'BIG', confidence: 0.8 };
                } else if (cluster2.length > cluster1.length * 1.5) {
                    return { size: 'SMALL', confidence: 0.8 };
                }
                return { size: avg > 4.5 ? 'BIG' : 'SMALL', confidence: 0.7 };
            }
        };
    }

    PatternRecognitionModel() {
        const HISTORY_SIZE = 8;
        const patterns = {
            'BBBS': 'BIG', 'SSSB': 'SMALL', 'BBSB': 'SMALL', 'SSBS': 'BIG', 'BSBS': 'BIG', 'SBSB': 'SMALL',
            'BSSB': 'BIG', 'SBBS': 'SMALL', 'BBBBS': 'BIG', 'SSSSB': 'SMALL', 'BBSBB': 'SMALL', 'SSBSS': 'BIG',
            'BBSBS': 'BIG', 'SSBSB': 'SMALL', 'BSBBS': 'SMALL', 'SBSSB': 'BIG', 'BBSSB': 'BIG', 'SSBBS': 'SMALL',
            'BSSSB': 'SMALL', 'BSBSB': 'BIG', 'SBSBS': 'SMALL', 'BSSBS': 'BIG', 'SBSBB': 'SMALL', 'BBBBBS': 'BIG',
            'SSSSSB': 'SMALL', 'BBBSSS': 'BIG', 'SSSBBB': 'SMALL', 'BBSBBS': 'SMALL', 'SSBSSB': 'BIG',
            'BSSBSB': 'BIG', 'SBSSBS': 'SMALL', 'BSBSSB': 'SMALL', 'SBSBSS': 'SMALL'
        };
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const last8 = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 'B' : 'S').join('');
                for (const pattern in patterns) {
                    if (last8.includes(pattern)) {
                        return { size: patterns[pattern] === 'B' ? 'BIG' : 'SMALL', confidence: 0.9 };
                    }
                }
                return { size: last8[0] === 'B' ? 'BIG' : 'SMALL', confidence: 0.6 };
            }
        };
    }

    SimpleNeuralNetModel() {
        const HISTORY_SIZE = 5;
        const MIN_HISTORY = 10;
        const WEIGHTS = [0.4, 0.3, 0.2, 0.08, 0.02];
        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.5 };
                const inputs = history.slice(0, HISTORY_SIZE).map(h => h.number / 10);
                const hidden = inputs.reduce((sum, input, i) => sum + input * (WEIGHTS[i] || 0), 0);
                const output = 1 / (1 + Math.exp(-hidden));
                return { size: output > 0.5 ? 'BIG' : 'SMALL', confidence: Math.abs(output - 0.5) * 2 };
            }
        };
    }

    ProbabilisticModel() {
        return {
            predict: (history) => {
                if (history.length === 0) return { size: 'BIG', confidence: 0.5 };
                const bigs = history.filter(h => h.number > 4).length;
                const total = history.length;
                const bigProb = bigs / total;
                const smallProb = (total - bigs) / total;
                const recent = history.slice(0, 10);
                const recentBigs = recent.filter(h => h.number > 4).length;
                const recentRatio = recentBigs / recent.length;
                const adjustedBigProb = (bigProb * 0.7) + (recentRatio * 0.3);
                const adjustedSmallProb = (smallProb * 0.7) + ((1 - recentRatio) * 0.3);
                return { size: adjustedBigProb > adjustedSmallProb ? 'BIG' : 'SMALL', confidence: Math.max(adjustedBigProb, adjustedSmallProb) };
            }
        };
    }

    RSIModel() {
        const HISTORY_SIZE = 14;
        const MIN_HISTORY = 14;
        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.5 };
                const changes = history.slice(0, HISTORY_SIZE).map((h, i) => i > 0 ? h.number - history[i - 1].number : 0);
                const gains = changes.filter(c => c > 0).reduce((a, b) => a + b, 0);
                const losses = Math.abs(changes.filter(c => c < 0).reduce((a, b) => a + b, 0));
                if (losses === 0) return { size: 'SMALL', confidence: 0.95 };
                const rs = gains / losses;
                const rsi = 100 - (100 / (1 + rs));
                if (rsi > 70) return { size: 'SMALL', confidence: 0.9 };
                if (rsi < 30) return { size: 'BIG', confidence: 0.9 };
                return { size: history[0].number > 4 ? 'BIG' : 'SMALL', confidence: 0.6 };
            }
        };
    }

    QuantumEntanglementModel() {
        const MIN_HISTORY = 2;
        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.98 };
                const last = history[0].number;
                const prev = history[1].number;
                const entanglement = (last * prev) % 10;
                const probability = (entanglement / 10) * 0.9 + 0.5;
                return { size: probability > 0.5 ? 'BIG' : 'SMALL', confidence: Math.abs(probability - 0.5) * 2 };
            }
        };
    }

    GANModel() {
        const HISTORY_SIZE = 10;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.95 };
                const pattern = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 1 : 0);
                const ones = pattern.filter(x => x === 1).length;
                const realPatternScore = 0.7;
                const generatedPatternScore = ones / pattern.length;
                const confidence = Math.abs(realPatternScore - generatedPatternScore) * 2;
                return { size: generatedPatternScore > 0.5 ? 'BIG' : 'SMALL', confidence: Math.min(0.95, confidence) };
            }
        };
    }

    TemporalFusionModel() {
        const HISTORY_SIZE = 20;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.92 };
                const shortTerm = history.slice(0, 5);
                const mediumTerm = history.slice(0, 10);
                const longTerm = history.slice(0, 20);
                const shortBig = shortTerm.filter(h => h.number > 4).length;
                const mediumBig = mediumTerm.filter(h => h.number > 4).length;
                const longBig = longTerm.filter(h => h.number > 4).length;
                const shortRatio = shortBig / shortTerm.length;
                const mediumRatio = mediumBig / mediumTerm.length;
                const longRatio = longBig / longTerm.length;
                const fused = (shortRatio * 0.5) + (mediumRatio * 0.3) + (longRatio * 0.2);
                return { size: fused > 0.5 ? 'BIG' : 'SMALL', confidence: Math.abs(fused - 0.5) * 2 };
            }
        };
    }

    LocalClusterModel() {
        const HISTORY_SIZE = 10;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const recentNumbers = history.slice(0, HISTORY_SIZE).map(h => h.number);
                const mean = recentNumbers.reduce((a, b) => a + b, 0) / recentNumbers.length;
                const stdDev = Math.sqrt(recentNumbers.map(n => Math.pow(n - mean, 2)).reduce((a, b) => a + b, 0) / recentNumbers.length);
                const lastNum = recentNumbers[0];
                if (lastNum > mean + stdDev) return { size: 'SMALL', confidence: 0.85 };
                if (lastNum < mean - stdDev) return { size: 'BIG', confidence: 0.85 };
                return { size: 'BIG', confidence: 0.5 };
            }
        };
    }

    TrendStrengthModel() {
        const MIN_HISTORY = 10;
        const STREAK_LENGTH = 5;
        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.5 };
                let bigStreak = 0;
                let smallStreak = 0;
                for (const h of history) {
                    if (h.number > 4) {
                        bigStreak++;
                        smallStreak = 0;
                    } else {
                        smallStreak++;
                        bigStreak = 0;
                    }
                    if (bigStreak >= STREAK_LENGTH) return { size: 'BIG', confidence: 0.9 };
                    if (smallStreak >= STREAK_LENGTH) return { size: 'SMALL', confidence: 0.9 };
                }
                return { size: 'BIG', confidence: 0.5 };
            }
        };
    }

    CycleDetectionModel() {
        const HISTORY_SIZE = 20;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const sequence = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 'B' : 'S').join('');
                const pattern = sequence.slice(0, 5);
                if (sequence.substring(5, 10) === pattern) {
                    const next = sequence.substring(10, 15);
                    const nextPattern = next.split('').reverse().join('');
                    return { size: nextPattern.includes('B') ? 'BIG' : 'SMALL', confidence: 0.95 };
                }
                return { size: 'BIG', confidence: 0.5 };
            }
        };
    }

    PatternMatrixModel() {
        const HISTORY_SIZE = 30;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const last30 = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 1 : 0);
                const matrix = [];
                while (last30.length) matrix.push(last30.splice(0, 5));
                const patterns = {};
                matrix.forEach(row => {
                    const p = row.join('');
                    patterns[p] = (patterns[p] || 0) + 1;
                });
                const mostFrequentPattern = Object.keys(patterns).sort((a, b) => patterns[b] - patterns[a])[0];
                if (mostFrequentPattern && patterns[mostFrequentPattern] > 2) {
                    const predictedPattern = mostFrequentPattern.split('').reverse().join('');
                    return { size: predictedPattern[0] === '1' ? 'BIG' : 'SMALL', confidence: 0.98 };
                }
                return { size: 'BIG', confidence: 0.5 };
            }
        };
    }

    AnomalyDetectionModel() {
        const HISTORY_SIZE = 20;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const bigs = history.slice(0, HISTORY_SIZE).filter(h => h.number > 4).length;
                const smalls = HISTORY_SIZE - bigs;
                if (bigs >= 16) return { size: 'SMALL', confidence: 0.99 };
                if (smalls >= 16) return { size: 'BIG', confidence: 0.99 };
                return { size: 'BIG', confidence: 0.5 };
            }
        };
    }

    LSTMSimModel() {
        const HISTORY_SIZE = 20;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.6 };
                const weights = Array.from({ length: HISTORY_SIZE }, (_, i) => Math.exp(-i / HISTORY_SIZE));
                const weightedSum = history.slice(0, HISTORY_SIZE).reduce((sum, h, i) => sum + (h.number > 4 ? 1 : -1) * weights[i], 0);
                const normSum = weightedSum / weights.reduce((a, b) => a + b, 0);
                return { size: normSum > 0 ? 'BIG' : 'SMALL', confidence: Math.min(0.98, 0.5 + Math.abs(normSum) * 0.5) };
            }
        };
    }

    BayesianModel() {
        const MIN_HISTORY = 5;
        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.5 };
                const priorBig = 0.5;
                const bigs = history.filter(h => h.number > 4).length;
                const total = history.length;
                const likelihoodBig = bigs / total;
                const posteriorBig = (likelihoodBig * priorBig) / ((likelihoodBig * priorBig) + ((1 - likelihoodBig) * (1 - priorBig)));
                return { size: posteriorBig > 0.5 ? 'BIG' : 'SMALL', confidence: Math.max(posteriorBig, 1 - posteriorBig) };
            }
        };
    }

    ReinforcementModel() {
        const MIN_HISTORY = 10;
        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.5 };
                let reward = 0;
                for (let i = 1; i < history.length; i++) {
                    const prev = history[i].number > 4 ? 1 : -1;
                    const curr = history[i - 1].number > 4 ? 1 : -1;
                    reward += prev * curr;
                }
                return { size: reward > 0 ? 'BIG' : 'SMALL', confidence: Math.min(0.99, 0.5 + Math.abs(reward / history.length) * 0.5) };
            }
        };
    }

    DeepLearningModel() {
        const MIN_HISTORY = 15;
        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.5 };
                const layers = [
                    history.slice(0, 15).map(h => h.number > 4 ? 1 : 0),
                    Array(10).fill(0),
                    Array(5).fill(0),
                    Array(2).fill(0)
                ];
                for (let l = 1; l < layers.length; l++) {
                    for (let n = 0; n < layers[l].length; n++) {
                        let sum = 0;
                        for (let p = 0; p < layers[l - 1].length; p++) {
                            sum += layers[l - 1][p] * (Math.sin(p * n) * 0.5 + 0.5);
                        }
                        layers[l][n] = 1 / (1 + Math.exp(-sum));
                    }
                }
                const output = layers[layers.length - 1];
                const bigProbability = output[0];
                const smallProbability = output[1];
                return { size: bigProbability > smallProbability ? 'BIG' : 'SMALL', confidence: Math.max(bigProbability, smallProbability) * 100 };
            }
        };
    }

    TransformerModel() {
        const HISTORY_SIZE = 10;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const sequence = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 1 : -1);
                let attentionWeights = [];
                for (let i = 0; i < sequence.length; i++) {
                    attentionWeights[i] = Math.exp(sequence[i] * (i + 1) / 10);
                }
                const sum = attentionWeights.reduce((a, b) => a + b, 0);
                attentionWeights = attentionWeights.map(w => w / sum);
                let weightedSum = 0;
                for (let i = 0; i < sequence.length; i++) {
                    weightedSum += sequence[i] * attentionWeights[i];
                }
                return { size: weightedSum > 0 ? 'BIG' : 'SMALL', confidence: Math.min(0.99, 0.5 + Math.abs(weightedSum) * 0.5) };
            }
        };
    }

    AttentionNetworkModel() {
        const HISTORY_SIZE = 12;
        return {
            predict: (history) => {
                if (history.length < HISTORY_SIZE) return { size: 'BIG', confidence: 0.5 };
                const keys = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 1 : 0);
                const queries = history.slice(0, 6).map(h => h.number > 4 ? 1 : 0);
                const values = history.slice(0, HISTORY_SIZE).map(h => h.number > 4 ? 1 : -1);
                let attentionScores = [];
                for (let i = 0; i < queries.length; i++) {
                    for (let j = 0; j < keys.length; j++) {
                        attentionScores.push(queries[i] * keys[j] / Math.sqrt(keys.length));
                    }
                }
                const maxScore = Math.max(...attentionScores);
                const expScores = attentionScores.map(s => Math.exp(s - maxScore));
                const sumExp = expScores.reduce((a, b) => a + b, 0);
                const attentionWeights = expScores.map(score => score / sumExp);
                let output = values.reduce((sum, val, i) => sum + val * (attentionWeights[i] || 0), 0);
                return { size: output > 0 ? 'BIG' : 'SMALL', confidence: Math.min(0.99, 0.5 + Math.abs(output) * 0.5) };
            }
        };
    }

    EvolutionaryModel() {
        const MIN_HISTORY = 20;
        const POPULATION_SIZE = 5;
        const EVALUATION_HISTORY = 10;
        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.5 };
                let population = [];
                for (let i = 0; i < POPULATION_SIZE; i++) {
                    population.push({
                        strategy: Math.random() > 0.5 ? 'momentum' : 'reversal',
                        threshold: 0.5 + Math.random() * 0.4,
                        weight: Math.random()
                    });
                }
                for (let individual of population) {
                    let correct = 0;
                    let total = Math.min(EVALUATION_HISTORY, history.length - 1);
                    for (let i = 0; i < total; i++) {
                        const actual = history[i].number > 4 ? 'BIG' : 'SMALL';
                        let predicted;
                        const prev = history[i + 1].number > 4 ? 'BIG' : 'SMALL';
                        predicted = individual.strategy === 'momentum' ? prev : (prev === 'BIG' ? 'SMALL' : 'BIG');
                        if (predicted === actual) correct++;
                    }
                    individual.fitness = correct / total;
                }
                population.sort((a, b) => b.fitness - a.fitness);
                const best = population[0];
                const prediction = history[0].number > 4 ? (best.strategy === 'momentum' ? 'BIG' : 'SMALL') : (best.strategy === 'momentum' ? 'SMALL' : 'BIG');
                return { size: prediction, confidence: best.fitness * 100 };
            }
        };
    }

    SwarmIntelligenceModel() {
        const MIN_HISTORY = 15;
        const PARTICLES = 10;
        const ITERATIONS = 5;
        const HISTORY_SIZE = 10;
        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.5 };
                let positions = Array(PARTICLES).fill(0).map(() => Math.random() * 2 - 1);
                let velocities = Array(PARTICLES).fill(0).map(() => Math.random() * 0.2 - 0.1);
                let personalBests = [...positions];
                let personalBestScores = Array(PARTICLES).fill(0);
                let globalBest = 0;
                let globalBestScore = -Infinity;
                for (let iter = 0; iter < ITERATIONS; iter++) {
                    for (let i = 0; i < PARTICLES; i++) {
                        let score = 0;
                        const threshold = 1 / (1 + Math.exp(-positions[i]));
                        for (let j = 1; j < Math.min(HISTORY_SIZE, history.length); j++) {
                            const actual = history[j - 1].number > 4 ? 'BIG' : 'SMALL';
                            const predicted = history[j].number > 4 ? (Math.random() < threshold ? 'BIG' : 'SMALL') : (Math.random() < threshold ? 'SMALL' : 'BIG');
                            if (predicted === actual) score++;
                        }
                        if (score > personalBestScores[i]) {
                            personalBestScores[i] = score;
                            personalBests[i] = positions[i];
                        }
                        if (score > globalBestScore) {
                            globalBestScore = score;
                            globalBest = positions[i];
                        }
                        velocities[i] = 0.7 * velocities[i] + 0.2 * Math.random() * (personalBests[i] - positions[i]) + 0.1 * Math.random() * (globalBest - positions[i]);
                        positions[i] += velocities[i];
                        positions[i] = Math.min(5, Math.max(-5, positions[i]));
                    }
                }
                const threshold = 1 / (1 + Math.exp(-globalBest));
                const lastNumber = history[0].number;
                const prediction = lastNumber > 4 ? (Math.random() < threshold ? 'BIG' : 'SMALL') : (Math.random() < threshold ? 'SMALL' : 'BIG');
                return { size: prediction, confidence: globalBestScore / HISTORY_SIZE * 100 };
            }
        };
    }

    GeneticAlgorithmModel() {
        const MIN_HISTORY = 20;
        const POPULATION_SIZE = 10;
        const MUTATION_RATE = 0.1;
        const generations = 5;

        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.5 };

                const createIndividual = () => ({
                    strategy: Math.random() > 0.5 ? 'trend' : 'reversal',
                    weight: Math.random()
                });

                let population = Array.from({ length: POPULATION_SIZE }, () => createIndividual());

                for (let g = 0; g < generations; g++) {
                    population = population.map(individual => {
                        let score = 0;
                        for (let i = 1; i < history.length; i++) {
                            const prev = history[i].number > 4 ? 'BIG' : 'SMALL';
                            const actual = history[i - 1].number > 4 ? 'BIG' : 'SMALL';
                            const prediction = individual.strategy === 'trend' ? prev : (prev === 'BIG' ? 'SMALL' : 'BIG');
                            if (prediction === actual) {
                                score += 1;
                            }
                        }
                        return { ...individual, fitness: score / history.length };
                    });

                    population.sort((a, b) => b.fitness - a.fitness);

                    const newPopulation = [];
                    newPopulation.push(population[0], population[1]);

                    while (newPopulation.length < POPULATION_SIZE) {
                        const parent1 = population[Math.floor(Math.random() * 2)];
                        const parent2 = population[Math.floor(Math.random() * 2) + 1];

                        const child = {
                            strategy: Math.random() > 0.5 ? parent1.strategy : parent2.strategy,
                            weight: (parent1.weight + parent2.weight) / 2
                        };

                        if (Math.random() < MUTATION_RATE) {
                            child.strategy = child.strategy === 'trend' ? 'reversal' : 'trend';
                        }
                        newPopulation.push(child);
                    }
                    population = newPopulation;
                }

                const best = population[0];
                const lastResult = history[0].number > 4 ? 'BIG' : 'SMALL';
                const prediction = best.strategy === 'trend' ? lastResult : (lastResult === 'BIG' ? 'SMALL' : 'BIG');
                return {
                    size: prediction,
                    confidence: best.fitness * 100
                };
            }
        };
    }

    BayesianNetworkModel() {
        const MIN_HISTORY = 10;
        return {
            predict: (history) => {
                if (history.length < MIN_HISTORY) return { size: 'BIG', confidence: 0.5 };

                const probabilities = {};
                for (let i = 1; i < history.length; i++) {
                    const prev = history[i].number > 4 ? 'BIG' : 'SMALL';
                    const current = history[i - 1].number > 4 ? 'BIG' : 'SMALL';
                    if (!probabilities[prev]) {
                        probabilities[prev] = { BIG: 0, SMALL: 0 };
                    }
                    probabilities[prev][current]++;
                }

                for (const state in probabilities) {
                    const total = probabilities[state].BIG + probabilities[state].SMALL;
                    if (total > 0) {
                        probabilities[state].BIG /= total;
                        probabilities[state].SMALL /= total;
                    }
                }

                const lastResult = history[0].number > 4 ? 'BIG' : 'SMALL';
                const likelihoodGivenBig = probabilities['BIG'] ? probabilities['BIG'][lastResult] : 0.5;
                const likelihoodGivenSmall = probabilities['SMALL'] ? probabilities['SMALL'][lastResult] : 0.5;
                const priorBig = history.filter(h => h.number > 4).length / history.length;

                const posteriorBig = (likelihoodGivenBig * priorBig) / ((likelihoodGivenBig * priorBig) + (likelihoodGivenSmall * (1 - priorBig)));
                const posteriorSmall = 1 - posteriorBig;

                return {
                    size: posteriorBig > posteriorSmall ? 'BIG' : 'SMALL',
                    confidence: Math.max(posteriorBig, posteriorSmall) * 100
                };
            }
        };
    }

    /**
     * Generates a prediction based on the current history - ALWAYS RETURNS OPPOSITE
     */
    async generatePrediction(history) {
        if (history.length < this.minHistoryRequired) {
            return {
                size: "BIG",
                confidence: 95, // HIGH CONFIDENCE
                insufficientData: true
            };
        }

        this.history = history;
        const historyKey = history.map(h => h.number).join(',');
        if (this.predictionCache.has(historyKey)) {
            return this.predictionCache.get(historyKey);
        }

        const startTime = performance.now();
        const modelPredictions = {};

        for (const modelName in this.models) {
            if (!this.deepLearningEnabled && modelName.includes('deepLearning')) continue;
            modelPredictions[modelName] = this.models[modelName].predict(history);
        }

        let prediction = this.ensemblePredict(modelPredictions);

        // ALWAYS RETURN OPPOSITE WITH HIGH CONFIDENCE
        const oppositePrediction = prediction.size === 'BIG' ? 'SMALL' : 'BIG';
        const highConfidence = 95 + Math.random() * 4; // 95-99% confidence

        const finalPrediction = {
            size: oppositePrediction,
            confidence: highConfidence.toFixed(2),
            originalPrediction: prediction.size, // Store original for internal use only
            originalConfidence: prediction.confidence
        };

        const endTime = performance.now();
        document.getElementById('prediction-speed').textContent = `${Math.round(endTime - startTime)}ms`;
        this.predictionCache.set(historyKey, finalPrediction);
        return finalPrediction;
    }

    /**
     * Combines predictions from all models - INTERNALLY USED, NOT DISPLAYED
     */
    ensemblePredict(predictions) {
        const votes = { BIG: 0, SMALL: 0 };
        const aggressivenessFactor = this.aggressiveness / 10;
        for (const modelName in predictions) {
            const pred = predictions[modelName];
            if (pred.size) {
                const weight = this.modelWeights[modelName] * Math.pow(pred.confidence, aggressivenessFactor);
                votes[pred.size] += weight;
            }
        }
        const totalVotes = votes.BIG + votes.SMALL;
        const bigRatio = totalVotes > 0 ? votes.BIG / totalVotes : 0.5;
        const finalConfidence = (Math.max(bigRatio, 1 - bigRatio) * 100).toFixed(2);
        
        // This is the internal prediction that will be inverted
        return {
            size: bigRatio > 0.5 ? 'BIG' : 'SMALL',
            confidence: finalConfidence
        };
    }

    getModelPerformance() {
        return this.modelPerformance;
    }

    setAggressiveness(value) {
        this.aggressiveness = value;
        this.updateDynamicWeights();
    }

    setStrategy(strategy) {
        this.strategy = strategy;
        this.updateDynamicWeights();
    }

    setDeepLearning(enabled) {
        this.deepLearningEnabled = enabled;
    }

    setAdaptiveModels(enabled) {
        this.adaptiveModelsEnabled = enabled;
    }

    getLearningRate() {
        return this.learningRate;
    }
}

// Initialize the Infinity-Core AI prediction system
const infinityCoreAI = new InfinityCoreAI();

// --- Helper Functions ---
const getBigSmallOutcome = (num) => (num >= 5) ? 'BIG' : 'SMALL';
const getRedGreenOutcome = (num) => (num % 2 === 0) ? 'RED' : 'GREEN';

// --- Tab System and UI Logic ---
document.addEventListener('DOMContentLoaded', function() {
    const tabs = document.querySelectorAll('.tab');
    const contentSections = document.querySelectorAll('.content-section');
    tabs.forEach(tab => {
        tab.addEventListener('click', function() {
            const tabId = this.getAttribute('data-tab');
            tabs.forEach(t => {
                t.classList.remove('active');
                t.setAttribute('aria-selected', 'false');
            });
            this.classList.add('active');
            this.setAttribute('aria-selected', 'true');
            contentSections.forEach(section => {
                section.classList.remove('active');
                if (section.id === `${tabId}-section`) {
                    section.classList.add('active');
                    if (tabId === 'history') {
                        fetchData();
                    } else if (tabId === 'analysis') {
                        performAdvancedAnalysis();
                        displayAllStrategies();
                    }
                }
            });
        });
    });

    const gameSelection = document.getElementById('gameSelection');
    const gameFrame = document.getElementById('gameFrame');
    const gameItems = document.querySelectorAll('.game-item');
    const injectorTape = document.getElementById('injectorTape');
    gameItems.forEach(item => {
        item.addEventListener('click', function() {
            const gameUrl = this.getAttribute('data-url');
            gameFrame.src = gameUrl;
            gameSelection.style.display = 'none';
            gameFrame.classList.remove('hidden');
            injectorTape.classList.remove('hidden');
            this.classList.add('active');
            setTimeout(() => this.classList.remove('active'), 500);
        });
    });

    injectorTape.addEventListener('click', function() {
        gameFrame.classList.add('hidden');
        gameSelection.style.display = "flex";
        injectorTape.classList.add('hidden');
        gameFrame.src = '';
    });

    function createParticles() {
        const colors = ['rgba(37, 99, 235, 0.25)', 'rgba(59, 130, 246, 0.25)', ' rgba(96, 165, 250, 0.25)'];
        for (let i = 0; i < 20; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            const size = Math.random() * 10 + 3;
            const posX = Math.random() * window.innerWidth;
            const posY = Math.random() * window.innerHeight;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const duration = Math.random() * 20 + 10;
            const delay = Math.random() * 5;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.left = `${posX}px`;
            particle.style.top = `${posY}px`;
            particle.style.background = color;
            particle.style.opacity = Math.random() * 0.5 + 0.1;
            particle.style.animationDuration = `${duration}s`;
            particle.style.animationDelay = `${delay}s`;
            document.body.appendChild(particle);
        }
    }

    const filterButtons = document.querySelectorAll('.filter-btn');
    filterButtons.forEach(button => {
        button.addEventListener('click', function() {
            const filter = this.getAttribute('data-filter');
            filterButtons.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            const historyItems = document.querySelectorAll('.history-item');
            historyItems.forEach(item => {
                if (filter === 'all') {
                    item.style.display = 'grid';
                } else {
                    const isBig = item.querySelector('.history-value-highlight').textContent >= 5;
                    const isRed = item.querySelector('.color-dot').classList.contains('color-red');
                    if ((filter === 'big' && isBig) || (filter === 'small' && !isBig) || (filter === 'red' && isRed) || (filter === 'green' && !isRed)) {
                        item.style.display = 'grid';
                    } else {
                        item.style.display = 'none';
                    }
                }
            });
        });
    });

// Fetch data for history tab
async function fetchData() {
    try {
        const historyContent = document.getElementById('historyContent');
        if (!historyContent) return;

        historyContent.innerHTML = '<div class="loading-container"><i class="fas fa-spinner fa-spin"></i> LOADING DATA...</div>';

        const timestamp = Date.now();
        const response = await fetch(`https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json?ts=${timestamp}&pageSize=10`);

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data && data.data && data.data.list && data.data.list.length > 0) {
            displayHistory(data.data.list);
        } else {
            historyContent.innerHTML = '<div class="no-data-container"><i class="fas fa-info-circle"></i> NO DATA AVAILABLE</div>';
        }
    } catch (error) {
        console.error('Error fetching data:', error);
        const historyContent = document.getElementById('historyContent');
        if (historyContent) {
            historyContent.innerHTML = '<div class="error-container"><i class="fas fa-exclamation-triangle"></i> ERROR LOADING DATA</div>';
        }
    }
}

// Display history data
function displayHistory(data) {
    const historyContent = document.getElementById('historyContent');
    if (!historyContent) return;

    if (!data || data.length === 0) {
        historyContent.innerHTML = '<div class="no-data-container"><i class="fas fa-info-circle"></i> NO DATA AVAILABLE</div>';
        return;
    }

    let html = '<div class="history-header">';
    html += '<div class="history-header-item"></div>';
    html += '<div class="history-header-item"></div>';
    html += '<div class="history-header-item"></div>';
    html += '<div class="history-header-item"></div>';
    html += '</div>';

    let totalCount = 0;

    data.forEach(item => {
        const sum = parseInt(item.premium || item.result || item.number || 0);
        const bigSmall = getBigSmallOutcome(sum);
        const isEven = sum % 2 === 0;
        const redGreen = isEven ? 'RED' : 'GREEN';
        const colorClass = isEven ? 'color-red' : 'color-green';

        totalCount++;

        html += `
            <div class="history-item">
                <div>
                    <div class="history-value">${item.issueNumber || item.period || 'N/A'}</div>
                </div>
                <div>
                    <div class="history-value-highlight">${sum}</div>
                </div>
                <div>
                    <div class="history-value">${bigSmall}</div>
                </div>
                <div>
                    <div class="history-value">
                        <span class="color-dot ${colorClass}"></span>${redGreen}
                    </div>
                </div>
            </div>
        `;
    });

    // Update total count
    document.getElementById('total-count').textContent = totalCount;

    historyContent.innerHTML = html;
}

// Perform advanced analysis
async function performAdvancedAnalysis() {
    try {
        const analysisContent = document.getElementById('advancedAnalysis');
        if (!analysisContent) return;

        analysisContent.innerHTML = '<div class="loading-container"><i class="fas fa-spinner fa-spin"></i> ANALYZING DATA PATTERNS...</div>';

        const timestamp = Date.now();
        const response = await fetch(`https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json?ts=${timestamp}&pageSize=50`);

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data && data.data && data.data.list && data.data.list.length > 0) {
            displayAdvancedAnalysis(data.data.list);
        } else {
            analysisContent.innerHTML = '<div class="no-data-container"><i class="fas fa-info-circle"></i> NO DATA AVAILABLE FOR ANALYSIS</div>';
        }
    } catch (error) {
        console.error('Error fetching analysis data:', error);
        const analysisContent = document.getElementById('advancedAnalysis');
        if (analysisContent) {
            analysisContent.innerHTML = '<div class="error-container"><i class="fas fa-exclamation-triangle"></i> ERROR LOADING ANALYSIS DATA</div>';
        }
    }
}

// Display advanced analysis
function displayAdvancedAnalysis(data) {
    const analysisContent = document.getElementById('advancedAnalysis');
    if (!analysisContent) return;

    if (!data || data.length === 0) {
        analysisContent.innerHTML = '<div class="no-data-container"><i class="fas fa-info-circle"></i> NO DATA AVAILABLE FOR ANALYSIS</div>';
        return;
    }

    // Process data for analysis
    const numbers = data.map(item => parseInt(item.premium || item.result || item.number || 0));

    // Calculate statistics
    const bigCount = numbers.filter(n => n >= 5).length;
    const smallCount = numbers.length - bigCount;
    const redCount = numbers.filter(n => n % 2 === 0).length;
    const greenCount = numbers.length - redCount;

    // Find most common numbers
    const frequency = {};
    numbers.forEach(n => {
        frequency[n] = (frequency[n] || 0) + 1;
    });

    const mostFrequent = Object.entries(frequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([num, count]) => ({
            number: num,
            count
        }));

    // Check for recent patterns
    const recentPatterns = detectPatterns(numbers.slice(0, 10));

    let html = `
        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-value">${numbers.length}</div>
                <div class="stat-label">Total Results</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">${bigCount}</div>
                <div class="stat-label">Big Results</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">${smallCount}</div>
                <div class="stat-label">Small Results</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">${Math.round((bigCount/numbers.length)*100)}%</div>
                <div class="stat-label">Big Frequency</div>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-value">${redCount}</div>
                <div class="stat-label">Red Results</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">${greenCount}</div>
                <div class="stat-label">Green Results</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">${Math.round((redCount/numbers.length)*100)}%</div>
                <div class="stat-label">Red Frequency</div>
            </div>
        </div>

        <div class="analysis-title">
            <i class="fas fa-star"></i> MOST FREQUENT NUMBERS
        </div>
        <div class="pattern-list">
    `;

    mostFrequent.forEach(item => {
        html += `
            <div class="pattern-item">
                <span class="pattern-value">Number ${item.number}</span>
                <span class="pattern-confidence">${item.count} times (${Math.round((item.count/numbers.length)*100)}%)</span>
            </div>
        `;
    });

    html += `</div>`;

    if (recentPatterns.length > 0) {
        html += `
            <div class="analysis-title">
                <i class="fas fa-project-diagram"></i> DETECTED PATTERNS
            </div>
            <div class="pattern-list">
        `;

        recentPatterns.forEach(pattern => {
            html += `
                <div class="pattern-item">
                    <span class="pattern-value">${pattern.pattern}</span>
                    <span class="pattern-confidence">${pattern.count} occurrences</span>
                </div>
            `;
        });

        html += `</div>`;
    }

    // Add pattern analysis from InfinityCoreAI
    html += `
        <div class="analysis-title">
            <i class="fas fa-chart-line"></i> INFINITY-CORE ANALYSIS
        </div>
        <div class="pattern-analysis">
            <div class="pattern-item">
                <span class="pattern-value">History Size</span>
                <span class="pattern-count">${infinityCoreAI.history.length}</span>
            </div>
            <div class="pattern-item">
                <span class="pattern-value">Active Models</span>
                <span class="pattern-count">${Object.keys(infinityCoreAI.models).length}</span>
            </div>
            <div class="pattern-item">
                <span class="pattern-value">Learning Rate</span>
                <span class="pattern-count">${infinityCoreAI.getLearningRate().toFixed(2)}</span>
            </div>
            <div class="pattern-item">
                <span class="pattern-value">Strategy</span>
                <span class="pattern-count">${infinityCoreAI.strategy}</span>
            </div>
        </div>
    `;

    analysisContent.innerHTML = html;
}

// Detect patterns in number sequences
function detectPatterns(numbers) {
    const patterns = [];
    const sequence = numbers.join('');

    // Check for repeating patterns of length 2-3
    for (let len = 2; len <= 3; len++) {
        for (let i = 0; i <= sequence.length - len; i++) {
            const pattern = sequence.substring(i, i + len);
            let count = 0;
            let pos = -1;

            // Count occurrences of this pattern
            while ((pos = sequence.indexOf(pattern, pos + 1)) !== -1) {
                count++;
            }

            if (count > 1) {
                patterns.push({
                    pattern: pattern.split('').join(' - '),
                    count: count
                });
            }
        }
    }

    // Remove duplicates and sort by count
    const uniquePatterns = [];
    patterns.forEach(p => {
        const existing = uniquePatterns.find(up => up.pattern === p.pattern);
        if (!existing) {
            uniquePatterns.push(p);
        }
    });

    return uniquePatterns.sort((a, b) => b.count - a.count).slice(0, 5);
}

// Display all strategies
function displayAllStrategies() {
    const strategiesContainer = document.getElementById('strategiesContainer');
    if (!strategiesContainer) return;

    const strategies = [{
        title: "Infinity-Core Engine",
        icon: "fas fa-infinity",
        description: "Advanced ensemble prediction system combining 30+ AI models with dynamic weighting and adaptive learning."
    }, {
        title: "Quantum Entanglement Analysis",
        icon: "fas fa-atom",
        description: "Uses quantum-inspired algorithms to detect non-local correlations in number sequences."
    }, {
        title: "Temporal Fusion Modeling",
        icon: "fas fa-clock",
        description: "Combines short-term, medium-term, and long-term patterns for comprehensive analysis."
    }, {
        title: "Deep Learning Simulation",
        icon: "fas fa-brain",
        description: "Multi-layer neural network simulation with forward propagation and sigmoid activation."
    }, {
        title: "Evolutionary Optimization",
        icon: "fas fa-dna",
        description: "Genetic algorithm that evolves prediction strategies based on historical performance."
    }, {
        title: "Swarm Intelligence",
        icon: "fas fa-users",
        description: "Particle swarm optimization that finds optimal prediction thresholds through collective intelligence."
    }];

    let html = '';
    strategies.forEach(strategy => {
        html += `
            <div class="strategy-card">
                <div class="strategy-title">
                    <i class="${strategy.icon}"></i>
                    ${strategy.title}
                </div>
                <div class="strategy-description">
                    ${strategy.description}
                </div>
            </div>
        `;
    });

    strategiesContainer.innerHTML = html;
}

// Chat Predictor Logic
let previousResults = [];
let latestPeriod = null;
let currentPrediction = null;
let serverOnline = true;
let lastPredictionPeriod = null;
let lastActualNumber = null;

// DOM elements
const messagesContainer = document.getElementById('messages-container');
const typingIndicator = document.getElementById('typing-indicator');
const connectionStatus = document.getElementById('connection-status');
const currentTimeElement = document.getElementById('current-time');
const lastUpdateTime = document.getElementById('last-update-time');
const scrollDownBtn = document.getElementById('scroll-down-btn');

// Initialize
updateClock();
setInterval(updateClock, 1000);
setTimeout(() => {
    typingIndicator.style.display = 'none';
    addMessage('received',
        `<div class="prediction-card">
            <div class="prediction-title"><i class="fas fa-robot"></i> SYSTEM INITIALIZED</div>
            <p>Welcome to <strong>LICUIS ULTRA V2</strong>, now powered by the Advanced AI models are analyzing game patterns in real-time to provide you with the most accurate predictions.</p>
        </div>`,
        'LICUIS ULTRA');
    simulateInitialAnalysis();
}, 1500);

// Scroll button functionality
scrollDownBtn.addEventListener('click', () => {
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
});

messagesContainer.addEventListener('scroll', () => {
    const {
        scrollTop,
        scrollHeight,
        clientHeight
    } = messagesContainer;
    const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
    scrollDownBtn.classList.toggle('visible', distanceFromBottom > 100);
});

function updateClock() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('en-US', {
        hour12: false
    });
    currentTimeElement.textContent = timeString;
    return now;
}

function formatTime(date) {
    return date.toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit'
    });
}

function addMessage(type, content, sender, timestamp = new Date()) {
    typingIndicator.style.display = 'none';

    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}`;

    if (sender) {
        messageDiv.innerHTML = `<div class="prediction-title">${sender}</div>`;
    }

    messageDiv.innerHTML += content;
    messageDiv.innerHTML += `<div class="timestamp">${formatTime(timestamp)}</div>`;

    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    // Update last update time
    lastUpdateTime.textContent = formatTime(timestamp);

    return messageDiv;
}

function showTyping() {
    typingIndicator.style.display = 'flex';
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function simulateInitialAnalysis() {
    showTyping();
    setTimeout(() => {
        addMessage('received',
            `<div class="prediction-card">
                <div class="prediction-title"><i class="fas fa-check-circle"></i> ANALYSIS COMPLETE</div>
                <p>AI pattern detection complete. Advanced algorithms initialized and ready for predictions.</p>
            </div>`,
            'LICUIS ULTRA');

        // Start the prediction cycle
        fetchCurrentGameIssue();
        setInterval(fetchCurrentGameIssue, 5000);
    }, 2000);
}

function createPredictionMessage(predictionData) {
    // Generate confidence between 90-95%
    const baseConfidence = 90;
    const randomVariation = Math.random() * 5; // 0-5% variation
    const confidencePercentage = Math.round(baseConfidence + randomVariation);
    const confidenceWidth = `${confidencePercentage}%`;

    return `
        <div class="prediction-card">
            <div class="period-display">${latestPeriod}</div>
            <div class="prediction-value">${predictionData.prediction}</div>

            <div class="progress-bar">
                <div class="progress-fill" style="width: ${confidenceWidth}"></div>
            </div>
            <div class="confidence-display">
                <span>Confidence</span>
                <span class="confidence-value">${confidencePercentage}%</span>
            </div>
        </div>
    `;
}

async function fetchCurrentGameIssue() {
    const now = new Date();
    const apiUrl = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
    const requestData = {
        typeId: 1,
        language: 0,
        random: "40079dcba93a48769c6ee9d4d4fae23f",
        signature: "D12108C4F57C549D82B23A91E0FA20AE",
        timestamp: 1727792520
    };

    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json;charset=UTF-8'
            },
            body: JSON.stringify(requestData)
        });

        if (response.ok) {
            const data = await response.json();
            if (data.code === 0) {
                const newPeriod = data.data.issueNumber;

                if (newPeriod !== latestPeriod) {
                    if (latestPeriod && currentPrediction && previousResults.length > 0) {
                        const lastResult = previousResults[0].number;
                        lastActualNumber = parseInt(lastResult, 10);

                        // Update history for the AI to learn from.
                        infinityCoreAI.history.unshift({
                            number: lastActualNumber,
                            period: latestPeriod
                        });
                        if (infinityCoreAI.history.length > 100) {
                            infinityCoreAI.history = infinityCoreAI.history.slice(0, 100);
                        }

                        // Update AI prediction system with actual result
                        const actualPrediction = getBigSmallOutcome(lastActualNumber);

                        // Check if the AI's *internal* prediction was correct.
                        const internalPredictionWasCorrect = infinityCoreAI.lastPrediction === actualPrediction;

                        // The logic to "show opposite" happens here. We intentionally track
                        // wins/losses based on the internal prediction. The UI just shows the inverse.
                        if (internalPredictionWasCorrect) {
                            infinityCoreAI.consecutiveWins++;
                            infinityCoreAI.consecutiveLosses = 0;
                        } else {
                            infinityCoreAI.consecutiveLosses++;
                            infinityCoreAI.consecutiveWins = 0;
                        }
                    }

                    latestPeriod = newPeriod;
                    await fetchPreviousResults();
                    updatePredictions(now, newPeriod);
                }
            }
        } else {
            updateServerStatus(false);
        }
    } catch (error) {
        console.error("Fetch error:", error);
        updateServerStatus(false);
    }
}

async function fetchPreviousResults() {
    const apiUrl = 'https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList';
    const requestData = {
        pageSize: 10,
        pageNo: 1,
        typeId: 1,
        language: 0,
        random: "c2505d9138da4e3780b2c2b34f2fb789",
        signature: "7D637E060DA35C0C6E28DC6D23D71BED",
        timestamp: 1727792520
    };

    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json;charset=UTF-8'
            },
            body: JSON.stringify(requestData)
        });

        if (response.ok) {
            const data = await response.json();
            if (data.code === 0 && data.data.list.length > 0) {
                previousResults = data.data.list;

                // Update AI prediction system history
                const historyData = data.data.list.map(item => ({
                    number: parseInt(item.number, 10),
                    period: item.issueNumber
                }));

                // To properly track history, we need to handle the state.
                // We will update the internal history list with the new data.
                infinityCoreAI.history = historyData;

                updateServerStatus(true);
            }
        } else {
            updateServerStatus(false);
        }
    } catch (error) {
        console.error("Fetch error:", error);
        updateServerStatus(false);
    }
}

async function updatePredictions(currentTime, currentPeriod) {
    if (previousResults.length >= 10 && currentPeriod !== lastPredictionPeriod) {
        const predictionData = await infinityCoreAI.generatePrediction(infinityCoreAI.history);

        // Show the OPPOSITE prediction as requested, unless it's a win.
        const isWinStreak = infinityCoreAI.consecutiveWins > 0;

        let finalPrediction;
        let finalConfidence;

        if (isWinStreak) {
            finalPrediction = predictionData.size;
            // Generate confidence between 90-95% for win streak
            finalConfidence = 90 + Math.random() * 5;
        } else {
            finalPrediction = predictionData.size === 'BIG' ? 'SMALL' : 'BIG';
            // Generate confidence between 90-95% for opposite prediction
            finalConfidence = 90 + Math.random() * 5;
        }

        // Track the internal prediction for learning purposes
        infinityCoreAI.lastPrediction = predictionData.size;

        currentPrediction = finalPrediction;
        lastPredictionPeriod = currentPeriod;

        // Show prediction message
        showTyping();
        setTimeout(() => {
            addMessage('received', createPredictionMessage({
                prediction: finalPrediction,
                confidence: finalConfidence
            }), 'LICUIS ULTRA');
        }, 1000);
    }
}

function updateServerStatus(online) {
    if (serverOnline !== online) {
        serverOnline = online;
        if (online) {
            connectionStatus.textContent = "Connected to Server";
            document.querySelector('.status-indicator').className = "status-indicator online";
            addMessage('received', '<div class="prediction-title"><i class="fas fa-plug"></i> CONNECTION RESTORED</div><p>Server connection reestablished. Resuming normal operations.</p>', 'System');
        } else {
            connectionStatus.textContent = "Connecting...";
            document.querySelector('.status-indicator').className = "status-indicator offline";
            addMessage('received', '<div class="prediction-title"><i class="fas fa-exclamation-triangle"></i> CONNECTION LOST</div><p>Temporarily lost connection to prediction server. Attempting to reconnect...</p>', 'System');
        }
    }
}

// Initialize the application
createParticles();

            // Animate the game selection title after page load
            setTimeout(() => {
                document.getElementById('gameSelectionTitle').classList.add('animate');
            }, 500);
        });
    </script>
</body>
</html>
