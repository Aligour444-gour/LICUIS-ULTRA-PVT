<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LICUIS ULTRA V3 - Enhanced</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=El+Messiri:wght@400;500;600;700&family=Orbitron:wght@400;500;700;900&family=Exo+2:wght@300;400;500;600;700&display=swap');

        :root {
            --primary: #4f46e5;
            --primary-dark: #4338ca;
            --secondary: #6366f1;
            --accent: #818cf8;
            --win: #10b981;
            --loss: #ef4444;
            --warning: #f59e0b;
            --bg-light: #0f0f23;
            --bg-lighter: #1a1b2e;
            --bg-medium: #252641;
            --text-dark: #f8fafc;
            --text-medium: #e2e8f0;
            --text-light: #94a3b8;
            --glass-bg: rgba(26, 27, 46, 0.9);
            --glass-border: rgba(79, 70, 229, 0.3);
            --transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.1);
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 20px 40px rgba(0, 0, 0, 0.5);
            --gradient: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
            --success-gradient: linear-gradient(135deg, var(--win), #059669);
            --danger-gradient: linear-gradient(135deg, var(--loss), #dc2626);
            --radius: 16px;
            --radius-sm: 8px;
            --glow: 0 0 15px rgba(79, 70, 229, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-light);
            color: var(--text-dark);
            font-family: 'Exo 2', sans-serif;
            padding: 0;
            margin: 0;
            overflow: hidden;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(79, 70, 229, 0.1) 0%, transparent 25%), 
                radial-gradient(circle at 90% 80%, rgba(99, 102, 241, 0.1) 0%, transparent 25%),
                linear-gradient(to bottom, rgba(15, 15, 35, 0.9), rgba(15, 15, 35, 0.7));
            position: fixed;
            width: 100%;
            height: 100%;
            line-height: 1.6;
        }

        /* Enhanced Logo Styles */
        .logo {
            position: absolute;
            top: 15px;
            left: 20px;
            z-index: 100000000;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: var(--glass-bg);
            border-radius: var(--radius);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow), var(--glow);
            transition: var(--transition);
        }

        .logo:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5), 0 0 20px rgba(79, 70, 229, 0.6);
        }

        .logo-icon {
            width: 38px;
            height: 38px;
            background: var(--gradient);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(79, 70, 229, 0.5);
            animation: logoPulse 4s ease-in-out infinite;
        }

        @keyframes logoPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 25px rgba(79, 70, 229, 0.7); }
        }

        .logo-icon svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        .logo-text {
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: 18px;
            background: var(--gradient);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(79, 70, 229, 0.3);
        }

        /* Enhanced Tab System */
        .tab-system {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 70px;
            background: rgba(15, 15, 35, 0.95);
            display: flex;
            z-index: 99999999;
            backdrop-filter: blur(15px);
            border-bottom: 1px solid rgba(79, 70, 229, 0.2);
            padding-left: 120px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .tab {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
            gap: 10px;
        }

        .tab:hover {
            background: rgba(79, 70, 229, 0.1);
        }

        .tab.active {
            background: rgba(79, 70, 229, 0.15);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--gradient);
            border-radius: 2px 2px 0 0;
            box-shadow: 0 0 10px rgba(79, 70, 229, 0.5);
        }

        .tab-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            background: rgba(79, 70, 229, 0.1);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .tab.active .tab-icon {
            background: var(--gradient);
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.4);
        }

        .tab-icon i {
            font-size: 14px;
            color: var(--primary);
            transition: var(--transition);
            z-index: 1;
        }

        .tab.active .tab-icon i {
            color: white;
        }

        .tab-label {
            font-family: 'Exo 2', sans-serif;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-medium);
            transition: var(--transition);
            letter-spacing: 0.5px;
        }

        .tab.active .tab-label {
            color: var(--text-dark);
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .tab:hover .tab-label {
            color: var(--text-dark);
        }

        /* Content Sections */
        .content-section {
            position: fixed;
            top: 70px;
            left: 0;
            width: 100%;
            height: calc(100% - 70px);
            display: none;
            overflow: hidden;
        }

        .content-section.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Web Section (Game Selection) */
        #web-section {
            background-color: var(--bg-light);
        }

        /* History Section */
        #history-section {
            background-color: var(--bg-light);
            padding: 25px;
            overflow-y: auto;
        }

        .history-container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--glass-bg);
            border-radius: var(--radius);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(15px);
            overflow: hidden;
            box-shadow: var(--shadow), var(--glow);
            animation: slideUp 0.6s ease;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .history-title {
            text-align: center;
            padding: 25px;
            font-family: 'Orbitron', sans-serif;
            font-size: 26px;
            color: var(--primary);
            background: rgba(79, 70, 229, 0.05);
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            text-shadow: 0 0 10px rgba(79, 70, 229, 0.3);
        }

        .history-controls {
            display: flex;
            justify-content: space-between;
            padding: 25px;
            background: rgba(79, 70, 229, 0.05);
            border-bottom: 1px solid var(--glass-border);
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .history-filter {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .filter-btn {
            background: rgba(26, 27, 46, 0.9);
            border: 1px solid var(--glass-border);
            color: var(--text-medium);
            padding: 12px 20px;
            border-radius: 30px;
            cursor: pointer;
            transition: var(--transition);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Exo 2', sans-serif;
        }

        .filter-btn:hover {
            background: rgba(79, 70, 229, 0.15);
            border-color: var(--primary);
            color: var(--text-dark);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .filter-btn.active {
            background: var(--gradient);
            color: white;
            box-shadow: 0 5px 15px rgba(79, 70, 229, 0.3), 0 0 10px rgba(79, 70, 229, 0.3);
            border-color: transparent;
        }

        .history-stats {
            display: flex;
            gap: 15px;
        }

        .stat-badge {
            background: rgba(26, 27, 46, 0.9);
            border: 1px solid var(--glass-border);
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            transition: var(--transition);
        }

        .stat-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .stat-badge.win {
            color: var(--win);
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.3);
        }

        .stat-badge.loss {
            color: var(--loss);
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.3);
        }

        .history-content {
            padding: 0;
        }

        .history-header {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            padding: 20px 25px;
            background: rgba(79, 70, 229, 0.05);
            font-weight: 600;
            border-bottom: 1px solid var(--glass-border);
            color: var(--text-dark);
            font-family: 'Exo 2', sans-serif;
            font-size: 15px;
        }

        .history-item {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            padding: 20px 25px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: var(--transition);
            position: relative;
        }

        .history-item:hover {
            background: rgba(79, 70, 229, 0.03);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .history-value {
            font-size: 16px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dark);
            font-family: 'Exo 2', sans-serif;
        }

        .history-value-highlight {
            font-size: 20px;
            font-weight: 700;
            color: var(--primary);
            text-shadow: 0 0 10px rgba(79, 70, 229, 0.3);
        }

        .color-dot {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 8px currentColor;
        }

        .color-red {
            background-color: var(--loss);
        }

        .color-green {
            background-color: var(--win);
        }

        .history-pagination {
            display: flex;
            justify-content: center;
            padding: 25px;
            gap: 12px;
            border-top: 1px solid var(--glass-border);
        }

        .pagination-btn {
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            background: rgba(26, 27, 46, 0.9);
            border: 1px solid var(--glass-border);
            color: var(--text-dark);
            cursor: pointer;
            transition: var(--transition);
            font-weight: 600;
            font-family: 'Exo 2', sans-serif;
        }

        .pagination-btn:hover:not(.disabled) {
            background: rgba(79, 70, 229, 0.1);
            border-color: var(--primary);
            color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .pagination-btn.active {
            background: var(--gradient);
            color: white;
            box-shadow: 0 5px 15px rgba(79, 70, 229, 0.3), 0 0 10px rgba(79, 70, 229, 0.3);
            border-color: transparent;
        }

        .pagination-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .loading-container,
        .error-container,
        .no-data-container {
            text-align: center;
            padding: 80px 25px;
            color: var(--text-light);
        }

        .loading-container i,
        .error-container i,
        .no-data-container i {
            font-size: 36px;
            margin-bottom: 20px;
            display: block;
            color: var(--primary);
        }

        .error-container {
            color: var(--loss);
        }

        /* Analysis Section */
        #analysis-section {
            overflow-y: auto;
            padding: 25px;
        }

        .analysis-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .analysis-card {
            background: var(--glass-bg);
            border-radius: var(--radius);
            border: 1px solid var(--glass-border);
            padding: 30px;
            margin-bottom: 30px;
            backdrop-filter: blur(15px);
            box-shadow: var(--shadow), var(--glow);
            animation: slideUp 0.6s ease;
        }

        .analysis-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 22px;
            color: var(--primary);
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--glass-border);
            text-shadow: 0 0 10px rgba(79, 70, 229, 0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .stat-item {
            background: rgba(26, 27, 46, 0.9);
            border-radius: var(--radius);
            padding: 25px;
            text-align: center;
            border: 1px solid var(--glass-border);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--gradient);
            transform: scaleX(0);
            transition: transform 0.5s ease;
        }

        .stat-item:hover::before {
            transform: scaleX(1);
        }

        .stat-item:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-lg), 0 0 15px rgba(79, 70, 229, 0.3);
        }

        .stat-value {
            font-size: 32px;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(79, 70, 229, 0.3);
            font-family: 'Orbitron', sans-serif;
        }

        .stat-label {
            font-size: 15px;
            color: var(--text-light);
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .pattern-list {
            margin-top: 25px;
        }

        .pattern-item {
            display: flex;
            justify-content: space-between;
            padding: 16px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            align-items: center;
            transition: var(--transition);
        }

        .pattern-item:hover {
            background: rgba(79, 70, 229, 0.03);
            padding-left: 10px;
            padding-right: 10px;
            border-radius: var(--radius-sm);
        }

        .pattern-item:last-child {
            border-bottom: none;
        }

        .pattern-value {
            font-weight: 600;
            color: var(--text-dark);
            font-family: 'Exo 2', sans-serif;
        }

        .pattern-confidence {
            color: var(--primary);
            font-weight: 700;
            text-shadow: 0 0 10px rgba(79, 70, 229, 0.3);
        }

        /* Strategy Cards */
        .strategy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }

        .strategy-card {
            background: rgba(26, 27, 46, 0.9);
            border-radius: var(--radius);
            padding: 25px;
            border-left: 4px solid var(--primary);
            border: 1px solid var(--glass-border);
            transition: var(--transition);
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .strategy-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--gradient);
            opacity: 0;
            transition: opacity 0.4s ease;
            z-index: 0;
        }

        .strategy-card:hover::before {
            opacity: 0.05;
        }

        .strategy-card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-lg), 0 0 15px rgba(79, 70, 229, 0.3);
        }

        .strategy-title {
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 19px;
            position: relative;
            z-index: 1;
            font-family: 'Exo 2', sans-serif;
        }

        .strategy-description {
            font-family: 'Exo 2', sans-serif;
            font-size: 15px;
            color: var(--text-medium);
            line-height: 1.6;
            position: relative;
            z-index: 1;
        }

        /* Game Selection Screen */
        .game-selection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 35, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999999;
            animation: fadeIn 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
            backdrop-filter: blur(15px);
        }

        .game-selection::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(79, 70, 229, 0.1) 0%, transparent 25%), 
                radial-gradient(circle at 80% 70%, rgba(99, 102, 241, 0.1) 0%, transparent 25%);
            z-index: -1;
            pointer-events: none;
        }

        .game-selection-title {
            font-family: 'El Messiri', sans-serif;
            font-weight: 700;
            font-size: 48px;
            margin: 0 0 60px;
            color: var(--primary);
            letter-spacing: 4px;
            position: relative;
            display: inline-block;
            text-shadow: 0 5px 20px rgba(79, 70, 229, 0.4);
            animation: titleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { text-shadow: 0 5px 20px rgba(79, 70, 229, 0.4); }
            to { text-shadow: 0 5px 30px rgba(79, 70, 229, 0.7), 0 0 20px rgba(79, 70, 229, 0.5); }
        }

        .game-selection-title::after {
            content: "";
            position: absolute;
            bottom: -20px;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--gradient);
            transform: scaleX(0);
            transform-origin: right;
            transition: transform 1s cubic-bezier(0.19, 1, 0.22, 1);
            border-radius: 2px;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.5);
        }

        .game-selection-title.animate::after {
            transform: scaleX(1);
            transform-origin: left;
        }

        .game-list-container {
            width: 100%;
            max-width: 1200px;
            max-height: calc(100vh - 220px);
            overflow-y: auto;
            padding: 0 25px;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) rgba(0, 0, 0, 0.1);
        }

        .game-list-container::-webkit-scrollbar {
            width: 10px;
        }

        .game-list-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .game-list-container::-webkit-scrollbar-thumb {
            background: var(--gradient);
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(79, 70, 229, 0.5);
        }

        .game-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 30px;
            padding: 0 25px 60px;
        }

        .game-item {
            background: rgba(26, 27, 46, 0.95);
            border: 1px solid rgba(79, 70, 229, 0.2);
            border-radius: var(--radius);
            padding: 30px;
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
            font-family: 'Exo 2', sans-serif;
            color: var(--text-dark);
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
        }

        .game-item::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: var(--gradient);
            opacity: 0;
            transition: opacity 0.4s ease;
            border-radius: 3px 3px 0 0;
        }

        .game-item:hover::before {
            opacity: 1;
        }

        .game-item:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow: var(--shadow-lg), 0 0 20px rgba(79, 70, 229, 0.4);
            background: rgba(26, 27, 46, 1);
            border-color: rgba(79, 70, 229, 0.4);
        }

        .game-name {
            font-family: 'El Messiri', sans-serif;
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 15px;
            position: relative;
            z-index: 1;
            transition: var(--transition);
        }

        .game-item:hover .game-name {
            color: var(--primary);
            text-shadow: 0 0 10px rgba(79, 70, 229, 0.3);
        }

        .game-url {
            font-size: 14px;
            color: var(--text-light);
            word-break: break-all;
            opacity: 0.7;
            transition: var(--transition);
        }

        .game-item:hover .game-url {
            opacity: 1;
        }

        /* Iframe and Tape Button */
        .fullscreen-iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            z-index: 1;
        }

        .hidden {
            display: none;
        }

        /* Enhanced BACK BUTTON DESIGN */
        .injector-tape {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 70px;
            height: 70px;
            background: var(--gradient);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 9999999;
            box-shadow: 0 10px 30px rgba(79, 70, 229, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.7);
            transition: var(--transition);
            animation: tapeFloat 4s ease-in-out infinite;
        }

        @keyframes tapeFloat {
            0%, 100% {
                transform: translateY(0) rotate(0deg);
            }
            50% {
                transform: translateY(-10px) rotate(10deg);
            }
        }

        .injector-tape:hover {
            transform: scale(1.2) rotate(15deg);
            box-shadow: 0 15px 40px rgba(79, 70, 229, 0.6), 0 0 20px rgba(79, 70, 229, 0.5);
            animation: none;
        }

        .injector-tape::before {
            content: "";
            position: absolute;
            width: 24px;
            height: 24px;
            border-left: 3px solid white;
            border-bottom: 3px solid white;
            transform: rotate(45deg);
            margin-top: -3px;
            margin-left: -3px;
        }

        /* Enhanced Floating Particles */
        .particle {
            position: absolute;
            background: rgba(79, 70, 229, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: -1;
            filter: blur(2px);
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% {
                transform: translateY(0) translateX(0) rotate(0deg);
            }
            25% {
                transform: translateY(-30px) translateX(20px) rotate(10deg);
            }
            50% {
                transform: translateY(0) translateX(30px) rotate(0deg);
            }
            75% {
                transform: translateY(30px) translateX(20px) rotate(-10deg);
            }
            100% {
                transform: translateY(0) translateX(0) rotate(0deg);
            }
        }

        /* Enhanced Chat Predictor Styles */
        .chat-container {
            width: 100%;
            height: 100%;
            margin: 0 auto;
            padding: 0;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-light);
            position: relative;
            overflow: hidden;
        }

        .chat-header {
            background: var(--bg-lighter);
            padding: 25px 20px;
            text-align: center;
            border-bottom: 1px solid rgba(79, 70, 229, 0.15);
            position: relative;
            z-index: 10;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }

        .chat-title {
            font-weight: 900;
            font-size: 1.8rem;
            background: var(--gradient);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin: 0;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            font-family: 'El Messiri', sans-serif;
            text-shadow: 0 0 15px rgba(79, 70, 229, 0.3);
        }

        .chat-subtitle {
            font-size: 0.9rem;
            color: var(--text-light);
            margin: 10px 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-family: 'Exo 2', sans-serif;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 25px;
            background-color: var(--bg-light);
            scroll-behavior: smooth;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(79, 70, 229, 0.08) 0%, transparent 50%), 
                radial-gradient(circle at 75% 75%, rgba(99, 102, 241, 0.08) 0%, transparent 50%);
        }

        .message {
            margin-bottom: 25px;
            padding: 18px 22px;
            border-radius: 20px;
            max-width: 85%;
            word-wrap: break-word;
            position: relative;
            animation: fadeIn 0.4s ease;
            font-family: 'Exo 2', sans-serif;
            font-size: 1rem;
            line-height: 1.5;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .received {
            background-color: var(--bg-lighter);
            border-bottom-left-radius: 10px;
            margin-right: auto;
            border: 1px solid rgba(79, 70, 229, 0.2);
            color: var(--text-dark);
        }

        .sent {
            background: var(--gradient);
            color: white;
            border-bottom-right-radius: 10px;
            margin-left: auto;
            box-shadow: 0 5px 15px rgba(79, 70, 229, 0.3);
        }

        .timestamp {
            font-size: 0.75rem;
            color: var(--text-light);
            margin-top: 12px;
            text-align: right;
            opacity: 0.8;
            pointer-events: none;
        }

        .emoji {
            font-size: 1.4em;
            margin-right: 8px;
            display: inline-block;
        }

        .prediction-card {
            background-color: rgba(79, 70, 229, 0.15);
            border-radius: var(--radius);
            padding: 20px;
            margin: 18px 0;
            border: 1px solid rgba(79, 70, 229, 0.3);
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.2);
        }

        .prediction-title {
            font-family: 'Exo 2', sans-serif;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 12px;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .prediction-title i {
            font-size: 1.3rem;
            display: inline-block;
        }

        .prediction-value {
            font-family: 'El Messiri', sans-serif;
            font-size: 2.8rem;
            font-weight: 900;
            margin: 18px 0;
            text-align: center;
            letter-spacing: 1px;
            color: var(--primary);
            text-transform: uppercase;
            text-shadow: 0 0 15px rgba(79, 70, 229, 0.4);
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 8px currentColor;
        }

        .online {
            background-color: var(--win);
        }

        .offline {
            background-color: var(--loss);
        }

        .typing-indicator {
            display: flex;
            padding: 16px 20px;
            background-color: var(--bg-lighter);
            border-radius: 25px;
            width: fit-content;
            margin-bottom: 25px;
            border-bottom-left-radius: 10px;
            align-items: center;
            gap: 12px;
            border: 1px solid rgba(79, 70, 229, 0.2);
        }

        .typing-text {
            font-size: 0.95rem;
            color: var(--text-light);
            font-family: 'Exo 2', sans-serif;
        }

        .typing-dot {
            width: 12px;
            height: 12px;
            background-color: var(--text-light);
            border-radius: 50%;
            animation: typingAnimation 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) {
            animation-delay: 0s;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typingAnimation {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.6;
            }
            30% {
                transform: translateY(-8px);
                opacity: 1;
            }
        }

        .scroll-down-btn {
            position: fixed;
            bottom: 110px;
            right: 30px;
            background: var(--gradient);
            color: white;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(79, 70, 229, 0.3);
            z-index: 100;
            opacity: 0;
            transition: all 0.3s ease;
            border: none;
            outline: none;
        }

        .scroll-down-btn.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .scroll-down-btn:not(.visible) {
            transform: translateY(15px);
        }

        .scroll-down-btn:hover {
            transform: translateY(-5px) scale(1.1);
            box-shadow: 0 10px 30px rgba(79, 70, 229, 0.4);
        }

        .progress-bar {
            height: 10px;
            background-color: rgba(255, 255, 255, 0.15);
            border-radius: 5px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            border-radius: 5px;
            background: var(--gradient);
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(79, 70, 229, 0.5);
        }

        .floating-bg {
            position: absolute;
            width: 400px;
            height: 400px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(79, 70, 229, 0.1) 0%, transparent 70%);
            z-index: 0;
            pointer-events: none;
            animation: pulse 8s infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); opacity: 0.7; }
            to { transform: scale(1.1); opacity: 0.9; }
        }

        .bg-1 {
            top: -150px;
            left: -150px;
        }

        .bg-2 {
            bottom: -100px;
            right: -150px;
        }

        .period-display {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary);
            text-align: center;
            margin: 15px 0;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(79, 70, 229, 0.3);
        }

        .confidence-display {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.85rem;
            color: var(--text-light);
            align-items: center;
        }

        .confidence-value {
            color: var(--primary);
            font-weight: 700;
            text-shadow: 0 0 10px rgba(79, 70, 229, 0.3);
        }

        /* Responsive Adjustments */
        @media (max-width: 1024px) {
            .game-list {
                grid-template-columns: repeat(auto-fill, minmax(270px, 1fr));
            }

            .strategy-grid {
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .logo {
                left: 15px;
                top: 12px;
            }

            .logo-text {
                display: none;
            }

            .tab-system {
                padding-left: 80px;
                height: 65px;
            }

            .content-section {
                top: 65px;
                height: calc(100% - 65px);
            }

            .game-list {
                grid-template-columns: 1fr 1fr;
                gap: 25px;
            }

            .game-selection-title {
                font-size: 36px;
                margin-bottom: 50px;
            }

            .injector-tape {
                width: 60px;
                height: 60px;
                bottom: 25px;
                right: 25px;
            }

            .tab-label {
                font-size: 12px;
            }

            .tab-icon {
                width: 24px;
                height: 24px;
            }

            .tab-icon i {
                font-size: 12px;
            }

            .prediction-value {
                font-size: 2.2rem;
            }

            .history-header,
            .history-item {
                grid-template-columns: 1fr 1fr 1fr;
                padding: 18px;
            }

            .history-value {
                font-size: 15px;
            }

            .history-value-highlight {
                font-size: 18px;
            }

            .strategy-grid {
                grid-template-columns: 1fr;
            }

            .history-controls {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }

            .stats-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 480px) {
            .game-list {
                grid-template-columns: 1fr;
            }

            .game-selection-title {
                font-size: 30px;
                margin-bottom: 40px;
            }

            .injector-tape {
                width: 55px;
                height: 55px;
            }

            .tab-label {
                display: none;
            }

            .tab-icon {
                margin-right: 0;
                width: 28px;
                height: 28px;
            }

            .prediction-value {
                font-size: 2rem;
            }

            .history-header,
            .history-item {
                grid-template-columns: 1fr 1fr;
                padding: 15px 12px;
            }

            .history-header-item:nth-child(3),
            .history-item>div:nth-child(3) {
                display: none;
            }

            .history-value {
                font-size: 14px;
            }

            .history-value-highlight {
                font-size: 16px;
            }

            .history-stats {
                flex-wrap: wrap;
                justify-content: center;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .analysis-card {
                padding: 25px;
            }

            .strategy-card {
                padding: 20px;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>

<body>
    <div class="logo">
        <div class="logo-icon">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M21 16.5c0 .83-.67 1.5-1.5 1.5H4.5c-.83 0-1.5-.67-1.5-1.5v-9c0-.83.67-1.5 1.5-1.5h15c.83 0 1.5.67 1.5 1.5v9zM4.5 20h15c.83 0 1.5-.67 1.5-1.5v-9c0-.83-.67-1.5-1.5-1.5h-15c-.83 0-1.5.67-1.5 1.5v9c0 .83.67 1.5 1.5 1.5zm2.5-6h2v2H7v-2zm4 0h2v2h-2v-2zm-4 4h2v2H7v-2zm4 0h2v2h-2v-2zm4-4h2v2h-2v-2zm-8-4h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2z" />
            </svg>
        </div>
        <div class="logo-text">LICUIS ULTRA V3</div>
    </div>

    <div class="tab-system">
        <div class="tab active" data-tab="web" role="tab" aria-controls="web-section" aria-selected="true">
            <div class="tab-icon"><i class="fas fa-gamepad"></i></div>
            <div class="tab-label">Games</div>
        </div>
        <div class="tab" data-tab="predictor" role="tab" aria-controls="predictor-section" aria-selected="false">
            <div class="tab-icon"><i class="fas fa-brain"></i></div>
            <div class="tab-label">Predictor</div>
        </div>
        <div class="tab" data-tab="history" role="tab" aria-controls="history-section" aria-selected="false">
            <div class="tab-icon"><i class="fas fa-history"></i></div>
            <div class="tab-label">History</div>
        </div>
        <div class="tab" data-tab="analysis" role="tab" aria-controls="analysis-section" aria-selected="false">
            <div class="tab-icon"><i class="fas fa-chart-line"></i></div>
            <div class="tab-label">Analysis</div>
        </div>
    </div>

    <div class="content-section active" id="web-section" role="tabpanel" aria-labelledby="web-tab">
        <div class="game-selection" id="gameSelection">
            <h1 class="game-selection-title" id="gameSelectionTitle">SELECT GAME</h1>
            <div class="game-list-container">
                <div class="game-list">
                    <div class="game-item" data-url="https://bdginf.com/#/login" role="button" tabindex="0">
                        <div class="game-name">BIG DADDY</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="http://Okwin.bio" role="button" tabindex="0">
                        <div class="game-name">OK WIN</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://goagamea.com/#/login" role="button" tabindex="0">
                        <div class="game-name">GOA GAME</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://www.bigmumbaiq.com/#/login" role="button" tabindex="0">
                        <div class="game-name">BIG MUMBAI</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="http://tirangagame.top" role="button" tabindex="0">
                        <div class="game-name">TIRANGA</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://51game5.com/#/" role="button" tabindex="0">
                        <div class="game-name">51 GAME</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://bdgwin.cc/#/login" role="button" tabindex="0">
                        <div class="game-name">BDG WIN</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="http://rajawager.com" role="button" tabindex="0">
                        <div class="game-name">RAJA WAGER</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="http://55club.game" role="button" tabindex="0">
                        <div class="game-name">55 CLUB</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://bharatclub.net/#/login" role="button" tabindex="0">
                        <div class="game-name">BHARAT CLUB</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://www.diuwin8.com/#/" role="button" tabindex="0">
                        <div class="game-name">DIUWIN</div>
                        <div class="game-url"></div>
                    </div>
                    <div class="game-item" data-url="https://www.aatclub.com/#/" role="button" tabindex="0">
                        <div class="game-name">91 CLUB</div>
                        <div class="game-url"></div>
                    </div>
                </div>
            </div>
        </div>

        <iframe id="gameFrame" class="fullscreen-iframe hidden" allowfullscreen aria-label="Game Window"></iframe>

        <button class="injector-tape hidden" id="injectorTape" aria-label="Go Back to Game Selection"></button>
    </div>

    <div class="content-section" id="predictor-section" role="tabpanel" aria-labelledby="predictor-tab">
        <div class="chat-container">
            <div class="floating-bg bg-1"></div>
            <div class="floating-bg bg-2"></div>

            <div class="chat-header">
                <h1 class="chat-title">LICUIS ULTRA</h1>
                <p class="chat-subtitle">
                    <span class="status-indicator online"></span>
                    <span id="connection-status">Connected to Server</span>
                    • <span id="current-time">00:00:00</span>
                    • <span id="prediction-speed">0ms</span>
                </p>
            </div>

            <div class="messages-container" id="messages-container">
                <div class="message received">
                    <div class="prediction-title"><i class="fas fa-robot"></i> SYSTEM INITIALIZED</div>
                    <p>Welcome to <strong>LICUIS ULTRA V3</strong>, now powered by the Advanced AI models are analyzing game patterns in real-time to provide you with the most accurate predictions.</p>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 100%"></div>
                    </div>
                    <div class="timestamp" id="last-update-time">Just now</div>
                </div>

                <div class="typing-indicator" id="typing-indicator">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <span class="typing-text">Initializing AI models...</span>
                </div>
            </div>

            <button class="scroll-down-btn" id="scroll-down-btn" aria-label="Scroll to bottom">
                <i class="fas fa-chevron-down"></i>
            </button>
        </div>
    </div>

    <div class="content-section" id="history-section" role="tabpanel" aria-labelledby="history-tab">
        <div class="history-container">
            <div class="history-title">
                <i class="fas fa-history"></i> GAME HISTORY
            </div>
            <div class="history-controls">
                <div class="history-filter">
                    <button class="filter-btn active" data-filter="all"><i class="fas fa-layer-group"></i> All</button>
                    <button class="filter-btn" data-filter="big"><i class="fas fa-arrow-up"></i> Big</button>
                    <button class="filter-btn" data-filter="small"><i class="fas fa-arrow-down"></i> Small</button>
                    <button class="filter-btn" data-filter="red"><i class="fas fa-circle" style="color: #ef4444;"></i> Red</button>
                    <button class="filter-btn" data-filter="green"><i class="fas fa-circle" style="color: #10b981;"></i> Green</button>
                </div>
                <div class="history-stats">
                    <div class="stat-badge"><i class="fas fa-database"></i> <span id="total-count">0</span></div>
                </div>
            </div>
            <div class="history-content" id="historyContent">
                <div class="loading-container">
                    <i class="fas fa-spinner fa-spin"></i>
                    <div>LOADING DATA...</div>
                </div>
            </div>
            <div class="history-pagination" id="historyPagination">
                <button class="pagination-btn disabled" id="prevPage" aria-label="Previous Page"><i class="fas fa-chevron-left"></i></button>
                <button class="pagination-btn active">1</button>
                <button class="pagination-btn">2</button>
                <button class="pagination-btn">3</button>
                <button class="pagination-btn" id="nextPage" aria-label="Next Page"><i class="fas fa-chevron-right"></i></button>
            </div>
        </div>
    </div>

    <div class="content-section" id="analysis-section" role="tabpanel" aria-labelledby="analysis-tab">
        <div class="analysis-container">
            <div class="analysis-card">
                <div class="analysis-title">
                    <i class="fas fa-chart-pie"></i> ADVANCED ANALYSIS
                </div>
                <div id="advancedAnalysis">
                    <div class="loading-container">
                        <i class="fas fa-spinner fa-spin"></i>
                        <div>ANALYZING DATA PATTERNS...</div>
                    </div>
                </div>
            </div>

            <div class="analysis-card">
                <div class="analysis-title">
                    <i class="fas fa-brain"></i> ACTIVE STRATEGIES
                </div>
                <div class="strategy-grid" id="strategiesContainer">
                </div>
            </div>
        </div>
    </div>
   
<script>
// 🔮 LICUIS ULTRA V3: INFINITY-CORE PREDICTION ENGINE 10.1 (Enhanced & Accurate)
// FIXED: ELIMINATED BIG BIAS IN STUB MODELS AND REFINED CONFIDENCE SCORING.

"use strict";

// =================================================================================
// === NEW PREDITION LOGIC (AIPredictionSystem) START ===
// The new system is designed to be more robust, especially for loss recovery.
// =================================================================================

class AIPredictionSystem {
    constructor() {
        this.history = []; // Array of numbers (e.g., [8, 2, 5, 1, ...])
        this.patterns = {};
        this.consecutiveWins = 0;
        this.consecutiveLosses = 0;
        this.lastPrediction = null; // BIG/SMALL
        this.lastActual = null;     // Number (0-9)
        this.lastPredictionAccuracy = null;
        
        // Enhanced tracking for loss recovery
        this.lossStreakThreshold = 2;
        this.adaptiveConfidence = true;
        this.predictionHistory = []; // Stores objects {prediction, actual, wasCorrect, ...}
    }

    // SIMULATED: Fetches and updates history, keeping it at max 100 items.
    async fetchGameResults(limit = 100) {
        // In the full environment, this would be a live API call.
        // Keeping it simulated for the class definition purity.
        const simulatedResults = Array.from({length: limit}, 
            () => Math.floor(Math.random() * 10));
        
        // Simulating the history update
        this.history = [...simulatedResults.reverse(), ...this.history]
            .slice(0, 100);
        
        return this.history;
    }

    /**
     * Updates the internal performance tracking.
     * @param {string} prediction - The size predicted ('BIG' or 'SMALL').
     * @param {number|string} actual - The actual result (number 0-9 or 'BIG'/'SMALL').
     * @returns {boolean} - True if the prediction was correct.
     */
    updatePredictionAccuracy(prediction, actual) {
        const actualNumber = typeof actual === 'string' ? 
            (actual === 'BIG' ? 7 : 2) : actual; // Convert BIG/SMALL to a representative number if needed
        
        this.lastPrediction = prediction;
        this.lastActual = actualNumber;
        
        const wasCorrect = (
            (prediction === 'BIG' && actualNumber >= 5) || 
            (prediction === 'SMALL' && actualNumber < 5)
        );
        
        this.lastPredictionAccuracy = wasCorrect;
        
        if (wasCorrect) {
            this.consecutiveWins++;
            this.consecutiveLosses = 0;
        } else {
            this.consecutiveLosses++;
            this.consecutiveWins = 0;
        }

        // Store prediction for analysis
        this.predictionHistory.push({
            prediction,
            actual: actualNumber,
            wasCorrect,
            timestamp: Date.now()
        });

        // Keep only last 50 predictions
        if (this.predictionHistory.length > 50) {
            this.predictionHistory.shift();
        }
        
        return wasCorrect;
    }

    updatePatternAnalysis() {
        // Simple pattern detection for the AIPredictionSystem internal use
        if (this.history.length < 6) return;
        
        for (let len = 3; len <= 5; len++) {
            if (this.history.length < len * 2) continue;
            
            const recentPattern = this.history.slice(0, len);
            let occurrences = [];
            
            for (let i = len; i < this.history.length - len; i++) {
                const currentWindow = this.history.slice(i, i + len);
                if (JSON.stringify(currentWindow) === JSON.stringify(recentPattern)) {
                    occurrences.push(this.history[i + len]);
                }
            }
            
            if (occurrences.length > 0) {
                const freqDist = {};
                occurrences.forEach(num => {
                    freqDist[num] = (freqDist[num] || 0) + 1;
                });
                
                for (const num in freqDist) {
                    const confidence = freqDist[num] / occurrences.length;
                    if (confidence >= 0.75) {
                        this.patterns[JSON.stringify(recentPattern)] = {
                            number: parseInt(num),
                            confidence: confidence
                        };
                    }
                }
            }
        }
    }

    /**
     * Core prediction logic including loss recovery.
     */
    enhancedPredictionAlgorithm(lastResults, currentSecond) {
        const results = lastResults.map(n => parseInt(n, 10));
        const bigCount = results.filter(n => n >= 5).length;
        const smallCount = results.length - bigCount;
        
        const lastThree = results.slice(0, 3);
        const lastFive = results.slice(0, 5);
        
        const timeBias = currentSecond < 30 ? "SMALL" : "BIG";
        
        let finalPrediction = null;
        let confidence = 77;

        // 1. Strong Trend Detection with adaptive thresholds
        const trendThreshold = this.consecutiveLosses > 0 ? 6 : 7;
        if (bigCount >= trendThreshold) {
            finalPrediction = "SMALL";
            confidence = 85 + Math.min(10, this.consecutiveLosses * 2);
        } else if (smallCount >= trendThreshold) {
            finalPrediction = "BIG";
            confidence = 85 + Math.min(10, this.consecutiveLosses * 2);
        }
        
        // 2. Enhanced Pattern Detection with loss consideration
        if (!finalPrediction) {
            // Check for streaks and patterns
            if (lastThree[0] === lastThree[1] && lastThree[1] === lastThree[2]) {
                // If we're in a loss streak, be more aggressive with pattern breaks
                if (this.consecutiveLosses >= 2) {
                    finalPrediction = lastThree[0] >= 5 ? "SMALL" : "BIG";
                    confidence = 90;
                } else {
                    finalPrediction = lastThree[0] >= 5 ? "SMALL" : "BIG";
                    confidence = 80;
                }
            }
            // Enhanced 4-of-5 detection
            else if (lastFive.filter(n => n >= 5).length >= 4) {
                finalPrediction = "SMALL";
                confidence = 75 + (this.consecutiveLosses * 3);
            } else if (lastFive.filter(n => n < 5).length >= 4) {
                finalPrediction = "BIG";
                confidence = 75 + (this.consecutiveLosses * 3);
            }
        }

        // 3. Advanced Loss Recovery System
        if (this.consecutiveLosses >= this.lossStreakThreshold) {
            // Revert the prediction for loss mitigation
            if (finalPrediction) {
                // Reverse the prediction with boosted confidence
                finalPrediction = finalPrediction === 'BIG' ? 'SMALL' : 'BIG';
                confidence = Math.min(95, 85 + (this.consecutiveLosses * 5));
            } else {
                // Aggressive time-based reversal
                finalPrediction = timeBias === 'BIG' ? 'SMALL' : 'BIG';
                confidence = 90 + (this.consecutiveLosses * 3);
            }
            
            // Additional pattern analysis for loss recovery
            const recentPattern = this.analyzeLossRecoveryPattern();
            if (recentPattern.prediction) {
                finalPrediction = recentPattern.prediction;
                confidence = Math.max(confidence, recentPattern.confidence);
            }
        }
        
        // 4. Fallback with enhanced logic
        if (!finalPrediction) {
            // Use weighted probability based on recent performance
            const performanceWeight = this.calculatePerformanceWeight();
            if (performanceWeight > 0.6) {
                finalPrediction = timeBias;
            } else {
                // If performance is poor, try opposite approach
                finalPrediction = timeBias === 'BIG' ? 'SMALL' : 'BIG';
            }
            confidence = 85;
        }

        // 5. Confidence adjustment based on recent performance
        if (this.adaptiveConfidence) {
            const performanceFactor = this.calculatePerformanceFactor();
            confidence = Math.min(95, Math.max(60, confidence * performanceFactor));
            
            // Boost confidence during loss streaks for recovery
            if (this.consecutiveLosses > 0) {
                confidence = Math.min(95, confidence + (this.consecutiveLosses * 2));
            }
        }

        const predictedNumbers = this.getRandomNumbers(finalPrediction, Math.random() > 0.5 ? 1 : 2);
        
        return {
            prediction: finalPrediction,
            confidence: Math.round(confidence),
            numbers: predictedNumbers,
            lossRecoveryActive: this.consecutiveLosses >= this.lossStreakThreshold,
            streakLength: this.consecutiveLosses
        };
    }

    // New: Analyze patterns specifically for loss recovery
    analyzeLossRecoveryPattern() {
        if (this.predictionHistory.length < 5) return { prediction: null, confidence: 0 };
        
        const recentPredictions = this.predictionHistory.slice(-5);
        const lossCount = recentPredictions.filter(p => !p.wasCorrect).length;
        
        if (lossCount >= 3) {
            // If majority of recent predictions are wrong, try complete reversal
            const lastPrediction = recentPredictions[recentPredictions.length - 1].prediction;
            return {
                prediction: lastPrediction === 'BIG' ? 'SMALL' : 'BIG',
                confidence: 85
            };
        }
        
        return { prediction: null, confidence: 0 };
    }

    // New: Calculate performance weight for decision making
    calculatePerformanceWeight() {
        if (this.predictionHistory.length < 10) return 0.5;
        
        const recentHistory = this.predictionHistory.slice(-10);
        const correctPredictions = recentHistory.filter(p => p.wasCorrect).length;
        return correctPredictions / 10;
    }

    // New: Calculate performance factor for confidence adjustment
    calculatePerformanceFactor() {
        if (this.predictionHistory.length < 5) return 1.0;
        
        const recentHistory = this.predictionHistory.slice(-5);
        const correctPredictions = recentHistory.filter(p => p.wasCorrect).length;
        const accuracy = correctPredictions / 5;
        
        if (accuracy >= 0.8) return 1.2;    // Boost confidence when performing well
        if (accuracy >= 0.6) return 1.1;    // Slight boost
        if (accuracy >= 0.4) return 1.0;    // Neutral
        if (accuracy >= 0.2) return 0.9;    // Reduce confidence
        return 0.8;                         // Significant reduction
    }

    getRandomNumbers(prediction, count) {
        const numbers = [];
        
        if (prediction === 'BIG') {
            for (let i = 0; i < count; i++) {
                numbers.push(Math.floor(Math.random() * 5) + 5);
            }
        } else {
            for (let i = 0; i < count; i++) {
                numbers.push(Math.floor(Math.random() * 5));
            }
        }
        
        return numbers;
    }

    /**
     * Enhanced prediction method with loss recovery
     * @returns {object} - The prediction details.
     */
    async predict() {
        if (this.history.length < 10) {
            // Note: In a live environment, this should wait for external data.
            // For now, we rely on the external caller to populate history.
            if (this.history.length === 0) {
                // Fallback to simulated data if no history provided
                await this.fetchGameResults(10); 
            }
        }
        
        this.updatePatternAnalysis();
        
        const currentSecond = new Date().getSeconds();
        // Use the most recent 10 results from the history
        const lastTenResults = this.history.slice(0, 10);
        
        const prediction = this.enhancedPredictionAlgorithm(lastTenResults, currentSecond);
        
        return prediction;
    }

    // Method to reset streaks (use cautiously)
    resetStreaks() {
        this.consecutiveWins = 0;
        this.consecutiveLosses = 0;
    }

    // Get performance statistics
    getPerformanceStats() {
        const total = this.predictionHistory.length;
        const wins = this.predictionHistory.filter(p => p.wasCorrect).length;
        const accuracy = total > 0 ? (wins / total) * 100 : 0;
        
        return {
            totalPredictions: total,
            wins: wins,
            losses: total - wins,
            accuracy: accuracy.toFixed(1),
            currentStreak: this.consecutiveWins > 0 ? `W${this.consecutiveWins}` : `L${this.consecutiveLosses}`,
            bestWinStreak: this.calculateBestStreak(true),
            worstLossStreak: this.calculateBestStreak(false)
        };
    }

    // Calculate best streaks
    calculateBestStreak(isWinStreak) {
        let currentStreak = 0;
        let bestStreak = 0;
        
        for (const prediction of this.predictionHistory) {
            if (prediction.wasCorrect === isWinStreak) {
                currentStreak++;
                bestStreak = Math.max(bestStreak, currentStreak);
            } else {
                currentStreak = 0;
            }
        }
        
        return bestStreak;
    }
}

/**
 * Replacement for the original InfinityCoreAI class, using the new AIPredictionSystem.
 * This class serves as the interface for the AIPredictionSystem to the rest of the application.
 */
class EnhancedInfinityCoreAI {
    constructor() {
        this.predictionSystem = new AIPredictionSystem();
        this.advancedMode = true;

        // Properties needed for compatibility with the old script's tracking logic
        this.lastPrediction = null; // Stored here for compatibility with updatePredictions() in the main script
        this.lastActual = null;     // Stored here for compatibility
        this.consecutiveLosses = 0; // Stored here for compatibility
        this.consecutiveWins = 0;   // Stored here for compatibility
        this.history = [];          // Stored here for compatibility
        this.strategy = 'enhanced_recovery'; // Dummy for compatibility
        this.learningRate = 0.95;   // Dummy for compatibility
        this.models = {};           // Dummy for compatibility
        this.modelPerformance = {}; // Dummy for compatibility
    }

    /**
     * Generates a prediction, fulfilling the interface of the original InfinityCoreAI.
     * @param {Array<object>} history - The game history from the external caller.
     * @returns {Promise<object>} - The prediction result.
     */
    async generatePrediction(history) {
        if (!history || history.length === 0) {
            return {
                size: "BIG",
                confidence: 50,
                insufficientData: true
            };
        }

        // Convert history format to simple numbers array
        const numbers = history.map(item => 
            typeof item === 'object' ? parseInt(item.number, 10) : parseInt(item, 10)
        ).filter(n => !isNaN(n));

        // Update the prediction system history
        this.predictionSystem.history = numbers.slice(0, 100);
        this.history = this.predictionSystem.history; // Update compatibility history

        // Generate prediction
        const prediction = await this.predictionSystem.predict();

        // Update compatibility properties
        this.lastPrediction = prediction.prediction;
        this.consecutiveLosses = prediction.streakLength;

        return {
            size: prediction.prediction,
            confidence: prediction.confidence.toFixed(2),
            lossRecoveryActive: prediction.lossRecoveryActive,
            streakLength: prediction.streakLength
        };
    }

    /**
     * Updates the internal model performance based on the actual result.
     * This method is the core replacement for the original infinityCoreAI.updateModelPerformance.
     * @param {string} actualSize - The actual result ('BIG' or 'SMALL').
     */
    updateModelPerformance(actualSize) {
        if (!this.lastPrediction) return;

        // The actual result should be a number (0-9) for the new system's logic
        const actualNumber = actualSize === 'BIG' ? 7 : 2; 

        const wasCorrect = this.predictionSystem.updatePredictionAccuracy(this.lastPrediction, actualNumber);

        // Update compatibility properties
        this.lastActual = actualSize;
        this.consecutiveLosses = this.predictionSystem.consecutiveLosses;
        this.consecutiveWins = this.predictionSystem.consecutiveWins;
    }

    // Compatibility stubs
    getModelPerformance() { return this.modelPerformance; }
    setAggressiveness() {}
    setStrategy(strategy) { this.strategy = strategy; }
    setDeepLearning() {}
    setAdaptiveModels() {}
    getLearningRate() { return this.learningRate; }
}

/**
 * The new EnhancedOppositePredictor class that uses the EnhancedInfinityCoreAI.
 * This replaces the original class definition.
 */
class EnhancedOppositePredictor {
    constructor() {
        // Replace old InfinityCoreAI with the new, enhanced version
        this.infinityAI = new EnhancedInfinityCoreAI();
        this.history = [];
        this.predictionLog = [];
        this.consecutiveLosses = 0;
        this.consecutiveWins = 0;
        
        // Dummy properties for compatibility with the script's original methods
        this.patternWeights = {};
        this.safetyThresholds = {};
        this.mode = 'normal';
    }

    // --- Helper Methods (Stubs to avoid errors) ---
    analyzePatterns() { return {}; }
    assessSafety() { return { score: 'green', flags: [], volatility: 0, entropy: 0 }; }
    updatePatternWeights() {}
    calculateWMA() { return 0.5; }
    calculateMomentum() { return 50; }
    calculateFrequency() { return { bigRatio: 0.5, smallRatio: 0.5 }; }
    detectMicroPattern() { return 'B'; }
    calculateVolatility() { return 0; }
    calculateEntropy() { return 0.5; }
    detectClusterBias() { return 0; }
    generateRandomDirect() {
        const randomPred = Math.random() > 0.5 ? 'BIG' : 'SMALL';
        return {
            displayedPrediction: randomPred,
            displayedConfidence: 50 + Math.random() * 10,
            internalPrediction: randomPred,
            internalConfidence: 0.5,
            mode: 'random',
            timestamp: Date.now()
        };
    }
    // --- END Helper Methods (Stubs) ---

    /**
     * Main prediction logic, now using the EnhancedInfinityCoreAI.
     * @param {Array<object>} history - The game history.
     * @returns {Promise<object>} - The final prediction output.
     */
    async generateOppositePrediction(history) {
        if (history.length < 5) {
            return this.generateRandomDirect();
        }

        this.history = history;

        // Step 1: Get internal prediction from EnhancedInfinityCoreAI (which wraps AIPredictionSystem)
        const infinityPred = await this.infinityAI.generatePrediction(history);
        
        // Use the direct prediction from Infinity-Core
        const finalPrediction = infinityPred.size;
        const finalConfidence = infinityPred.confidence;
        
        // Step 2: Determine mode based on new system's state
        const mode = infinityPred.lossRecoveryActive ? 'lossRecovery' : 
                     (parseFloat(finalConfidence) >= 90 ? 'sureShot' : 'normal');

        const finalOutput = {
            // DISPLAYED PREDICTION (NOW DIRECT)
            displayedPrediction: finalPrediction,
            displayedConfidence: finalConfidence,
            
            // INTERNAL TRACKING (NOW MATCHES DISPLAYED)
            internalPrediction: finalPrediction,
            internalConfidence: finalConfidence,
            
            // METADATA
            mode: mode,
            safety: 'green', // Simplified for the new system
            patterns: ['EnhancedRecovery'],
            timestamp: Date.now()
        };

        this.predictionLog.push(finalOutput);
        return finalOutput;
    }

    /**
     * The script's original updateReinforcement method, adapted for the new system.
     * Note: The core win/loss tracking is now handled inside the EnhancedInfinityCoreAI.
     * @param {string} actualResult - The actual game result ('BIG' or 'SMALL').
     */
    updateReinforcement(actualResult) {
        if (this.predictionLog.length === 0) return;

        // The core performance update is delegated to the new AI system.
        // This will update the internal streaks (consecutiveLosses/Wins) in the AIPredictionSystem.
        this.infinityAI.updateModelPerformance(actualResult);

        // Update the top-level predictor's streak trackers for compatibility with the original logic.
        this.consecutiveLosses = this.infinityAI.consecutiveLosses;
        this.consecutiveWins = this.infinityAI.consecutiveWins;

        // Update the top-level mode based on the new system's state
        if (this.consecutiveLosses >= 2) {
            this.mode = 'sureShot';
        } else if (this.consecutiveLosses === 1) {
            this.mode = 'cautious';
        } else {
            this.mode = 'normal';
        }
    }
}

// =================================================================================
// === NEW PREDITION LOGIC (AIPredictionSystem) END ===
// =================================================================================

// --- Utility function re-definitions for safety ---
const getBigSmallOutcome = (num) => (num >= 5) ? 'BIG' : 'SMALL';
const getRedGreenOutcome = (num) => (num % 2 === 0) ? 'RED' : 'GREEN';

// Enhanced initialization with new direct prediction focus
// This replaces the original initialization of the predictor
const enhancedPredictor = new EnhancedOppositePredictor();

// Initialize the Infinity-Core AI prediction system
// Use the internal instance of the *new* EnhancedInfinityCoreAI
const infinityCoreAI = enhancedPredictor.infinityAI;

// --- Remaining unchanged script logic ---
document.addEventListener('DOMContentLoaded', function() {
    const tabs = document.querySelectorAll('.tab');
    const contentSections = document.querySelectorAll('.content-section');
    tabs.forEach(tab => {
        tab.addEventListener('click', function() {
            const tabId = this.getAttribute('data-tab');
            tabs.forEach(t => {
                t.classList.remove('active');
                t.setAttribute('aria-selected', 'false');
            });
            this.classList.add('active');
            this.setAttribute('aria-selected', 'true');
            contentSections.forEach(section => {
                section.classList.remove('active');
                if (section.id === `${tabId}-section`) {
                    section.classList.add('active');
                    if (tabId === 'history') {
                        fetchData();
                    } else if (tabId === 'analysis') {
                        performAdvancedAnalysis();
                        displayAllStrategies();
                    }
                }
            });
        });
    });

    const gameSelection = document.getElementById('gameSelection');
    const gameFrame = document.getElementById('gameFrame');
    const gameItems = document.querySelectorAll('.game-item');
    const injectorTape = document.getElementById('injectorTape');
    gameItems.forEach(item => {
        item.addEventListener('click', function() {
            const gameUrl = this.getAttribute('data-url');
            gameFrame.src = gameUrl;
            gameSelection.style.display = 'none';
            gameFrame.classList.remove('hidden');
            injectorTape.classList.remove('hidden');
            this.classList.add('active');
            setTimeout(() => this.classList.remove('active'), 500);
        });
    });

    injectorTape.addEventListener('click', function() {
        gameFrame.classList.add('hidden');
        gameSelection.style.display = "flex";
        injectorTape.classList.add('hidden');
        gameFrame.src = '';
    });

    function createParticles() {
        const colors = ['rgba(37, 99, 235, 0.25)', 'rgba(59, 130, 246, 0.25)', ' rgba(96, 165, 250, 0.25)'];
        for (let i = 0; i < 20; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            const size = Math.random() * 10 + 3;
            const posX = Math.random() * window.innerWidth;
            const posY = Math.random() * window.innerHeight;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const duration = Math.random() * 20 + 10;
            const delay = Math.random() * 5;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.left = `${posX}px`;
            particle.style.top = `${posY}px`;
            particle.style.background = color;
            particle.style.opacity = Math.random() * 0.5 + 0.1;
            particle.style.animationDuration = `${duration}s`;
            particle.style.animationDelay = `${delay}s`;
            document.body.appendChild(particle);
        }
    }

    const filterButtons = document.querySelectorAll('.filter-btn');
    filterButtons.forEach(button => {
        button.addEventListener('click', function() {
            const filter = this.getAttribute('data-filter');
            filterButtons.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            const historyItems = document.querySelectorAll('.history-item');
            historyItems.forEach(item => {
                if (filter === 'all') {
                    item.style.display = 'grid';
                } else {
                    const isBig = item.querySelector('.history-value-highlight').textContent >= 5;
                    const isRed = item.querySelector('.color-dot').classList.contains('color-red');
                    if ((filter === 'big' && isBig) || (filter === 'small' && !isBig) || (filter === 'red' && isRed) || (filter === 'green' && !isRed)) {
                        item.style.display = 'grid';
                    } else {
                        item.style.display = 'none';
                    }
                }
            });
        });
    });

// Fetch data for history tab
async function fetchData() {
    try {
        const historyContent = document.getElementById('historyContent');
        if (!historyContent) return;

        historyContent.innerHTML = '<div class="loading-container"><i class="fas fa-spinner fa-spin"></i> LOADING DATA...</div>';

        const timestamp = Date.now();
        const response = await fetch(`https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json?ts=${timestamp}&pageSize=10`);

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data && data.data && data.data.list && data.data.list.length > 0) {
            displayHistory(data.data.list);
        } else {
            historyContent.innerHTML = '<div class="no-data-container"><i class="fas fa-info-circle"></i> NO DATA AVAILABLE</div>';
        }
    } catch (error) {
        console.error('Error fetching data:', error);
        const historyContent = document.getElementById('historyContent');
        if (historyContent) {
            historyContent.innerHTML = '<div class="error-container"><i class="fas fa-exclamation-triangle"></i> ERROR LOADING DATA</div>';
        }
    }
}

// Display history data
function displayHistory(data) {
    const historyContent = document.getElementById('historyContent');
    if (!historyContent) return;

    if (!data || data.length === 0) {
        historyContent.innerHTML = '<div class="no-data-container"><i class="fas fa-info-circle"></i> NO DATA AVAILABLE</div>';
        return;
    }

    let html = '<div class="history-header">';
    html += '<div class="history-header-item"></div>';
    html += '<div class="history-header-item"></div>';
    html += '<div class="history-header-item"></div>';
    html += '<div class="history-header-item"></div>';
    html += '</div>';

    let totalCount = 0;

    data.forEach(item => {
        const sum = parseInt(item.premium || item.result || item.number || 0);
        const bigSmall = getBigSmallOutcome(sum);
        const isEven = sum % 2 === 0;
        const redGreen = isEven ? 'RED' : 'GREEN';
        const colorClass = isEven ? 'color-red' : 'color-green';

        totalCount++;

        html += `
            <div class="history-item">
                <div>
                    <div class="history-value">${item.issueNumber || item.period || 'N/A'}</div>
                </div>
                <div>
                    <div class="history-value-highlight">${sum}</div>
                </div>
                <div>
                    <div class="history-value">${bigSmall}</div>
                </div>
                <div>
                    <div class="history-value">
                        <span class="color-dot ${colorClass}"></span>${redGreen}
                    </div>
                </div>
            </div>
        `;
    });

    // Update total count
    document.getElementById('total-count').textContent = totalCount;

    historyContent.innerHTML = html;
}

// Perform advanced analysis
async function performAdvancedAnalysis() {
    try {
        const analysisContent = document.getElementById('advancedAnalysis');
        if (!analysisContent) return;

        analysisContent.innerHTML = '<div class="loading-container"><i class="fas fa-spinner fa-spin"></i> ANALYZING DATA PATTERNS...</div>';

        const timestamp = Date.now();
        const response = await fetch(`https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json?ts=${timestamp}&pageSize=50`);

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data && data.data && data.data.list && data.data.list.length > 0) {
            displayAdvancedAnalysis(data.data.list);
        } else {
            analysisContent.innerHTML = '<div class="no-data-container"><i class="fas fa-info-circle"></i> NO DATA AVAILABLE FOR ANALYSIS</div>';
        }
    } catch (error) {
        console.error('Error fetching analysis data:', error);
        const analysisContent = document.getElementById('advancedAnalysis');
        if (analysisContent) {
            analysisContent.innerHTML = '<div class="error-container"><i class="fas fa-exclamation-triangle"></i> ERROR LOADING ANALYSIS DATA</div>';
        }
    }
}

// Display advanced analysis
function displayAdvancedAnalysis(data) {
    const analysisContent = document.getElementById('advancedAnalysis');
    if (!analysisContent) return;

    if (!data || data.length === 0) {
        analysisContent.innerHTML = '<div class="no-data-container"><i class="fas fa-info-circle"></i> NO DATA AVAILABLE FOR ANALYSIS</div>';
        return;
    }

    // Process data for analysis
    const numbers = data.map(item => parseInt(item.premium || item.result || item.number || 0));

    // Calculate statistics
    const bigCount = numbers.filter(n => n >= 5).length;
    const smallCount = numbers.length - bigCount;
    const redCount = numbers.filter(n => n % 2 === 0).length;
    const greenCount = numbers.length - redCount;

    // Find most common numbers
    const frequency = {};
    numbers.forEach(n => {
        frequency[n] = (frequency[n] || 0) + 1;
    });

    const mostFrequent = Object.entries(frequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([num, count]) => ({
            number: num,
            count
        }));

    // Check for recent patterns
    const recentPatterns = detectPatterns(numbers.slice(0, 10));

    let html = `
        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-value">${numbers.length}</div>
                <div class="stat-label">Total Results</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">${bigCount}</div>
                <div class="stat-label">Big Results</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">${smallCount}</div>
                <div class="stat-label">Small Results</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">${Math.round((bigCount/numbers.length)*100)}%</div>
                <div class="stat-label">Big Frequency</div>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-value">${redCount}</div>
                <div class="stat-label">Red Results</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">${greenCount}</div>
                <div class="stat-label">Green Results</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">${Math.round((redCount/numbers.length)*100)}%</div>
                <div class="stat-label">Red Frequency</div>
            </div>
        </div>

        <div class="analysis-title">
            <i class="fas fa-star"></i> MOST FREQUENT NUMBERS
        </div>
        <div class="pattern-list">
    `;

    mostFrequent.forEach(item => {
        html += `
            <div class="pattern-item">
                <span class="pattern-value">Number ${item.number}</span>
                <span class="pattern-confidence">${item.count} times (${Math.round((item.count/numbers.length)*100)}%)</span>
            </div>
        `;
    });

    html += `</div>`;

    if (recentPatterns.length > 0) {
        html += `
            <div class="analysis-title">
                <i class="fas fa-project-diagram"></i> DETECTED PATTERNS
            </div>
            <div class="pattern-list">
        `;

        recentPatterns.forEach(pattern => {
            html += `
                <div class="pattern-item">
                    <span class="pattern-value">${pattern.pattern}</span>
                    <span class="pattern-confidence">${pattern.count} occurrences</span>
                </div>
            `;
        });

        html += `</div>`;
    }

    // Add pattern analysis from InfinityCoreAI - Using the new system's stats for display
    const stats = infinityCoreAI.predictionSystem.getPerformanceStats();

    html += `
        <div class="analysis-title">
            <i class="fas fa-chart-line"></i> INFINITY-CORE ANALYSIS (v3)
        </div>
        <div class="pattern-analysis">
            <div class="pattern-item">
                <span class="pattern-value">Total Predictions</span>
                <span class="pattern-count">${stats.totalPredictions}</span>
            </div>
            <div class="pattern-item">
                <span class="pattern-value">Overall Accuracy</span>
                <span class="pattern-count">${stats.accuracy}%</span>
            </div>
            <div class="pattern-item">
                <span class="pattern-value">Current Streak</span>
                <span class="pattern-count">${stats.currentStreak}</span>
            </div>
            <div class="pattern-item">
                <span class="pattern-value">Worst Loss Streak</span>
                <span class="pattern-count">L${stats.worstLossStreak}</span>
            </div>
            <div class="pattern-item">
                <span class="pattern-value">Recovery Threshold</span>
                <span class="pattern-count">${infinityCoreAI.predictionSystem.lossStreakThreshold} losses</span>
            </div>
            <div class="pattern-item">
                <span class="pattern-value">System Mode</span>
                <span class="pattern-count">${enhancedPredictor.mode}</span>
            </div>
        </div>
    `;

    analysisContent.innerHTML = html;
}

// Detect patterns in number sequences
function detectPatterns(numbers) {
    const patterns = [];
    const sequence = numbers.join('');

    // Check for repeating patterns of length 2-3
    for (let len = 2; len <= 3; len++) {
        for (let i = 0; i <= sequence.length - len; i++) {
            const pattern = sequence.substring(i, i + len);
            let count = 0;
            let pos = -1;

            // Count occurrences of this pattern
            while ((pos = sequence.indexOf(pattern, pos + 1)) !== -1) {
                count++;
            }

            if (count > 1) {
                patterns.push({
                    pattern: pattern.split('').join(' - '),
                    count: count
                });
            }
        }
    }

    // Remove duplicates and sort by count
    const uniquePatterns = [];
    patterns.forEach(p => {
        const existing = uniquePatterns.find(up => up.pattern === p.pattern);
        if (!existing) {
            uniquePatterns.push(p);
        }
    });

    return uniquePatterns.sort((a, b) => b.count - a.count).slice(0, 5);
}

// Display all strategies
function displayAllStrategies() {
    const strategiesContainer = document.getElementById('strategiesContainer');
    if (!strategiesContainer) return;

    const strategies = [{
        title: "AIPredictionSystem (New Core)",
        icon: "fas fa-microchip",
        description: "Adaptive AI with enhanced loss recovery logic, dynamic confidence, and pattern-based reversal."
    }, {
        title: "Loss Recovery Hybrid (Adaptive)",
        icon: "fas fa-crosshairs",
        description: "High-confidence strategy that aggressively reverses the prediction after a set loss streak."
    }, {
        title: "Enhanced Pattern Breaker",
        icon: "fas fa-compress-arrows-alt",
        description: "Aggressive pattern detection that predicts the break of streaks and simple repeats with high confidence."
    }, {
        title: "Adaptive Confidence Scaling",
        icon: "fas fa-chart-bar",
        description: "Confidence scores are dynamically boosted or reduced based on the system's real-time accuracy and loss streak."
    }, {
        title: "Micro-Trend Reversal",
        icon: "fas fa-exchange-alt",
        description: "Uses a low-latency lookback to identify and predict the immediate reversal of small trends."
    }, {
        title: "Time-Based Bias Check",
        icon: "fas fa-clock",
        description: "Implements a secondary bias based on the time of the round, acting as a tie-breaker."
    }];

    let html = '';
    strategies.forEach(strategy => {
        html += `
            <div class="strategy-card">
                <div class="strategy-title">
                    <i class="${strategy.icon}"></i>
                    ${strategy.title}
                </div>
                <div class="strategy-description">
                    ${strategy.description}
                </div>
            </div>
        `;
    });

    strategiesContainer.innerHTML = html;
}

// Chat Predictor Logic
let previousResults = [];
let latestPeriod = null;
let currentPrediction = null;
let serverOnline = true;
let lastPredictionPeriod = null;
let lastActualNumber = null;

// DOM elements
const messagesContainer = document.getElementById('messages-container');
const typingIndicator = document.getElementById('typing-indicator');
const connectionStatus = document.getElementById('connection-status');
const currentTimeElement = document.getElementById('current-time');
const lastUpdateTime = document.getElementById('last-update-time');
const scrollDownBtn = document.getElementById('scroll-down-btn');

// Initialize
updateClock();
setInterval(updateClock, 1000);
setTimeout(() => {
    typingIndicator.style.display = 'none';
    addMessage('received',
        `<div class="prediction-card">
            <div class="prediction-title"><i class="fas fa-robot"></i> SYSTEM INITIALIZED</div>
            <p>Welcome to <strong>LICUIS ULTRA 32</strong>, Advanced AI models are analyzing game patterns in real-time to provide you with the most accurate predictions.</p>
        </div>`,
        'LICUIS ULTRA');
    simulateInitialAnalysis();
}, 1500);

// Scroll button functionality
scrollDownBtn.addEventListener('click', () => {
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
});

messagesContainer.addEventListener('scroll', () => {
    const {
        scrollTop,
        scrollHeight,
        clientHeight
    } = messagesContainer;
    const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
    scrollDownBtn.classList.toggle('visible', distanceFromBottom > 100);
});

function updateClock() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('en-US', {
        hour12: false
    });
    currentTimeElement.textContent = timeString;
    return now;
}

function formatTime(date) {
    return date.toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit'
    });
}

function addMessage(type, content, sender, timestamp = new Date()) {
    typingIndicator.style.display = 'none';

    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}`;

    if (sender) {
        messageDiv.innerHTML = `<div class="prediction-title">${sender}</div>`;
    }

    messageDiv.innerHTML += content;
    messageDiv.innerHTML += `<div class="timestamp">${formatTime(timestamp)}</div>`;

    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    // Update last update time
    lastUpdateTime.textContent = formatTime(timestamp);

    return messageDiv;
}

function showTyping() {
    typingIndicator.style.display = 'flex';
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function simulateInitialAnalysis() {
    showTyping();
    setTimeout(() => {
        addMessage('received',
            `<div class="prediction-card">
                <div class="prediction-title"><i class="fas fa-check-circle"></i> ANALYSIS COMPLETE</div>
                <p>AI pattern detection complete. Advanced algorithms initialized and ready for predictions.</p>
            </div>`,
            'LICUIS ULTRA');

        // Start the prediction cycle
        fetchCurrentGameIssue();
        setInterval(fetchCurrentGameIssue, 5000);
    }, 2000);
}

function createPredictionMessage(predictionData) {
    // Use the final prediction data confidence
    const confidencePercentage = Math.round(parseFloat(predictionData.confidence));
    const confidenceWidth = `${confidencePercentage}%`;

    return `
        <div class="prediction-card">
            <div class="period-display">${latestPeriod}</div>
            <div class="prediction-value">${predictionData.size}</div>

            <div class="progress-bar">
                <div class="progress-fill" style="width: ${confidenceWidth}"></div>
            </div>
            <div class="confidence-display">
                <span>Confidence</span>
                <span class="confidence-value">${confidencePercentage}%</span>
            </div>
        </div>
    `;
}

async function fetchCurrentGameIssue() {
    const now = new Date();
    const apiUrl = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
    const requestData = {
        typeId: 1,
        language: 0,
        random: "40079dcba93a48769c6ee9d4d4fae23f",
        signature: "D12108C4F57C549D82B23A91E0FA20AE",
        timestamp: 1727792520
    };

    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json;charset=UTF-8'
            },
            body: JSON.stringify(requestData)
        });

        if (response.ok) {
            const data = await response.json();
            if (data.code === 0) {
                const newPeriod = data.data.issueNumber;

                if (newPeriod !== latestPeriod) {
                    if (latestPeriod && currentPrediction && previousResults.length > 0) {
                        const lastResult = previousResults[0].number;
                        lastActualNumber = parseInt(lastResult, 10);
                        const actualPrediction = getBigSmallOutcome(lastActualNumber);
                        
                        // Update the new AI prediction system with actual result
                        // The prediction made *in the previous cycle* is stored in infinityCoreAI.lastPrediction
                        infinityCoreAI.updateModelPerformance(actualPrediction);

                        // Update the high-level predictor's mode/streak using its updated Reinforcement method
                        enhancedPredictor.updateReinforcement(actualPrediction);

                        // Note: The loss/win streaks are now centrally managed in the AIPredictionSystem
                    }

                    latestPeriod = newPeriod;
                    await fetchPreviousResults();
                    updatePredictions(now, newPeriod);
                }
            }
        } else {
            updateServerStatus(false);
        }
    } catch (error) {
        console.error("Fetch error:", error);
        updateServerStatus(false);
    }
}

async function fetchPreviousResults() {
    const apiUrl = 'https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList';
    const requestData = {
        pageSize: 10,
        pageNo: 1,
        typeId: 1,
        language: 0,
        random: "c2505d9138da4e3780b2c2b34f2fb789",
        signature: "7D637E060DA35C0C6E28DC6D23D71BED",
        timestamp: 1727792520
    };

    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json;charset=UTF-8'
            },
            body: JSON.stringify(requestData)
        });

        if (response.ok) {
            const data = await response.json();
            if (data.code === 0 && data.data.list.length > 0) {
                previousResults = data.data.list;

                // Update AI prediction system history
                const historyData = data.data.list.map(item => ({
                    number: parseInt(item.number, 10),
                    period: item.issueNumber
                }));

                // The history is used by the models as-is (newest first)
                infinityCoreAI.history = historyData;

                updateServerStatus(true);
            }
        } else {
            updateServerStatus(false);
        }
    } catch (error) {
        console.error("Fetch error:", error);
        updateServerStatus(false);
    }
}

async function updatePredictions(currentTime, currentPeriod) {
    if (previousResults.length >= 10 && currentPeriod !== lastPredictionPeriod) {
        // Use the EnhancedOppositePredictor which wraps the new Core AI
        const predictionData = await enhancedPredictor.generateOppositePrediction(infinityCoreAI.history);

        // The displayed prediction is the direct one
        const finalPrediction = predictionData.displayedPrediction;
        const finalConfidence = predictionData.displayedConfidence;
        
        // Track the *direct* prediction for learning purposes in the next cycle
        infinityCoreAI.lastPrediction = finalPrediction;

        currentPrediction = finalPrediction;
        lastPredictionPeriod = currentPeriod;
            // Show prediction message
            showTyping();
            setTimeout(() => {
                addMessage('received', createPredictionMessage({
                    size: finalPrediction,
                    confidence: finalConfidence
                }), 'LICUIS ULTRA');
            }, 1000);
        }
    }

    function updateServerStatus(online) {
        if (serverOnline !== online) {
            serverOnline = online;
            if (online) {
                connectionStatus.textContent = "Connected to Server";
                document.querySelector('.status-indicator').className = "status-indicator online";
                addMessage('received', '<div class="prediction-title"><i class="fas fa-plug"></i> CONNECTION RESTORED</div><p>Server connection reestablished. Resuming normal operations.</p>', 'System');
            } else {
                connectionStatus.textContent = "Connecting...";
                document.querySelector('.status-indicator').className = "status-indicator offline";
                addMessage('received', '<div class="prediction-title"><i class="fas fa-exclamation-triangle"></i> CONNECTION LOST</div><p>Temporarily lost connection to prediction server. Attempting to reconnect...</p>', 'System');
            }
        }
    }

    // Initialize the application
    createParticles();

    // Animate the game selection title after page load
    setTimeout(() => {
        document.getElementById('gameSelectionTitle').classList.add('animate');
    }, 500);
});
</script>
